{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-\\.]+"},"docs":[{"location":"","text":"JSON for Modern C++ \u00b6 Note This page is under construction.","title":"JSON for Modern C++"},{"location":"#json-for-modern-c","text":"Note This page is under construction.","title":"JSON for Modern C++"},{"location":"api/json/","text":"json \u00b6 using json = basic_json <> ;","title":"json"},{"location":"api/json/#json","text":"using json = basic_json <> ;","title":"json"},{"location":"api/json_pointer/","text":"json_pointer \u00b6 template < typename BasicJsonType > class json_pointer ; Template parameters \u00b6 BasicJsonType a specialization of basic_json Member functions \u00b6 (constructor) to_string - return a string representation of the JSON pointer operator std::string - return a string representation of the JSON pointer operator/= - append to the end of the JSON pointer operator/ - create JSON Pointer by appending parent_pointer - returns the parent of this JSON pointer pop_back - remove last reference token back - return last reference token push_back - append an unescaped token at the end of the pointer empty - return whether pointer points to the root document","title":"json_pointer"},{"location":"api/json_pointer/#json_pointer","text":"template < typename BasicJsonType > class json_pointer ;","title":"json_pointer"},{"location":"api/json_pointer/#template-parameters","text":"BasicJsonType a specialization of basic_json","title":"Template parameters"},{"location":"api/json_pointer/#member-functions","text":"(constructor) to_string - return a string representation of the JSON pointer operator std::string - return a string representation of the JSON pointer operator/= - append to the end of the JSON pointer operator/ - create JSON Pointer by appending parent_pointer - returns the parent of this JSON pointer pop_back - remove last reference token back - return last reference token push_back - append an unescaped token at the end of the pointer empty - return whether pointer points to the root document","title":"Member functions"},{"location":"api/ordered_json/","text":"ordered_json \u00b6 using ordered_json = basic_json < nlohmann :: ordered_map > ;","title":"ordered_json"},{"location":"api/ordered_json/#ordered_json","text":"using ordered_json = basic_json < nlohmann :: ordered_map > ;","title":"ordered_json"},{"location":"api/ordered_map/","text":"ordered_map \u00b6 template < class Key , class T , class IgnoredLess = std :: less < Key > , class Allocator = std :: allocator < std :: pair < const Key , T >>> struct ordered_map : std :: vector < std :: pair < const Key , T > , Allocator > ;","title":"ordered_map"},{"location":"api/ordered_map/#ordered_map","text":"template < class Key , class T , class IgnoredLess = std :: less < Key > , class Allocator = std :: allocator < std :: pair < const Key , T >>> struct ordered_map : std :: vector < std :: pair < const Key , T > , Allocator > ;","title":"ordered_map"},{"location":"api/basic_json/","text":"basic_json \u00b6 Note This page is under construction. Defined in header <json.hpp> template < template < typename U , typename V , typename ... Args > class ObjectType = std :: map , template < typename U , typename ... Args > class ArrayType = std :: vector , class StringType = std :: string , class BooleanType = bool , class NumberIntegerType = std :: int64_t , class NumberUnsignedType = std :: uint64_t , class NumberFloatType = double , template < typename U > class AllocatorType = std :: allocator , template < typename T , typename SFINAE = void > class JSONSerializer = adl_serializer , class BinaryType = std :: vector < std :: uint8_t > > class basic_json ; Specializations \u00b6 json - default specialization ordered_json - specialization that maintains the insertion order of object keys Template parameters \u00b6 Template parameter Description Derived type ObjectType type for JSON objects object_t ArrayType type for JSON arrays array_t StringType type for JSON strings and object keys string_t BooleanType type for JSON booleans boolean_t NumberIntegerType type for JSON integer numbers number_integer_t NumberUnsignedType type for JSON unsigned integer numbers number_unsigned_t NumberFloatType type for JSON floating-point numbers number_float_t AllocatorType type of the allocator to use JSONSerializer the serializer to resolve internal calls to to_json() and from_json() BinaryType type for binary arrays binary_t Iterator invalidation \u00b6 Todo Member types \u00b6 value_t - the JSON type enumeration json_pointer - JSON Pointer implementation json_serializer error_handler_t - type to choose behavior on decoding errors cbor_tag_handler_t initializer_list_t input_format_t json_sax_t Exceptions \u00b6 exception parse_error invalid_iterator type_error out_of_range other_error Container types \u00b6 Type Definition value_type basic_json reference value_type & const_reference const value_type & difference_type std :: ptrdiff_t size_type std :: size_t allocator_type AllocatorType < basic_json > pointer std :: allocator_traits < allocator_type >:: pointer const_pointer std :: allocator_traits < allocator_type >:: const_pointer iterator LegacyBidirectionalIterator const_iterator constant LegacyBidirectionalIterator reverse_iterator const_reverse_iterator iteration_proxy JSON value data types \u00b6 object_comparator_t object_t - type for objects array_t - type for arrays string_t - type for strings boolean_t - type for booleans number_integer_t - type for numbers (integer) number_unsigned_t - type for numbers (unsigned) number_float_t - type for numbers (floating-point) binary_t Parser callback \u00b6 parse_event_t - parser event types parser_callback_t - per-element parser callback type Member functions \u00b6 (constructor) (destructor) operator= - copy assignment array (static) - explicitly create an array binary (static) - explicitly create a binary array object (static) - explicitly create an object Object inspection \u00b6 Functions to inspect the type of a JSON value. type - return the type of the JSON value operator value_t - return the type of the JSON value type_name - return the type as string is_primitive - return whether type is primitive is_structured - return whether type is structured is_null - return whether value is null is_boolean - return whether value is a boolean is_number - return whether value is a number is_number_integer - return whether value is an integer number is_number_unsigned - return whether value is an unsigned integer number is_number_float - return whether value is a floating-point number is_object - return whether value is an object is_array - return whether value is an array is_string - return whether value is a string is_binary - return whether value is a binary array is_discarded - return whether value is discarded Value access \u00b6 Direct access to the stored value of a JSON value. get - get a value get_to - get a value get_ptr - get a pointer value get_ref - get a reference value operator ValueType - get a value get_binary - get a binary value Element access \u00b6 Access to the JSON value at - access specified element with bounds checking operator[] - access specified element value - access specified object element with default value front - access the first element back - access the last element Lookup \u00b6 find - find an element in a JSON object count - returns the number of occurrences of a key in a JSON object contains - check the existence of an element in a JSON object Iterators \u00b6 begin - returns an iterator to the first element cbegin - returns a const iterator to the first element end - returns an iterator to one past the last element cend - returns a const iterator to one past the last element rbegin - returns an iterator to the reverse-beginning rend - returns an iterator to the reverse-end crbegin - returns a const iterator to the reverse-beginning crend - returns a const iterator to the reverse-end items - wrapper to access iterator member functions in range-based for Capacity \u00b6 empty - checks whether the container is empty size - returns the number of elements max_size - returns the maximum possible number of elements Modifiers \u00b6 clear - clears the contents push_back - add a value to an array/object operator+= - add a value to an array/object emplace_back - add a value to an array emplace - add a value to an object if key does not exist erase - remove elements insert - inserts elements update - updates a JSON object from another object, overwriting existing keys swap - exchanges the values Lexicographical comparison operators \u00b6 operator== - comparison: equal operator!= - comparison: not equal operator< - comparison: less than operator<= - comparison: less than or equal operator> - comparison: greater than operator>= - comparison: greater than or equal Serialization \u00b6 dump - serialization to_string - user-defined to_string function for JSON values Deserialization \u00b6 parse (static) - deserialize from a compatible input accept (static) - check if the input is valid JSON sax_parse (static) - generate SAX events JSON Pointer functions \u00b6 flatten - return flattened JSON value unflatten - unflatten a previously flattened JSON value JSON Patch functions \u00b6 patch - applies a JSON patch diff (static) - creates a diff as a JSON patch JSON Merge Patch functions \u00b6 merge_patch - applies a JSON Merge Patch Static functions \u00b6 meta - returns version information on the library get_allocator - returns the allocator associated with the container Binary formats \u00b6 from_bson (static) - create a JSON value from an input in BSON format from_cbor (static) - create a JSON value from an input in CBOR format from_msgpack (static) - create a JSON value from an input in MessagePack format from_ubjson (static) - create a JSON value from an input in UBJSON format to_bson (static) - create a BSON serialization of a given JSON value to_cbor (static) - create a CBOR serialization of a given JSON value to_msgpack (static) - create a MessagePack serialization of a given JSON value to_ubjson (static) - create a UBJSON serialization of a given JSON value Non-member functions \u00b6 operator<<(std::ostream&) - serialize to stream operator>>(std::istream&) - deserialize from stream Literals \u00b6 operator\"\"_json - user-defined string literal for JSON values operator\"\"_json_pointer - user-defined string literal for JSON pointers Helper classes \u00b6 std::hash<nlohmann::json> std::less<nlohmann::value_t> std::swap<nlohmann::json>","title":"basic_json"},{"location":"api/basic_json/#basic_json","text":"Note This page is under construction. Defined in header <json.hpp> template < template < typename U , typename V , typename ... Args > class ObjectType = std :: map , template < typename U , typename ... Args > class ArrayType = std :: vector , class StringType = std :: string , class BooleanType = bool , class NumberIntegerType = std :: int64_t , class NumberUnsignedType = std :: uint64_t , class NumberFloatType = double , template < typename U > class AllocatorType = std :: allocator , template < typename T , typename SFINAE = void > class JSONSerializer = adl_serializer , class BinaryType = std :: vector < std :: uint8_t > > class basic_json ;","title":"basic_json"},{"location":"api/basic_json/#specializations","text":"json - default specialization ordered_json - specialization that maintains the insertion order of object keys","title":"Specializations"},{"location":"api/basic_json/#template-parameters","text":"Template parameter Description Derived type ObjectType type for JSON objects object_t ArrayType type for JSON arrays array_t StringType type for JSON strings and object keys string_t BooleanType type for JSON booleans boolean_t NumberIntegerType type for JSON integer numbers number_integer_t NumberUnsignedType type for JSON unsigned integer numbers number_unsigned_t NumberFloatType type for JSON floating-point numbers number_float_t AllocatorType type of the allocator to use JSONSerializer the serializer to resolve internal calls to to_json() and from_json() BinaryType type for binary arrays binary_t","title":"Template parameters"},{"location":"api/basic_json/#iterator-invalidation","text":"Todo","title":"Iterator invalidation"},{"location":"api/basic_json/#member-types","text":"value_t - the JSON type enumeration json_pointer - JSON Pointer implementation json_serializer error_handler_t - type to choose behavior on decoding errors cbor_tag_handler_t initializer_list_t input_format_t json_sax_t","title":"Member types"},{"location":"api/basic_json/#exceptions","text":"exception parse_error invalid_iterator type_error out_of_range other_error","title":"Exceptions"},{"location":"api/basic_json/#container-types","text":"Type Definition value_type basic_json reference value_type & const_reference const value_type & difference_type std :: ptrdiff_t size_type std :: size_t allocator_type AllocatorType < basic_json > pointer std :: allocator_traits < allocator_type >:: pointer const_pointer std :: allocator_traits < allocator_type >:: const_pointer iterator LegacyBidirectionalIterator const_iterator constant LegacyBidirectionalIterator reverse_iterator const_reverse_iterator iteration_proxy","title":"Container types"},{"location":"api/basic_json/#json-value-data-types","text":"object_comparator_t object_t - type for objects array_t - type for arrays string_t - type for strings boolean_t - type for booleans number_integer_t - type for numbers (integer) number_unsigned_t - type for numbers (unsigned) number_float_t - type for numbers (floating-point) binary_t","title":"JSON value data types"},{"location":"api/basic_json/#parser-callback","text":"parse_event_t - parser event types parser_callback_t - per-element parser callback type","title":"Parser callback"},{"location":"api/basic_json/#member-functions","text":"(constructor) (destructor) operator= - copy assignment array (static) - explicitly create an array binary (static) - explicitly create a binary array object (static) - explicitly create an object","title":"Member functions"},{"location":"api/basic_json/#object-inspection","text":"Functions to inspect the type of a JSON value. type - return the type of the JSON value operator value_t - return the type of the JSON value type_name - return the type as string is_primitive - return whether type is primitive is_structured - return whether type is structured is_null - return whether value is null is_boolean - return whether value is a boolean is_number - return whether value is a number is_number_integer - return whether value is an integer number is_number_unsigned - return whether value is an unsigned integer number is_number_float - return whether value is a floating-point number is_object - return whether value is an object is_array - return whether value is an array is_string - return whether value is a string is_binary - return whether value is a binary array is_discarded - return whether value is discarded","title":"Object inspection"},{"location":"api/basic_json/#value-access","text":"Direct access to the stored value of a JSON value. get - get a value get_to - get a value get_ptr - get a pointer value get_ref - get a reference value operator ValueType - get a value get_binary - get a binary value","title":"Value access"},{"location":"api/basic_json/#element-access","text":"Access to the JSON value at - access specified element with bounds checking operator[] - access specified element value - access specified object element with default value front - access the first element back - access the last element","title":"Element access"},{"location":"api/basic_json/#lookup","text":"find - find an element in a JSON object count - returns the number of occurrences of a key in a JSON object contains - check the existence of an element in a JSON object","title":"Lookup"},{"location":"api/basic_json/#iterators","text":"begin - returns an iterator to the first element cbegin - returns a const iterator to the first element end - returns an iterator to one past the last element cend - returns a const iterator to one past the last element rbegin - returns an iterator to the reverse-beginning rend - returns an iterator to the reverse-end crbegin - returns a const iterator to the reverse-beginning crend - returns a const iterator to the reverse-end items - wrapper to access iterator member functions in range-based for","title":"Iterators"},{"location":"api/basic_json/#capacity","text":"empty - checks whether the container is empty size - returns the number of elements max_size - returns the maximum possible number of elements","title":"Capacity"},{"location":"api/basic_json/#modifiers","text":"clear - clears the contents push_back - add a value to an array/object operator+= - add a value to an array/object emplace_back - add a value to an array emplace - add a value to an object if key does not exist erase - remove elements insert - inserts elements update - updates a JSON object from another object, overwriting existing keys swap - exchanges the values","title":"Modifiers"},{"location":"api/basic_json/#lexicographical-comparison-operators","text":"operator== - comparison: equal operator!= - comparison: not equal operator< - comparison: less than operator<= - comparison: less than or equal operator> - comparison: greater than operator>= - comparison: greater than or equal","title":"Lexicographical comparison operators"},{"location":"api/basic_json/#serialization","text":"dump - serialization to_string - user-defined to_string function for JSON values","title":"Serialization"},{"location":"api/basic_json/#deserialization","text":"parse (static) - deserialize from a compatible input accept (static) - check if the input is valid JSON sax_parse (static) - generate SAX events","title":"Deserialization"},{"location":"api/basic_json/#json-pointer-functions","text":"flatten - return flattened JSON value unflatten - unflatten a previously flattened JSON value","title":"JSON Pointer functions"},{"location":"api/basic_json/#json-patch-functions","text":"patch - applies a JSON patch diff (static) - creates a diff as a JSON patch","title":"JSON Patch functions"},{"location":"api/basic_json/#json-merge-patch-functions","text":"merge_patch - applies a JSON Merge Patch","title":"JSON Merge Patch functions"},{"location":"api/basic_json/#static-functions","text":"meta - returns version information on the library get_allocator - returns the allocator associated with the container","title":"Static functions"},{"location":"api/basic_json/#binary-formats","text":"from_bson (static) - create a JSON value from an input in BSON format from_cbor (static) - create a JSON value from an input in CBOR format from_msgpack (static) - create a JSON value from an input in MessagePack format from_ubjson (static) - create a JSON value from an input in UBJSON format to_bson (static) - create a BSON serialization of a given JSON value to_cbor (static) - create a CBOR serialization of a given JSON value to_msgpack (static) - create a MessagePack serialization of a given JSON value to_ubjson (static) - create a UBJSON serialization of a given JSON value","title":"Binary formats"},{"location":"api/basic_json/#non-member-functions","text":"operator<<(std::ostream&) - serialize to stream operator>>(std::istream&) - deserialize from stream","title":"Non-member functions"},{"location":"api/basic_json/#literals","text":"operator\"\"_json - user-defined string literal for JSON values operator\"\"_json_pointer - user-defined string literal for JSON pointers","title":"Literals"},{"location":"api/basic_json/#helper-classes","text":"std::hash<nlohmann::json> std::less<nlohmann::value_t> std::swap<nlohmann::json>","title":"Helper classes"},{"location":"api/basic_json/accept/","text":"basic_json::accept \u00b6 // (1) template < typename InputType > static bool accept ( InputType && i , const bool ignore_comments = false ); // (2) template < typename IteratorType > static bool accept ( IteratorType first , IteratorType last , const bool ignore_comments = false ); Checks whether the input is valid JSON. Reads from a compatible input. Reads from a pair of character iterators The value_type of the iterator must be a integral type with size of 1, 2 or 4 bytes, which will be interpreted respectively as UTF-8, UTF-16 and UTF-32. Unlike the parse function, this function neither throws an exception in case of invalid JSON input (i.e., a parse error) nor creates diagnostic information. Template parameters \u00b6 InputType A compatible input, for instance: an std::istream object a FILE pointer a C-style array of characters a pointer to a null-terminated string of single byte characters an object obj for which begin(obj) and end(obj) produces a valid pair of iterators. IteratorType a compatible iterator type Parameters \u00b6 i (in) Input to parse from. ignore_comments (in) whether comments should be ignored and treated like whitespace ( true ) or yield a parse error ( false ); (optional, false by default) first (in) iterator to start of character range last (in) iterator to end of character range Return value \u00b6 Whether the input is valid JSON. Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Linear in the length of the input. The parser is a predictive LL(1) parser. Notes \u00b6 (1) A UTF-8 byte order mark is silently ignored. Examples \u00b6 Example The example below demonstrates the accept() function reading from a string. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // a valid JSON text auto valid_text = R \" ( { \"numbers\": [1, 2, 3] } ) \" ; // an invalid JSON text auto invalid_text = R \" ( { \"strings\": [\"extra\", \"comma\", ] } ) \" ; std :: cout << std :: boolalpha << json :: accept ( valid_text ) << ' ' << json :: accept ( invalid_text ) << '\\n' ; } Output: true false Version history \u00b6 Added in version 3.0.0. Ignoring comments via ignore_comments added in version 3.9.0.","title":"basic_json::accept"},{"location":"api/basic_json/accept/#basic_jsonaccept","text":"// (1) template < typename InputType > static bool accept ( InputType && i , const bool ignore_comments = false ); // (2) template < typename IteratorType > static bool accept ( IteratorType first , IteratorType last , const bool ignore_comments = false ); Checks whether the input is valid JSON. Reads from a compatible input. Reads from a pair of character iterators The value_type of the iterator must be a integral type with size of 1, 2 or 4 bytes, which will be interpreted respectively as UTF-8, UTF-16 and UTF-32. Unlike the parse function, this function neither throws an exception in case of invalid JSON input (i.e., a parse error) nor creates diagnostic information.","title":"basic_json::accept"},{"location":"api/basic_json/accept/#template-parameters","text":"InputType A compatible input, for instance: an std::istream object a FILE pointer a C-style array of characters a pointer to a null-terminated string of single byte characters an object obj for which begin(obj) and end(obj) produces a valid pair of iterators. IteratorType a compatible iterator type","title":"Template parameters"},{"location":"api/basic_json/accept/#parameters","text":"i (in) Input to parse from. ignore_comments (in) whether comments should be ignored and treated like whitespace ( true ) or yield a parse error ( false ); (optional, false by default) first (in) iterator to start of character range last (in) iterator to end of character range","title":"Parameters"},{"location":"api/basic_json/accept/#return-value","text":"Whether the input is valid JSON.","title":"Return value"},{"location":"api/basic_json/accept/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/accept/#complexity","text":"Linear in the length of the input. The parser is a predictive LL(1) parser.","title":"Complexity"},{"location":"api/basic_json/accept/#notes","text":"(1) A UTF-8 byte order mark is silently ignored.","title":"Notes"},{"location":"api/basic_json/accept/#examples","text":"Example The example below demonstrates the accept() function reading from a string. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // a valid JSON text auto valid_text = R \" ( { \"numbers\": [1, 2, 3] } ) \" ; // an invalid JSON text auto invalid_text = R \" ( { \"strings\": [\"extra\", \"comma\", ] } ) \" ; std :: cout << std :: boolalpha << json :: accept ( valid_text ) << ' ' << json :: accept ( invalid_text ) << '\\n' ; } Output: true false","title":"Examples"},{"location":"api/basic_json/accept/#version-history","text":"Added in version 3.0.0. Ignoring comments via ignore_comments added in version 3.9.0.","title":"Version history"},{"location":"api/basic_json/array/","text":"basic_json::array \u00b6 static basic_json array ( initializer_list_t init = {}); Creates a JSON array value from a given initializer list. That is, given a list of values a, b, c , creates the JSON value [ a , b , c ] . If the initializer list is empty, the empty array [] is created. Parameters \u00b6 init (in) initializer list with JSON values to create an array from (optional) Return value \u00b6 JSON array value Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Linear in the size of init . Notes \u00b6 This function is only needed to express two edge cases that cannot be realized with the initializer list constructor ( basic_json(initializer_list_t, bool, value_t) ). These cases are: creating an array whose elements are all pairs whose first element is a string -- in this case, the initializer list constructor would create an object, taking the first elements as keys creating an empty array -- passing the empty initializer list to the initializer list constructor yields an empty object Examples \u00b6 Example The following code shows an example for the array function. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON arrays json j_no_init_list = json :: array (); json j_empty_init_list = json :: array ({}); json j_nonempty_init_list = json :: array ({ 1 , 2 , 3 , 4 }); json j_list_of_pairs = json :: array ({ { \"one\" , 1 }, { \"two\" , 2 } }); // serialize the JSON arrays std :: cout << j_no_init_list << '\\n' ; std :: cout << j_empty_init_list << '\\n' ; std :: cout << j_nonempty_init_list << '\\n' ; std :: cout << j_list_of_pairs << '\\n' ; } Output: [] [] [ 1 , 2 , 3 , 4 ] [[ \"one\" , 1 ],[ \"two\" , 2 ]] Version history \u00b6 Added in version 1.0.0.","title":"basic_json::array"},{"location":"api/basic_json/array/#basic_jsonarray","text":"static basic_json array ( initializer_list_t init = {}); Creates a JSON array value from a given initializer list. That is, given a list of values a, b, c , creates the JSON value [ a , b , c ] . If the initializer list is empty, the empty array [] is created.","title":"basic_json::array"},{"location":"api/basic_json/array/#parameters","text":"init (in) initializer list with JSON values to create an array from (optional)","title":"Parameters"},{"location":"api/basic_json/array/#return-value","text":"JSON array value","title":"Return value"},{"location":"api/basic_json/array/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/array/#complexity","text":"Linear in the size of init .","title":"Complexity"},{"location":"api/basic_json/array/#notes","text":"This function is only needed to express two edge cases that cannot be realized with the initializer list constructor ( basic_json(initializer_list_t, bool, value_t) ). These cases are: creating an array whose elements are all pairs whose first element is a string -- in this case, the initializer list constructor would create an object, taking the first elements as keys creating an empty array -- passing the empty initializer list to the initializer list constructor yields an empty object","title":"Notes"},{"location":"api/basic_json/array/#examples","text":"Example The following code shows an example for the array function. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON arrays json j_no_init_list = json :: array (); json j_empty_init_list = json :: array ({}); json j_nonempty_init_list = json :: array ({ 1 , 2 , 3 , 4 }); json j_list_of_pairs = json :: array ({ { \"one\" , 1 }, { \"two\" , 2 } }); // serialize the JSON arrays std :: cout << j_no_init_list << '\\n' ; std :: cout << j_empty_init_list << '\\n' ; std :: cout << j_nonempty_init_list << '\\n' ; std :: cout << j_list_of_pairs << '\\n' ; } Output: [] [] [ 1 , 2 , 3 , 4 ] [[ \"one\" , 1 ],[ \"two\" , 2 ]]","title":"Examples"},{"location":"api/basic_json/array/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/array_t/","text":"basic_json::array_t \u00b6 using array_t = ArrayType < basic_json , AllocatorType < basic_json >> ; The type used to store JSON arrays. RFC 7159 describes JSON arrays as follows: An array is an ordered sequence of zero or more values. To store objects in C++, a type is defined by the template parameters explained below. Template parameters \u00b6 ArrayType container type to store arrays (e.g., std::vector or std::list ) AllocatorType the allocator to use for objects (e.g., std::allocator ) Notes \u00b6 Default type \u00b6 With the default values for ArrayType ( std::vector ) and AllocatorType ( std::allocator ), the default value for array_t is: std :: vector < basic_json , // value_type std :: allocator < basic_json > // allocator_type > Limits \u00b6 RFC 7159 specifies: An implementation may set limits on the maximum depth of nesting. In this class, the array's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the max_size function of a JSON array. Storage \u00b6 Arrays are stored as pointers in a basic_json type. That is, for any access to array values, a pointer of type array_t * must be dereferenced. Version history \u00b6 Added in version 1.0.0.","title":"basic_json::array_t"},{"location":"api/basic_json/array_t/#basic_jsonarray_t","text":"using array_t = ArrayType < basic_json , AllocatorType < basic_json >> ; The type used to store JSON arrays. RFC 7159 describes JSON arrays as follows: An array is an ordered sequence of zero or more values. To store objects in C++, a type is defined by the template parameters explained below.","title":"basic_json::array_t"},{"location":"api/basic_json/array_t/#template-parameters","text":"ArrayType container type to store arrays (e.g., std::vector or std::list ) AllocatorType the allocator to use for objects (e.g., std::allocator )","title":"Template parameters"},{"location":"api/basic_json/array_t/#notes","text":"","title":"Notes"},{"location":"api/basic_json/array_t/#default-type","text":"With the default values for ArrayType ( std::vector ) and AllocatorType ( std::allocator ), the default value for array_t is: std :: vector < basic_json , // value_type std :: allocator < basic_json > // allocator_type >","title":"Default type"},{"location":"api/basic_json/array_t/#limits","text":"RFC 7159 specifies: An implementation may set limits on the maximum depth of nesting. In this class, the array's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the max_size function of a JSON array.","title":"Limits"},{"location":"api/basic_json/array_t/#storage","text":"Arrays are stored as pointers in a basic_json type. That is, for any access to array values, a pointer of type array_t * must be dereferenced.","title":"Storage"},{"location":"api/basic_json/array_t/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/at/","text":"basic_json::at \u00b6 // (1) reference at ( size_type idx ); const_reference at ( size_type idx ) const ; // (2) reference at ( const typename object_t :: key_type & key ); const_reference at ( const typename object_t :: key_type & key ) const ; // (3) reference at ( const json_pointer & ptr ); const_reference at ( const json_pointer & ptr ) const ; Returns a reference to the element at specified location idx , with bounds checking. Returns a reference to the element at with specified key key , with bounds checking. Returns a reference to the element at with specified JSON pointer ptr , with bounds checking. Parameters \u00b6 idx (in) index of the element to access key (in) object key of the elements to remove ptr (in) JSON pointer to the desired element Return value \u00b6 reference to the element at index idx reference to the element at key key reference to the element pointed to by ptr Exceptions \u00b6 The function can throw the following exceptions: Throws type_error.304 if the JSON value is not an array; in this case, calling at with an index makes no sense. See example below. Throws out_of_range.401 if the index idx is out of range of the array; that is, idx >= size() . See example below. The function can throw the following exceptions: Throws type_error.304 if the JSON value is not an object; in this case, calling at with a key makes no sense. See example below. Throws out_of_range.403 if the key key is is not stored in the object; that is, find(key) == end() . See example below. The function can throw the following exceptions: Throws parse_error.106 if an array index in the passed JSON pointer ptr begins with '0'. See example below. Throws parse_error.109 if an array index in the passed JSON pointer ptr is not a number. See example below. Throws out_of_range.401 if an array index in the passed JSON pointer ptr is out of range. See example below. Throws out_of_range.402 if the array index '-' is used in the passed JSON pointer ptr . As at provides checked access (and no elements are implicitly inserted), the index '-' is always invalid. See example below. Throws out_of_range.403 if the JSON pointer describes a key of an object which cannot be found. See example below. Throws out_of_range.404 if the JSON pointer ptr can not be resolved. See example below. Exception safety \u00b6 Strong exception safety: if an exception occurs, the original value stays intact. Complexity \u00b6 Constant Logarithmic in the size of the container. Constant Example \u00b6 Example The example below shows how array elements can be read and written using at() . It also demonstrates the different exceptions that can be thrown. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON array json array = { \"first\" , \"2nd\" , \"third\" , \"fourth\" }; // output element at index 2 (third element) std :: cout << array . at ( 2 ) << '\\n' ; // change element at index 1 (second element) to \"second\" array . at ( 1 ) = \"second\" ; // output changed array std :: cout << array << '\\n' ; // exception type_error.304 try { // use at() on a non-array type json str = \"I am a string\" ; str . at ( 0 ) = \"Another string\" ; } catch ( json :: type_error & e ) { std :: cout << e . what () << '\\n' ; } // exception out_of_range.401 try { // try to write beyond the array limit array . at ( 5 ) = \"sixth\" ; } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } } Output: \"third\" [ \"first\" , \"second\" , \"third\" , \"fourth\" ] [ json.exception.type_error. 304 ] cannot use at() with string [ json.exception.out_of_range. 401 ] array index 5 is out of range Example The example below shows how array elements can be read using at() . It also demonstrates the different exceptions that can be thrown. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON array const json array = { \"first\" , \"2nd\" , \"third\" , \"fourth\" }; // output element at index 2 (third element) std :: cout << array . at ( 2 ) << '\\n' ; // exception type_error.304 try { // use at() on a non-array type const json str = \"I am a string\" ; std :: cout << str . at ( 0 ) << '\\n' ; } catch ( json :: type_error & e ) { std :: cout << e . what () << '\\n' ; } // exception out_of_range.401 try { // try to read beyond the array limit std :: cout << array . at ( 5 ) << '\\n' ; } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } } Output: \"third\" [ json.exception.type_error. 304 ] cannot use at() with string [ json.exception.out_of_range. 401 ] array index 5 is out of range Example The example below shows how object elements can be read and written using at() . It also demonstrates the different exceptions that can be thrown. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON object json object = { { \"the good\" , \"il buono\" }, { \"the bad\" , \"il cattivo\" }, { \"the ugly\" , \"il brutto\" } }; // output element with key \"the ugly\" std :: cout << object . at ( \"the ugly\" ) << '\\n' ; // change element with key \"the bad\" object . at ( \"the bad\" ) = \"il cattivo\" ; // output changed array std :: cout << object << '\\n' ; // exception type_error.304 try { // use at() on a non-object type json str = \"I am a string\" ; str . at ( \"the good\" ) = \"Another string\" ; } catch ( json :: type_error & e ) { std :: cout << e . what () << '\\n' ; } // exception out_of_range.401 try { // try to write at a nonexisting key object . at ( \"the fast\" ) = \"il rapido\" ; } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } } Output: \"il brutto\" { \"the bad\" : \"il cattivo\" , \"the good\" : \"il buono\" , \"the ugly\" : \"il brutto\" } [ json.exception.type_error. 304 ] cannot use at() with string [ json.exception.out_of_range. 403 ] key 'the fast' not found Example The example below shows how object elements can be read using at() . It also demonstrates the different exceptions that can be thrown. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON object const json object = { { \"the good\" , \"il buono\" }, { \"the bad\" , \"il cattivo\" }, { \"the ugly\" , \"il brutto\" } }; // output element with key \"the ugly\" std :: cout << object . at ( \"the ugly\" ) << '\\n' ; // exception type_error.304 try { // use at() on a non-object type const json str = \"I am a string\" ; std :: cout << str . at ( \"the good\" ) << '\\n' ; } catch ( json :: type_error & e ) { std :: cout << e . what () << '\\n' ; } // exception out_of_range.401 try { // try to read from a nonexisting key std :: cout << object . at ( \"the fast\" ) << '\\n' ; } catch ( json :: out_of_range ) { std :: cout << \"out of range\" << '\\n' ; } } Output: \"il brutto\" [ json.exception.type_error. 304 ] cannot use at() with string out of range Example The example below shows how object elements can be read and written using at() . It also demonstrates the different exceptions that can be thrown. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = { { \"number\" , 1 }, { \"string\" , \"foo\" }, { \"array\" , { 1 , 2 }} }; // read-only access // output element with JSON pointer \"/number\" std :: cout << j . at ( \"/number\" _json_pointer ) << '\\n' ; // output element with JSON pointer \"/string\" std :: cout << j . at ( \"/string\" _json_pointer ) << '\\n' ; // output element with JSON pointer \"/array\" std :: cout << j . at ( \"/array\" _json_pointer ) << '\\n' ; // output element with JSON pointer \"/array/1\" std :: cout << j . at ( \"/array/1\" _json_pointer ) << '\\n' ; // writing access // change the string j . at ( \"/string\" _json_pointer ) = \"bar\" ; // output the changed string std :: cout << j [ \"string\" ] << '\\n' ; // change an array element j . at ( \"/array/1\" _json_pointer ) = 21 ; // output the changed array std :: cout << j [ \"array\" ] << '\\n' ; // out_of_range.106 try { // try to use an array index with leading '0' json :: reference ref = j . at ( \"/array/01\" _json_pointer ); } catch ( json :: parse_error & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.109 try { // try to use an array index that is not a number json :: reference ref = j . at ( \"/array/one\" _json_pointer ); } catch ( json :: parse_error & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.401 try { // try to use a an invalid array index json :: reference ref = j . at ( \"/array/4\" _json_pointer ); } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.402 try { // try to use the array index '-' json :: reference ref = j . at ( \"/array/-\" _json_pointer ); } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.403 try { // try to use a JSON pointer to an nonexistent object key json :: const_reference ref = j . at ( \"/foo\" _json_pointer ); } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.404 try { // try to use a JSON pointer that cannot be resolved json :: reference ref = j . at ( \"/number/foo\" _json_pointer ); } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } } Output: 1 \"foo\" [ 1 , 2 ] 2 \"bar\" [ 1 , 21 ] [ json.exception.parse_error. 106 ] parse error: array index ' 01 ' must not begin with ' 0 ' [ json.exception.parse_error. 109 ] parse error: array index 'one' is not a number [ json.exception.out_of_range. 401 ] array index 4 is out of range [ json.exception.out_of_range. 402 ] array index '-' ( 2 ) is out of range [ json.exception.out_of_range. 403 ] key 'foo' not found [ json.exception.out_of_range. 404 ] unresolved reference token 'foo' Example The example below shows how object elements can be read using at() . It also demonstrates the different exceptions that can be thrown. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value const json j = { { \"number\" , 1 }, { \"string\" , \"foo\" }, { \"array\" , { 1 , 2 }} }; // read-only access // output element with JSON pointer \"/number\" std :: cout << j . at ( \"/number\" _json_pointer ) << '\\n' ; // output element with JSON pointer \"/string\" std :: cout << j . at ( \"/string\" _json_pointer ) << '\\n' ; // output element with JSON pointer \"/array\" std :: cout << j . at ( \"/array\" _json_pointer ) << '\\n' ; // output element with JSON pointer \"/array/1\" std :: cout << j . at ( \"/array/1\" _json_pointer ) << '\\n' ; // out_of_range.109 try { // try to use an array index that is not a number json :: const_reference ref = j . at ( \"/array/one\" _json_pointer ); } catch ( json :: parse_error & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.401 try { // try to use a an invalid array index json :: const_reference ref = j . at ( \"/array/4\" _json_pointer ); } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.402 try { // try to use the array index '-' json :: const_reference ref = j . at ( \"/array/-\" _json_pointer ); } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.403 try { // try to use a JSON pointer to an nonexistent object key json :: const_reference ref = j . at ( \"/foo\" _json_pointer ); } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.404 try { // try to use a JSON pointer that cannot be resolved json :: const_reference ref = j . at ( \"/number/foo\" _json_pointer ); } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } } Output: 1 \"foo\" [ 1 , 2 ] 2 [ json.exception.parse_error. 109 ] parse error: array index 'one' is not a number [ json.exception.out_of_range. 401 ] array index 4 is out of range [ json.exception.out_of_range. 402 ] array index '-' ( 2 ) is out of range [ json.exception.out_of_range. 403 ] key 'foo' not found [ json.exception.out_of_range. 404 ] unresolved reference token 'foo' Version history \u00b6 Added in version 1.0.0. Added in version 1.0.0. Added in version 2.0.0.","title":"basic_json::at"},{"location":"api/basic_json/at/#basic_jsonat","text":"// (1) reference at ( size_type idx ); const_reference at ( size_type idx ) const ; // (2) reference at ( const typename object_t :: key_type & key ); const_reference at ( const typename object_t :: key_type & key ) const ; // (3) reference at ( const json_pointer & ptr ); const_reference at ( const json_pointer & ptr ) const ; Returns a reference to the element at specified location idx , with bounds checking. Returns a reference to the element at with specified key key , with bounds checking. Returns a reference to the element at with specified JSON pointer ptr , with bounds checking.","title":"basic_json::at"},{"location":"api/basic_json/at/#parameters","text":"idx (in) index of the element to access key (in) object key of the elements to remove ptr (in) JSON pointer to the desired element","title":"Parameters"},{"location":"api/basic_json/at/#return-value","text":"reference to the element at index idx reference to the element at key key reference to the element pointed to by ptr","title":"Return value"},{"location":"api/basic_json/at/#exceptions","text":"The function can throw the following exceptions: Throws type_error.304 if the JSON value is not an array; in this case, calling at with an index makes no sense. See example below. Throws out_of_range.401 if the index idx is out of range of the array; that is, idx >= size() . See example below. The function can throw the following exceptions: Throws type_error.304 if the JSON value is not an object; in this case, calling at with a key makes no sense. See example below. Throws out_of_range.403 if the key key is is not stored in the object; that is, find(key) == end() . See example below. The function can throw the following exceptions: Throws parse_error.106 if an array index in the passed JSON pointer ptr begins with '0'. See example below. Throws parse_error.109 if an array index in the passed JSON pointer ptr is not a number. See example below. Throws out_of_range.401 if an array index in the passed JSON pointer ptr is out of range. See example below. Throws out_of_range.402 if the array index '-' is used in the passed JSON pointer ptr . As at provides checked access (and no elements are implicitly inserted), the index '-' is always invalid. See example below. Throws out_of_range.403 if the JSON pointer describes a key of an object which cannot be found. See example below. Throws out_of_range.404 if the JSON pointer ptr can not be resolved. See example below.","title":"Exceptions"},{"location":"api/basic_json/at/#exception-safety","text":"Strong exception safety: if an exception occurs, the original value stays intact.","title":"Exception safety"},{"location":"api/basic_json/at/#complexity","text":"Constant Logarithmic in the size of the container. Constant","title":"Complexity"},{"location":"api/basic_json/at/#example","text":"Example The example below shows how array elements can be read and written using at() . It also demonstrates the different exceptions that can be thrown. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON array json array = { \"first\" , \"2nd\" , \"third\" , \"fourth\" }; // output element at index 2 (third element) std :: cout << array . at ( 2 ) << '\\n' ; // change element at index 1 (second element) to \"second\" array . at ( 1 ) = \"second\" ; // output changed array std :: cout << array << '\\n' ; // exception type_error.304 try { // use at() on a non-array type json str = \"I am a string\" ; str . at ( 0 ) = \"Another string\" ; } catch ( json :: type_error & e ) { std :: cout << e . what () << '\\n' ; } // exception out_of_range.401 try { // try to write beyond the array limit array . at ( 5 ) = \"sixth\" ; } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } } Output: \"third\" [ \"first\" , \"second\" , \"third\" , \"fourth\" ] [ json.exception.type_error. 304 ] cannot use at() with string [ json.exception.out_of_range. 401 ] array index 5 is out of range Example The example below shows how array elements can be read using at() . It also demonstrates the different exceptions that can be thrown. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON array const json array = { \"first\" , \"2nd\" , \"third\" , \"fourth\" }; // output element at index 2 (third element) std :: cout << array . at ( 2 ) << '\\n' ; // exception type_error.304 try { // use at() on a non-array type const json str = \"I am a string\" ; std :: cout << str . at ( 0 ) << '\\n' ; } catch ( json :: type_error & e ) { std :: cout << e . what () << '\\n' ; } // exception out_of_range.401 try { // try to read beyond the array limit std :: cout << array . at ( 5 ) << '\\n' ; } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } } Output: \"third\" [ json.exception.type_error. 304 ] cannot use at() with string [ json.exception.out_of_range. 401 ] array index 5 is out of range Example The example below shows how object elements can be read and written using at() . It also demonstrates the different exceptions that can be thrown. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON object json object = { { \"the good\" , \"il buono\" }, { \"the bad\" , \"il cattivo\" }, { \"the ugly\" , \"il brutto\" } }; // output element with key \"the ugly\" std :: cout << object . at ( \"the ugly\" ) << '\\n' ; // change element with key \"the bad\" object . at ( \"the bad\" ) = \"il cattivo\" ; // output changed array std :: cout << object << '\\n' ; // exception type_error.304 try { // use at() on a non-object type json str = \"I am a string\" ; str . at ( \"the good\" ) = \"Another string\" ; } catch ( json :: type_error & e ) { std :: cout << e . what () << '\\n' ; } // exception out_of_range.401 try { // try to write at a nonexisting key object . at ( \"the fast\" ) = \"il rapido\" ; } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } } Output: \"il brutto\" { \"the bad\" : \"il cattivo\" , \"the good\" : \"il buono\" , \"the ugly\" : \"il brutto\" } [ json.exception.type_error. 304 ] cannot use at() with string [ json.exception.out_of_range. 403 ] key 'the fast' not found Example The example below shows how object elements can be read using at() . It also demonstrates the different exceptions that can be thrown. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON object const json object = { { \"the good\" , \"il buono\" }, { \"the bad\" , \"il cattivo\" }, { \"the ugly\" , \"il brutto\" } }; // output element with key \"the ugly\" std :: cout << object . at ( \"the ugly\" ) << '\\n' ; // exception type_error.304 try { // use at() on a non-object type const json str = \"I am a string\" ; std :: cout << str . at ( \"the good\" ) << '\\n' ; } catch ( json :: type_error & e ) { std :: cout << e . what () << '\\n' ; } // exception out_of_range.401 try { // try to read from a nonexisting key std :: cout << object . at ( \"the fast\" ) << '\\n' ; } catch ( json :: out_of_range ) { std :: cout << \"out of range\" << '\\n' ; } } Output: \"il brutto\" [ json.exception.type_error. 304 ] cannot use at() with string out of range Example The example below shows how object elements can be read and written using at() . It also demonstrates the different exceptions that can be thrown. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = { { \"number\" , 1 }, { \"string\" , \"foo\" }, { \"array\" , { 1 , 2 }} }; // read-only access // output element with JSON pointer \"/number\" std :: cout << j . at ( \"/number\" _json_pointer ) << '\\n' ; // output element with JSON pointer \"/string\" std :: cout << j . at ( \"/string\" _json_pointer ) << '\\n' ; // output element with JSON pointer \"/array\" std :: cout << j . at ( \"/array\" _json_pointer ) << '\\n' ; // output element with JSON pointer \"/array/1\" std :: cout << j . at ( \"/array/1\" _json_pointer ) << '\\n' ; // writing access // change the string j . at ( \"/string\" _json_pointer ) = \"bar\" ; // output the changed string std :: cout << j [ \"string\" ] << '\\n' ; // change an array element j . at ( \"/array/1\" _json_pointer ) = 21 ; // output the changed array std :: cout << j [ \"array\" ] << '\\n' ; // out_of_range.106 try { // try to use an array index with leading '0' json :: reference ref = j . at ( \"/array/01\" _json_pointer ); } catch ( json :: parse_error & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.109 try { // try to use an array index that is not a number json :: reference ref = j . at ( \"/array/one\" _json_pointer ); } catch ( json :: parse_error & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.401 try { // try to use a an invalid array index json :: reference ref = j . at ( \"/array/4\" _json_pointer ); } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.402 try { // try to use the array index '-' json :: reference ref = j . at ( \"/array/-\" _json_pointer ); } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.403 try { // try to use a JSON pointer to an nonexistent object key json :: const_reference ref = j . at ( \"/foo\" _json_pointer ); } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.404 try { // try to use a JSON pointer that cannot be resolved json :: reference ref = j . at ( \"/number/foo\" _json_pointer ); } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } } Output: 1 \"foo\" [ 1 , 2 ] 2 \"bar\" [ 1 , 21 ] [ json.exception.parse_error. 106 ] parse error: array index ' 01 ' must not begin with ' 0 ' [ json.exception.parse_error. 109 ] parse error: array index 'one' is not a number [ json.exception.out_of_range. 401 ] array index 4 is out of range [ json.exception.out_of_range. 402 ] array index '-' ( 2 ) is out of range [ json.exception.out_of_range. 403 ] key 'foo' not found [ json.exception.out_of_range. 404 ] unresolved reference token 'foo' Example The example below shows how object elements can be read using at() . It also demonstrates the different exceptions that can be thrown. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value const json j = { { \"number\" , 1 }, { \"string\" , \"foo\" }, { \"array\" , { 1 , 2 }} }; // read-only access // output element with JSON pointer \"/number\" std :: cout << j . at ( \"/number\" _json_pointer ) << '\\n' ; // output element with JSON pointer \"/string\" std :: cout << j . at ( \"/string\" _json_pointer ) << '\\n' ; // output element with JSON pointer \"/array\" std :: cout << j . at ( \"/array\" _json_pointer ) << '\\n' ; // output element with JSON pointer \"/array/1\" std :: cout << j . at ( \"/array/1\" _json_pointer ) << '\\n' ; // out_of_range.109 try { // try to use an array index that is not a number json :: const_reference ref = j . at ( \"/array/one\" _json_pointer ); } catch ( json :: parse_error & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.401 try { // try to use a an invalid array index json :: const_reference ref = j . at ( \"/array/4\" _json_pointer ); } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.402 try { // try to use the array index '-' json :: const_reference ref = j . at ( \"/array/-\" _json_pointer ); } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.403 try { // try to use a JSON pointer to an nonexistent object key json :: const_reference ref = j . at ( \"/foo\" _json_pointer ); } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } // out_of_range.404 try { // try to use a JSON pointer that cannot be resolved json :: const_reference ref = j . at ( \"/number/foo\" _json_pointer ); } catch ( json :: out_of_range & e ) { std :: cout << e . what () << '\\n' ; } } Output: 1 \"foo\" [ 1 , 2 ] 2 [ json.exception.parse_error. 109 ] parse error: array index 'one' is not a number [ json.exception.out_of_range. 401 ] array index 4 is out of range [ json.exception.out_of_range. 402 ] array index '-' ( 2 ) is out of range [ json.exception.out_of_range. 403 ] key 'foo' not found [ json.exception.out_of_range. 404 ] unresolved reference token 'foo'","title":"Example"},{"location":"api/basic_json/at/#version-history","text":"Added in version 1.0.0. Added in version 1.0.0. Added in version 2.0.0.","title":"Version history"},{"location":"api/basic_json/back/","text":"basic_json::back \u00b6 reference back (); const_reference back () const ; Returns a reference to the last element in the container. For a JSON container c , the expression c.back() is equivalent to auto tmp = c . end (); -- tmp ; return * tmp ; Return value \u00b6 In case of a structured type (array or object), a reference to the last element is returned. In case of number, string, boolean, or binary values, a reference to the value is returned. Exceptions \u00b6 If the JSON value is null , exception invalid_iterator.214 is thrown. Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Constant. Note \u00b6 Danger Calling back on an empty array or object is undefined behavior and is guarded by an assertion ! Example \u00b6 Example The following code shows an example for back() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_object_empty ( json :: value_t :: object ); json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_array_empty ( json :: value_t :: array ); json j_string = \"Hello, world\" ; // call back() std :: cout << j_boolean . back () << '\\n' ; std :: cout << j_number_integer . back () << '\\n' ; std :: cout << j_number_float . back () << '\\n' ; std :: cout << j_object . back () << '\\n' ; //std::cout << j_object_empty.back() << '\\n'; // undefined behavior std :: cout << j_array . back () << '\\n' ; //std::cout << j_array_empty.back() << '\\n'; // undefined behavior std :: cout << j_string . back () << '\\n' ; // back() called on a null value try { json j_null ; j_null . back (); } catch ( json :: invalid_iterator & e ) { std :: cout << e . what () << '\\n' ; } } Output: true 17 23.42 2 16 \"Hello, world\" [ json.exception.invalid_iterator. 214 ] cannot get value Version history \u00b6 Added in version 1.0.0. Adjusted code to return reference to binary values in version 3.8.0.","title":"basic_json::back"},{"location":"api/basic_json/back/#basic_jsonback","text":"reference back (); const_reference back () const ; Returns a reference to the last element in the container. For a JSON container c , the expression c.back() is equivalent to auto tmp = c . end (); -- tmp ; return * tmp ;","title":"basic_json::back"},{"location":"api/basic_json/back/#return-value","text":"In case of a structured type (array or object), a reference to the last element is returned. In case of number, string, boolean, or binary values, a reference to the value is returned.","title":"Return value"},{"location":"api/basic_json/back/#exceptions","text":"If the JSON value is null , exception invalid_iterator.214 is thrown.","title":"Exceptions"},{"location":"api/basic_json/back/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/back/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/back/#note","text":"Danger Calling back on an empty array or object is undefined behavior and is guarded by an assertion !","title":"Note"},{"location":"api/basic_json/back/#example","text":"Example The following code shows an example for back() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_object_empty ( json :: value_t :: object ); json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_array_empty ( json :: value_t :: array ); json j_string = \"Hello, world\" ; // call back() std :: cout << j_boolean . back () << '\\n' ; std :: cout << j_number_integer . back () << '\\n' ; std :: cout << j_number_float . back () << '\\n' ; std :: cout << j_object . back () << '\\n' ; //std::cout << j_object_empty.back() << '\\n'; // undefined behavior std :: cout << j_array . back () << '\\n' ; //std::cout << j_array_empty.back() << '\\n'; // undefined behavior std :: cout << j_string . back () << '\\n' ; // back() called on a null value try { json j_null ; j_null . back (); } catch ( json :: invalid_iterator & e ) { std :: cout << e . what () << '\\n' ; } } Output: true 17 23.42 2 16 \"Hello, world\" [ json.exception.invalid_iterator. 214 ] cannot get value","title":"Example"},{"location":"api/basic_json/back/#version-history","text":"Added in version 1.0.0. Adjusted code to return reference to binary values in version 3.8.0.","title":"Version history"},{"location":"api/basic_json/basic_json/","text":"basic_json::basic_json \u00b6 // 1 basic_json ( const value_t v ); // 2 basic_json ( std :: nullptr_t = nullptr ) noexcept ; // 3 template < typename CompatibleType > basic_json ( CompatibleType && val ) noexcept ( noexcept ( JSONSerializer < U >:: to_json ( std :: declval < basic_json_t &> (), std :: forward < CompatibleType > ( val )))); // 4 template < typename BasicJsonType > basic_json ( const BasicJsonType & val ); // 5 basic_json ( initializer_list_t init , bool type_deduction = true , value_t manual_type = value_t :: array ); // 6 basic_json ( size_type cnt , const basic_json & val ); // 7 basic_json ( iterator first , iterator last ); basic_json ( const_iterator first , const_iterator last ); // 8 basic_json ( const basic_json & other ); // 9 basic_json ( basic_json && other ) noexcept ; Create an empty JSON value with a given type. The value will be default initialized with an empty value which depends on the type: Value type initial value null null boolean false string \"\" number 0 object {} array [] binary empty array Create a null JSON value. It either takes a null pointer as parameter (explicitly creating null ) or no parameter (implicitly creating null ). The passed null pointer itself is not read -- it is only used to choose the right constructor. This is a \"catch all\" constructor for all compatible JSON types; that is, types for which a to_json() method exists. The constructor forwards the parameter val to that method (to json_serializer<U>::to_json method with U = uncvref_t<CompatibleType> , to be exact). Template type CompatibleType includes, but is not limited to, the following types: arrays : array_t and all kinds of compatible containers such as std::vector , std::deque , std::list , std::forward_list , std::array , std::valarray , std::set , std::unordered_set , std::multiset , and std::unordered_multiset with a value_type from which a basic_json value can be constructed. objects : object_t and all kinds of compatible associative containers such as std::map , std::unordered_map , std::multimap , and std::unordered_multimap with a key_type compatible to string_t and a value_type from which a basic_json value can be constructed. strings : string_t , string literals, and all compatible string containers can be used. numbers : number_integer_t , number_unsigned_t , number_float_t , and all convertible number types such as int , size_t , int64_t , float or double can be used. boolean : boolean_t / bool can be used. binary : binary_t / std::vector<uint8_t> may be used; unfortunately because string literals cannot be distinguished from binary character arrays by the C++ type system, all types compatible with const char* will be directed to the string constructor instead. This is both for backwards compatibility, and due to the fact that a binary type is not a standard JSON type. See the examples below. This is a constructor for existing basic_json types. It does not hijack copy/move constructors, since the parameter has different template arguments than the current ones. The constructor tries to convert the internal m_value of the parameter. Creates a JSON value of type array or object from the passed initializer list init . In case type_deduction is true (default), the type of the JSON value to be created is deducted from the initializer list init according to the following rules: If the list is empty, an empty JSON object value {} is created. If the list consists of pairs whose first element is a string, a JSON object value is created where the first elements of the pairs are treated as keys and the second elements are as values. In all other cases, an array is created. The rules aim to create the best fit between a C++ initializer list and JSON values. The rationale is as follows: The empty initializer list is written as {} which is exactly an empty JSON object. C++ has no way of describing mapped types other than to list a list of pairs. As JSON requires that keys must be of type string, rule 2 is the weakest constraint one can pose on initializer lists to interpret them as an object. In all other cases, the initializer list could not be interpreted as JSON object type, so interpreting it as JSON array type is safe. With the rules described above, the following JSON values cannot be expressed by an initializer list: the empty array ( [] ): use array(initializer_list_t) with an empty initializer list in this case arrays whose elements satisfy rule 2: use array(initializer_list_t) with the same initializer list in this case Constructs a JSON array value by creating cnt copies of a passed value. In case cnt is 0 , an empty array is created. Constructs the JSON value with the contents of the range [first, last) . The semantics depends on the different types a JSON value can have: In case of a null type, invalid_iterator.206 is thrown. In case of other primitive types (number, boolean, or string), first must be begin() and last must be end() . In this case, the value is copied. Otherwise, invalid_iterator.204 is thrown. In case of structured types (array, object), the constructor behaves as similar versions for std::vector or std::map ; that is, a JSON array or object is constructed from the values in the range. Creates a copy of a given JSON value. Move constructor. Constructs a JSON value with the contents of the given value other using move semantics. It \"steals\" the resources from other and leaves it as JSON null value. Template parameters \u00b6 CompatibleType a type such that: CompatibleType is not derived from std::istream , CompatibleType is not basic_json (to avoid hijacking copy/move constructors), CompatibleType is not a different basic_json type (i.e. with different template arguments) CompatibleType is not a basic_json nested type (e.g., json_pointer , iterator , etc.) json_serializer<U> (with U = uncvref_t<CompatibleType> ) has a to_json(basic_json_t&, CompatibleType&&) method BasicJsonType : a type such that: BasicJsonType is a basic_json type. BasicJsonType has different template arguments than basic_json_t . Parameters \u00b6 v (in) the type of the value to create val (in) the value to be forwarded to the respective constructor init (in) initializer list with JSON values type_deduction (in) internal parameter; when set to true , the type of the JSON value is deducted from the initializer list init ; when set to false , the type provided via manual_type is forced. This mode is used by the functions array(initializer_list_t) and object(initializer_list_t) . manual_type (in) internal parameter; when type_deduction is set to false , the created JSON value will use the provided type (only value_t::array and value_t::object are valid); when type_deduction is set to true , this parameter has no effect cnt (in) the number of JSON copies of val to create first (in) begin of the range to copy from (included) last (in) end of the range to copy from (excluded) other (in) the JSON value to copy/move Exceptions \u00b6 / The function does not throw exceptions. / / The function can throw the following exceptions: Throws type_error.301 if type_deduction is false , manual_type is value_t::object , but init contains an element which is not a pair whose first element is a string. In this case, the constructor could not create an object. If type_deduction would have been true , an array would have been created. See object(initializer_list_t) for an example. / The function can throw the following exceptions: Throws invalid_iterator.201 if iterators first and last are not compatible (i.e., do not belong to the same JSON value). In this case, the range [first, last) is undefined. Throws invalid_iterator.204 if iterators first and last belong to a primitive type (number, boolean, or string), but first does not point to the first element any more. In this case, the range [first, last) is undefined. See example code below. Throws invalid_iterator.206 if iterators first and last belong to a null value. In this case, the range [first, last) is undefined. / The function does not throw exceptions. Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes to any JSON value. No-throw guarantee: this constructor never throws exceptions. Depends on the called constructor. For types directly supported by the library (i.e., all types for which no to_json() function was provided), strong guarantee holds: if an exception is thrown, there are no changes to any JSON value. Depends on the called constructor. For types directly supported by the library (i.e., all types for which no to_json() function was provided), strong guarantee holds: if an exception is thrown, there are no changes to any JSON value. Strong guarantee: if an exception is thrown, there are no changes to any JSON value. Strong guarantee: if an exception is thrown, there are no changes to any JSON value. Strong guarantee: if an exception is thrown, there are no changes to any JSON value. Strong guarantee: if an exception is thrown, there are no changes to any JSON value. No-throw guarantee: this constructor never throws exceptions. Complexity \u00b6 Constant. Constant. Usually linear in the size of the passed val , also depending on the implementation of the called to_json() method. Usually linear in the size of the passed val , also depending on the implementation of the called to_json() method. Linear in the size of the initializer list init . Linear in cnt . Linear in distance between first and last . Linear in the size of other . Constant. Notes \u00b6 Overload 5: Note When used without parentheses around an empty initializer list, basic_json() is called instead of this function, yielding the JSON null value. Overload 7: Preconditions Iterators first and last must be initialized. This precondition is enforced with an assertion (see warning). If assertions are switched off, a violation of this precondition yields undefined behavior. Range [first, last) is valid. Usually, this precondition cannot be checked efficiently. Only certain edge cases are detected; see the description of the exceptions above. A violation of this precondition yields undefined behavior. Warning A precondition is enforced with a runtime assertion that will result in calling std::abort if this precondition is not met. Assertions can be disabled by defining NDEBUG at compile time. See https://en.cppreference.com/w/cpp/error/assert for more information. Overload 8: Postcondition * this == other Overload 9: Postconditions ` * this has the same value as other before the call. other is a JSON null value Example \u00b6 Example The following code shows the constructor for different value_t values. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create the different JSON values with default values json j_null ( json :: value_t :: null ); json j_boolean ( json :: value_t :: boolean ); json j_number_integer ( json :: value_t :: number_integer ); json j_number_float ( json :: value_t :: number_float ); json j_object ( json :: value_t :: object ); json j_array ( json :: value_t :: array ); json j_string ( json :: value_t :: string ); // serialize the JSON values std :: cout << j_null << '\\n' ; std :: cout << j_boolean << '\\n' ; std :: cout << j_number_integer << '\\n' ; std :: cout << j_number_float << '\\n' ; std :: cout << j_object << '\\n' ; std :: cout << j_array << '\\n' ; std :: cout << j_string << '\\n' ; } Output: null false 0 0.0 {} [] \"\" Example The following code shows the constructor with and without a null pointer parameter. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // implicitly create a JSON null value json j1 ; // explicitly create a JSON null value json j2 ( nullptr ); // serialize the JSON null value std :: cout << j1 << '\\n' << j2 << '\\n' ; } Output: null null Example The following code shows the constructor with several compatible types. #include <iostream> #include <deque> #include <list> #include <forward_list> #include <set> #include <unordered_map> #include <unordered_set> #include <valarray> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // ============ // object types // ============ // create an object from an object_t value json :: object_t object_value = { { \"one\" , 1 }, { \"two\" , 2 } }; json j_object_t ( object_value ); // create an object from std::map std :: map < std :: string , int > c_map { { \"one\" , 1 }, { \"two\" , 2 }, { \"three\" , 3 } }; json j_map ( c_map ); // create an object from std::unordered_map std :: unordered_map < const char * , double > c_umap { { \"one\" , 1.2 }, { \"two\" , 2.3 }, { \"three\" , 3.4 } }; json j_umap ( c_umap ); // create an object from std::multimap std :: multimap < std :: string , bool > c_mmap { { \"one\" , true }, { \"two\" , true }, { \"three\" , false }, { \"three\" , true } }; json j_mmap ( c_mmap ); // only one entry for key \"three\" is used // create an object from std::unordered_multimap std :: unordered_multimap < std :: string , bool > c_ummap { { \"one\" , true }, { \"two\" , true }, { \"three\" , false }, { \"three\" , true } }; json j_ummap ( c_ummap ); // only one entry for key \"three\" is used // serialize the JSON objects std :: cout << j_object_t << '\\n' ; std :: cout << j_map << '\\n' ; std :: cout << j_umap << '\\n' ; std :: cout << j_mmap << '\\n' ; std :: cout << j_ummap << \" \\n\\n \" ; // =========== // array types // =========== // create an array from an array_t value json :: array_t array_value = { \"one\" , \"two\" , 3 , 4.5 , false }; json j_array_t ( array_value ); // create an array from std::vector std :: vector < int > c_vector { 1 , 2 , 3 , 4 }; json j_vec ( c_vector ); // create an array from std::valarray std :: valarray < short > c_valarray { 10 , 9 , 8 , 7 }; json j_valarray ( c_valarray ); // create an array from std::deque std :: deque < double > c_deque { 1.2 , 2.3 , 3.4 , 5.6 }; json j_deque ( c_deque ); // create an array from std::list std :: list < bool > c_list { true , true , false , true }; json j_list ( c_list ); // create an array from std::forward_list std :: forward_list < int64_t > c_flist { 12345678909876 , 23456789098765 , 34567890987654 , 45678909876543 }; json j_flist ( c_flist ); // create an array from std::array std :: array < unsigned long , 4 > c_array {{ 1 , 2 , 3 , 4 }}; json j_array ( c_array ); // create an array from std::set std :: set < std :: string > c_set { \"one\" , \"two\" , \"three\" , \"four\" , \"one\" }; json j_set ( c_set ); // only one entry for \"one\" is used // create an array from std::unordered_set std :: unordered_set < std :: string > c_uset { \"one\" , \"two\" , \"three\" , \"four\" , \"one\" }; json j_uset ( c_uset ); // only one entry for \"one\" is used // create an array from std::multiset std :: multiset < std :: string > c_mset { \"one\" , \"two\" , \"one\" , \"four\" }; json j_mset ( c_mset ); // both entries for \"one\" are used // create an array from std::unordered_multiset std :: unordered_multiset < std :: string > c_umset { \"one\" , \"two\" , \"one\" , \"four\" }; json j_umset ( c_umset ); // both entries for \"one\" are used // serialize the JSON arrays std :: cout << j_array_t << '\\n' ; std :: cout << j_vec << '\\n' ; std :: cout << j_valarray << '\\n' ; std :: cout << j_deque << '\\n' ; std :: cout << j_list << '\\n' ; std :: cout << j_flist << '\\n' ; std :: cout << j_array << '\\n' ; std :: cout << j_set << '\\n' ; std :: cout << j_uset << '\\n' ; std :: cout << j_mset << '\\n' ; std :: cout << j_umset << \" \\n\\n \" ; // ============ // string types // ============ // create string from a string_t value json :: string_t string_value = \"The quick brown fox jumps over the lazy dog.\" ; json j_string_t ( string_value ); // create a JSON string directly from a string literal json j_string_literal ( \"The quick brown fox jumps over the lazy dog.\" ); // create string from std::string std :: string s_stdstring = \"The quick brown fox jumps over the lazy dog.\" ; json j_stdstring ( s_stdstring ); // serialize the JSON strings std :: cout << j_string_t << '\\n' ; std :: cout << j_string_literal << '\\n' ; std :: cout << j_stdstring << \" \\n\\n \" ; // ============ // number types // ============ // create a JSON number from number_integer_t json :: number_integer_t value_integer_t = - 42 ; json j_integer_t ( value_integer_t ); // create a JSON number from number_unsigned_t json :: number_integer_t value_unsigned_t = 17 ; json j_unsigned_t ( value_unsigned_t ); // create a JSON number from an anonymous enum enum { enum_value = 17 }; json j_enum ( enum_value ); // create values of different integer types short n_short = 42 ; int n_int = - 23 ; long n_long = 1024 ; int_least32_t n_int_least32_t = - 17 ; uint8_t n_uint8_t = 8 ; // create (integer) JSON numbers json j_short ( n_short ); json j_int ( n_int ); json j_long ( n_long ); json j_int_least32_t ( n_int_least32_t ); json j_uint8_t ( n_uint8_t ); // create values of different floating-point types json :: number_float_t v_ok = 3.141592653589793 ; json :: number_float_t v_nan = NAN ; json :: number_float_t v_infinity = INFINITY ; // create values of different floating-point types float n_float = 42.23 ; float n_float_nan = 1.0f / 0.0f ; double n_double = 23.42 ; // create (floating point) JSON numbers json j_ok ( v_ok ); json j_nan ( v_nan ); json j_infinity ( v_infinity ); json j_float ( n_float ); json j_float_nan ( n_float_nan ); json j_double ( n_double ); // serialize the JSON numbers std :: cout << j_integer_t << '\\n' ; std :: cout << j_unsigned_t << '\\n' ; std :: cout << j_enum << '\\n' ; std :: cout << j_short << '\\n' ; std :: cout << j_int << '\\n' ; std :: cout << j_long << '\\n' ; std :: cout << j_int_least32_t << '\\n' ; std :: cout << j_uint8_t << '\\n' ; std :: cout << j_ok << '\\n' ; std :: cout << j_nan << '\\n' ; std :: cout << j_infinity << '\\n' ; std :: cout << j_float << '\\n' ; std :: cout << j_float_nan << '\\n' ; std :: cout << j_double << \" \\n\\n \" ; // ============= // boolean types // ============= // create boolean values json j_truth = true ; json j_falsity = false ; // serialize the JSON booleans std :: cout << j_truth << '\\n' ; std :: cout << j_falsity << '\\n' ; } Output: { \"one\" : 1 , \"two\" : 2 } { \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } { \"one\" : 1.2 , \"three\" : 3.4 , \"two\" : 2.3 } { \"one\" : true , \"three\" : false , \"two\" : true } { \"one\" : true , \"three\" : false , \"two\" : true } [ \"one\" , \"two\" , 3 , 4.5 , false ] [ 1 , 2 , 3 , 4 ] [ 10 , 9 , 8 , 7 ] [ 1.2 , 2.3 , 3.4 , 5.6 ] [ true , true , false , true ] [ 12345678909876 , 23456789098765 , 34567890987654 , 45678909876543 ] [ 1 , 2 , 3 , 4 ] [ \"four\" , \"one\" , \"three\" , \"two\" ] [ \"four\" , \"three\" , \"two\" , \"one\" ] [ \"four\" , \"one\" , \"one\" , \"two\" ] [ \"four\" , \"two\" , \"one\" , \"one\" ] \"The quick brown fox jumps over the lazy dog.\" \"The quick brown fox jumps over the lazy dog.\" \"The quick brown fox jumps over the lazy dog.\" -42 17 17 42 -23 1024 -17 8 3.141592653589793 null null 42.22999954223633 null 23.42 true false Example The example below shows how JSON values are created from initializer lists. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_empty_init_list = json ({}); json j_object = { { \"one\" , 1 }, { \"two\" , 2 } }; json j_array = { 1 , 2 , 3 , 4 }; json j_nested_object = { { \"one\" , { 1 }}, { \"two\" , { 1 , 2 }} }; json j_nested_array = { {{ 1 }, \"one\" }, {{ 1 , 2 }, \"two\" } }; // serialize the JSON value std :: cout << j_empty_init_list << '\\n' ; std :: cout << j_object << '\\n' ; std :: cout << j_array << '\\n' ; std :: cout << j_nested_object << '\\n' ; std :: cout << j_nested_array << '\\n' ; } Output: {} { \"one\" : 1 , \"two\" : 2 } [ 1 , 2 , 3 , 4 ] { \"one\" :[ 1 ], \"two\" :[ 1 , 2 ]} [[[ 1 ], \"one\" ],[[ 1 , 2 ], \"two\" ]] Example The following code shows examples for creating arrays with several copies of a given value. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array by creating copies of a JSON value json value = \"Hello\" ; json array_0 = json ( 0 , value ); json array_1 = json ( 1 , value ); json array_5 = json ( 5 , value ); // serialize the JSON arrays std :: cout << array_0 << '\\n' ; std :: cout << array_1 << '\\n' ; std :: cout << array_5 << '\\n' ; } Output: [] [ \"Hello\" ] [ \"Hello\" , \"Hello\" , \"Hello\" , \"Hello\" , \"Hello\" ] Example The example below shows several ways to create JSON values by specifying a subrange with iterators. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_array = { \"alpha\" , \"bravo\" , \"charly\" , \"delta\" , \"easy\" }; json j_number = 42 ; json j_object = {{ \"one\" , \"eins\" }, { \"two\" , \"zwei\" }}; // create copies using iterators json j_array_range ( j_array . begin () + 1 , j_array . end () - 2 ); json j_number_range ( j_number . begin (), j_number . end ()); json j_object_range ( j_object . begin (), j_object . find ( \"two\" )); // serialize the values std :: cout << j_array_range << '\\n' ; std :: cout << j_number_range << '\\n' ; std :: cout << j_object_range << '\\n' ; // example for an exception try { json j_invalid ( j_number . begin () + 1 , j_number . end ()); } catch ( json :: invalid_iterator & e ) { std :: cout << e . what () << '\\n' ; } } Output: [ \"bravo\" , \"charly\" ] 42 { \"one\" : \"eins\" } [ json.exception.invalid_iterator. 204 ] iterators out of range Example The following code shows an example for the copy constructor. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON array json j1 = { \"one\" , \"two\" , 3 , 4.5 , false }; // create a copy json j2 ( j1 ); // serialize the JSON array std :: cout << j1 << \" = \" << j2 << '\\n' ; std :: cout << std :: boolalpha << ( j1 == j2 ) << '\\n' ; } Output: [ \"one\" , \"two\" , 3 , 4.5 , false ] = [ \"one\" , \"two\" , 3 , 4.5 , false ] true Example The code below shows the move constructor explicitly called via std::move . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json a = 23 ; // move contents of a to b json b ( std :: move ( a )); // serialize the JSON arrays std :: cout << a << '\\n' ; std :: cout << b << '\\n' ; } Output: null 23 Version history \u00b6 Since version 1.0.0. Since version 1.0.0. Since version 2.1.0. Since version 3.2.0. Since version 1.0.0. Since version 1.0.0. Since version 1.0.0. Since version 1.0.0. Since version 1.0.0.","title":"basic_json::basic_json"},{"location":"api/basic_json/basic_json/#basic_jsonbasic_json","text":"// 1 basic_json ( const value_t v ); // 2 basic_json ( std :: nullptr_t = nullptr ) noexcept ; // 3 template < typename CompatibleType > basic_json ( CompatibleType && val ) noexcept ( noexcept ( JSONSerializer < U >:: to_json ( std :: declval < basic_json_t &> (), std :: forward < CompatibleType > ( val )))); // 4 template < typename BasicJsonType > basic_json ( const BasicJsonType & val ); // 5 basic_json ( initializer_list_t init , bool type_deduction = true , value_t manual_type = value_t :: array ); // 6 basic_json ( size_type cnt , const basic_json & val ); // 7 basic_json ( iterator first , iterator last ); basic_json ( const_iterator first , const_iterator last ); // 8 basic_json ( const basic_json & other ); // 9 basic_json ( basic_json && other ) noexcept ; Create an empty JSON value with a given type. The value will be default initialized with an empty value which depends on the type: Value type initial value null null boolean false string \"\" number 0 object {} array [] binary empty array Create a null JSON value. It either takes a null pointer as parameter (explicitly creating null ) or no parameter (implicitly creating null ). The passed null pointer itself is not read -- it is only used to choose the right constructor. This is a \"catch all\" constructor for all compatible JSON types; that is, types for which a to_json() method exists. The constructor forwards the parameter val to that method (to json_serializer<U>::to_json method with U = uncvref_t<CompatibleType> , to be exact). Template type CompatibleType includes, but is not limited to, the following types: arrays : array_t and all kinds of compatible containers such as std::vector , std::deque , std::list , std::forward_list , std::array , std::valarray , std::set , std::unordered_set , std::multiset , and std::unordered_multiset with a value_type from which a basic_json value can be constructed. objects : object_t and all kinds of compatible associative containers such as std::map , std::unordered_map , std::multimap , and std::unordered_multimap with a key_type compatible to string_t and a value_type from which a basic_json value can be constructed. strings : string_t , string literals, and all compatible string containers can be used. numbers : number_integer_t , number_unsigned_t , number_float_t , and all convertible number types such as int , size_t , int64_t , float or double can be used. boolean : boolean_t / bool can be used. binary : binary_t / std::vector<uint8_t> may be used; unfortunately because string literals cannot be distinguished from binary character arrays by the C++ type system, all types compatible with const char* will be directed to the string constructor instead. This is both for backwards compatibility, and due to the fact that a binary type is not a standard JSON type. See the examples below. This is a constructor for existing basic_json types. It does not hijack copy/move constructors, since the parameter has different template arguments than the current ones. The constructor tries to convert the internal m_value of the parameter. Creates a JSON value of type array or object from the passed initializer list init . In case type_deduction is true (default), the type of the JSON value to be created is deducted from the initializer list init according to the following rules: If the list is empty, an empty JSON object value {} is created. If the list consists of pairs whose first element is a string, a JSON object value is created where the first elements of the pairs are treated as keys and the second elements are as values. In all other cases, an array is created. The rules aim to create the best fit between a C++ initializer list and JSON values. The rationale is as follows: The empty initializer list is written as {} which is exactly an empty JSON object. C++ has no way of describing mapped types other than to list a list of pairs. As JSON requires that keys must be of type string, rule 2 is the weakest constraint one can pose on initializer lists to interpret them as an object. In all other cases, the initializer list could not be interpreted as JSON object type, so interpreting it as JSON array type is safe. With the rules described above, the following JSON values cannot be expressed by an initializer list: the empty array ( [] ): use array(initializer_list_t) with an empty initializer list in this case arrays whose elements satisfy rule 2: use array(initializer_list_t) with the same initializer list in this case Constructs a JSON array value by creating cnt copies of a passed value. In case cnt is 0 , an empty array is created. Constructs the JSON value with the contents of the range [first, last) . The semantics depends on the different types a JSON value can have: In case of a null type, invalid_iterator.206 is thrown. In case of other primitive types (number, boolean, or string), first must be begin() and last must be end() . In this case, the value is copied. Otherwise, invalid_iterator.204 is thrown. In case of structured types (array, object), the constructor behaves as similar versions for std::vector or std::map ; that is, a JSON array or object is constructed from the values in the range. Creates a copy of a given JSON value. Move constructor. Constructs a JSON value with the contents of the given value other using move semantics. It \"steals\" the resources from other and leaves it as JSON null value.","title":"basic_json::basic_json"},{"location":"api/basic_json/basic_json/#template-parameters","text":"CompatibleType a type such that: CompatibleType is not derived from std::istream , CompatibleType is not basic_json (to avoid hijacking copy/move constructors), CompatibleType is not a different basic_json type (i.e. with different template arguments) CompatibleType is not a basic_json nested type (e.g., json_pointer , iterator , etc.) json_serializer<U> (with U = uncvref_t<CompatibleType> ) has a to_json(basic_json_t&, CompatibleType&&) method BasicJsonType : a type such that: BasicJsonType is a basic_json type. BasicJsonType has different template arguments than basic_json_t .","title":"Template parameters"},{"location":"api/basic_json/basic_json/#parameters","text":"v (in) the type of the value to create val (in) the value to be forwarded to the respective constructor init (in) initializer list with JSON values type_deduction (in) internal parameter; when set to true , the type of the JSON value is deducted from the initializer list init ; when set to false , the type provided via manual_type is forced. This mode is used by the functions array(initializer_list_t) and object(initializer_list_t) . manual_type (in) internal parameter; when type_deduction is set to false , the created JSON value will use the provided type (only value_t::array and value_t::object are valid); when type_deduction is set to true , this parameter has no effect cnt (in) the number of JSON copies of val to create first (in) begin of the range to copy from (included) last (in) end of the range to copy from (excluded) other (in) the JSON value to copy/move","title":"Parameters"},{"location":"api/basic_json/basic_json/#exceptions","text":"/ The function does not throw exceptions. / / The function can throw the following exceptions: Throws type_error.301 if type_deduction is false , manual_type is value_t::object , but init contains an element which is not a pair whose first element is a string. In this case, the constructor could not create an object. If type_deduction would have been true , an array would have been created. See object(initializer_list_t) for an example. / The function can throw the following exceptions: Throws invalid_iterator.201 if iterators first and last are not compatible (i.e., do not belong to the same JSON value). In this case, the range [first, last) is undefined. Throws invalid_iterator.204 if iterators first and last belong to a primitive type (number, boolean, or string), but first does not point to the first element any more. In this case, the range [first, last) is undefined. See example code below. Throws invalid_iterator.206 if iterators first and last belong to a null value. In this case, the range [first, last) is undefined. / The function does not throw exceptions.","title":"Exceptions"},{"location":"api/basic_json/basic_json/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes to any JSON value. No-throw guarantee: this constructor never throws exceptions. Depends on the called constructor. For types directly supported by the library (i.e., all types for which no to_json() function was provided), strong guarantee holds: if an exception is thrown, there are no changes to any JSON value. Depends on the called constructor. For types directly supported by the library (i.e., all types for which no to_json() function was provided), strong guarantee holds: if an exception is thrown, there are no changes to any JSON value. Strong guarantee: if an exception is thrown, there are no changes to any JSON value. Strong guarantee: if an exception is thrown, there are no changes to any JSON value. Strong guarantee: if an exception is thrown, there are no changes to any JSON value. Strong guarantee: if an exception is thrown, there are no changes to any JSON value. No-throw guarantee: this constructor never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/basic_json/#complexity","text":"Constant. Constant. Usually linear in the size of the passed val , also depending on the implementation of the called to_json() method. Usually linear in the size of the passed val , also depending on the implementation of the called to_json() method. Linear in the size of the initializer list init . Linear in cnt . Linear in distance between first and last . Linear in the size of other . Constant.","title":"Complexity"},{"location":"api/basic_json/basic_json/#notes","text":"Overload 5: Note When used without parentheses around an empty initializer list, basic_json() is called instead of this function, yielding the JSON null value. Overload 7: Preconditions Iterators first and last must be initialized. This precondition is enforced with an assertion (see warning). If assertions are switched off, a violation of this precondition yields undefined behavior. Range [first, last) is valid. Usually, this precondition cannot be checked efficiently. Only certain edge cases are detected; see the description of the exceptions above. A violation of this precondition yields undefined behavior. Warning A precondition is enforced with a runtime assertion that will result in calling std::abort if this precondition is not met. Assertions can be disabled by defining NDEBUG at compile time. See https://en.cppreference.com/w/cpp/error/assert for more information. Overload 8: Postcondition * this == other Overload 9: Postconditions ` * this has the same value as other before the call. other is a JSON null value","title":"Notes"},{"location":"api/basic_json/basic_json/#example","text":"Example The following code shows the constructor for different value_t values. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create the different JSON values with default values json j_null ( json :: value_t :: null ); json j_boolean ( json :: value_t :: boolean ); json j_number_integer ( json :: value_t :: number_integer ); json j_number_float ( json :: value_t :: number_float ); json j_object ( json :: value_t :: object ); json j_array ( json :: value_t :: array ); json j_string ( json :: value_t :: string ); // serialize the JSON values std :: cout << j_null << '\\n' ; std :: cout << j_boolean << '\\n' ; std :: cout << j_number_integer << '\\n' ; std :: cout << j_number_float << '\\n' ; std :: cout << j_object << '\\n' ; std :: cout << j_array << '\\n' ; std :: cout << j_string << '\\n' ; } Output: null false 0 0.0 {} [] \"\" Example The following code shows the constructor with and without a null pointer parameter. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // implicitly create a JSON null value json j1 ; // explicitly create a JSON null value json j2 ( nullptr ); // serialize the JSON null value std :: cout << j1 << '\\n' << j2 << '\\n' ; } Output: null null Example The following code shows the constructor with several compatible types. #include <iostream> #include <deque> #include <list> #include <forward_list> #include <set> #include <unordered_map> #include <unordered_set> #include <valarray> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // ============ // object types // ============ // create an object from an object_t value json :: object_t object_value = { { \"one\" , 1 }, { \"two\" , 2 } }; json j_object_t ( object_value ); // create an object from std::map std :: map < std :: string , int > c_map { { \"one\" , 1 }, { \"two\" , 2 }, { \"three\" , 3 } }; json j_map ( c_map ); // create an object from std::unordered_map std :: unordered_map < const char * , double > c_umap { { \"one\" , 1.2 }, { \"two\" , 2.3 }, { \"three\" , 3.4 } }; json j_umap ( c_umap ); // create an object from std::multimap std :: multimap < std :: string , bool > c_mmap { { \"one\" , true }, { \"two\" , true }, { \"three\" , false }, { \"three\" , true } }; json j_mmap ( c_mmap ); // only one entry for key \"three\" is used // create an object from std::unordered_multimap std :: unordered_multimap < std :: string , bool > c_ummap { { \"one\" , true }, { \"two\" , true }, { \"three\" , false }, { \"three\" , true } }; json j_ummap ( c_ummap ); // only one entry for key \"three\" is used // serialize the JSON objects std :: cout << j_object_t << '\\n' ; std :: cout << j_map << '\\n' ; std :: cout << j_umap << '\\n' ; std :: cout << j_mmap << '\\n' ; std :: cout << j_ummap << \" \\n\\n \" ; // =========== // array types // =========== // create an array from an array_t value json :: array_t array_value = { \"one\" , \"two\" , 3 , 4.5 , false }; json j_array_t ( array_value ); // create an array from std::vector std :: vector < int > c_vector { 1 , 2 , 3 , 4 }; json j_vec ( c_vector ); // create an array from std::valarray std :: valarray < short > c_valarray { 10 , 9 , 8 , 7 }; json j_valarray ( c_valarray ); // create an array from std::deque std :: deque < double > c_deque { 1.2 , 2.3 , 3.4 , 5.6 }; json j_deque ( c_deque ); // create an array from std::list std :: list < bool > c_list { true , true , false , true }; json j_list ( c_list ); // create an array from std::forward_list std :: forward_list < int64_t > c_flist { 12345678909876 , 23456789098765 , 34567890987654 , 45678909876543 }; json j_flist ( c_flist ); // create an array from std::array std :: array < unsigned long , 4 > c_array {{ 1 , 2 , 3 , 4 }}; json j_array ( c_array ); // create an array from std::set std :: set < std :: string > c_set { \"one\" , \"two\" , \"three\" , \"four\" , \"one\" }; json j_set ( c_set ); // only one entry for \"one\" is used // create an array from std::unordered_set std :: unordered_set < std :: string > c_uset { \"one\" , \"two\" , \"three\" , \"four\" , \"one\" }; json j_uset ( c_uset ); // only one entry for \"one\" is used // create an array from std::multiset std :: multiset < std :: string > c_mset { \"one\" , \"two\" , \"one\" , \"four\" }; json j_mset ( c_mset ); // both entries for \"one\" are used // create an array from std::unordered_multiset std :: unordered_multiset < std :: string > c_umset { \"one\" , \"two\" , \"one\" , \"four\" }; json j_umset ( c_umset ); // both entries for \"one\" are used // serialize the JSON arrays std :: cout << j_array_t << '\\n' ; std :: cout << j_vec << '\\n' ; std :: cout << j_valarray << '\\n' ; std :: cout << j_deque << '\\n' ; std :: cout << j_list << '\\n' ; std :: cout << j_flist << '\\n' ; std :: cout << j_array << '\\n' ; std :: cout << j_set << '\\n' ; std :: cout << j_uset << '\\n' ; std :: cout << j_mset << '\\n' ; std :: cout << j_umset << \" \\n\\n \" ; // ============ // string types // ============ // create string from a string_t value json :: string_t string_value = \"The quick brown fox jumps over the lazy dog.\" ; json j_string_t ( string_value ); // create a JSON string directly from a string literal json j_string_literal ( \"The quick brown fox jumps over the lazy dog.\" ); // create string from std::string std :: string s_stdstring = \"The quick brown fox jumps over the lazy dog.\" ; json j_stdstring ( s_stdstring ); // serialize the JSON strings std :: cout << j_string_t << '\\n' ; std :: cout << j_string_literal << '\\n' ; std :: cout << j_stdstring << \" \\n\\n \" ; // ============ // number types // ============ // create a JSON number from number_integer_t json :: number_integer_t value_integer_t = - 42 ; json j_integer_t ( value_integer_t ); // create a JSON number from number_unsigned_t json :: number_integer_t value_unsigned_t = 17 ; json j_unsigned_t ( value_unsigned_t ); // create a JSON number from an anonymous enum enum { enum_value = 17 }; json j_enum ( enum_value ); // create values of different integer types short n_short = 42 ; int n_int = - 23 ; long n_long = 1024 ; int_least32_t n_int_least32_t = - 17 ; uint8_t n_uint8_t = 8 ; // create (integer) JSON numbers json j_short ( n_short ); json j_int ( n_int ); json j_long ( n_long ); json j_int_least32_t ( n_int_least32_t ); json j_uint8_t ( n_uint8_t ); // create values of different floating-point types json :: number_float_t v_ok = 3.141592653589793 ; json :: number_float_t v_nan = NAN ; json :: number_float_t v_infinity = INFINITY ; // create values of different floating-point types float n_float = 42.23 ; float n_float_nan = 1.0f / 0.0f ; double n_double = 23.42 ; // create (floating point) JSON numbers json j_ok ( v_ok ); json j_nan ( v_nan ); json j_infinity ( v_infinity ); json j_float ( n_float ); json j_float_nan ( n_float_nan ); json j_double ( n_double ); // serialize the JSON numbers std :: cout << j_integer_t << '\\n' ; std :: cout << j_unsigned_t << '\\n' ; std :: cout << j_enum << '\\n' ; std :: cout << j_short << '\\n' ; std :: cout << j_int << '\\n' ; std :: cout << j_long << '\\n' ; std :: cout << j_int_least32_t << '\\n' ; std :: cout << j_uint8_t << '\\n' ; std :: cout << j_ok << '\\n' ; std :: cout << j_nan << '\\n' ; std :: cout << j_infinity << '\\n' ; std :: cout << j_float << '\\n' ; std :: cout << j_float_nan << '\\n' ; std :: cout << j_double << \" \\n\\n \" ; // ============= // boolean types // ============= // create boolean values json j_truth = true ; json j_falsity = false ; // serialize the JSON booleans std :: cout << j_truth << '\\n' ; std :: cout << j_falsity << '\\n' ; } Output: { \"one\" : 1 , \"two\" : 2 } { \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } { \"one\" : 1.2 , \"three\" : 3.4 , \"two\" : 2.3 } { \"one\" : true , \"three\" : false , \"two\" : true } { \"one\" : true , \"three\" : false , \"two\" : true } [ \"one\" , \"two\" , 3 , 4.5 , false ] [ 1 , 2 , 3 , 4 ] [ 10 , 9 , 8 , 7 ] [ 1.2 , 2.3 , 3.4 , 5.6 ] [ true , true , false , true ] [ 12345678909876 , 23456789098765 , 34567890987654 , 45678909876543 ] [ 1 , 2 , 3 , 4 ] [ \"four\" , \"one\" , \"three\" , \"two\" ] [ \"four\" , \"three\" , \"two\" , \"one\" ] [ \"four\" , \"one\" , \"one\" , \"two\" ] [ \"four\" , \"two\" , \"one\" , \"one\" ] \"The quick brown fox jumps over the lazy dog.\" \"The quick brown fox jumps over the lazy dog.\" \"The quick brown fox jumps over the lazy dog.\" -42 17 17 42 -23 1024 -17 8 3.141592653589793 null null 42.22999954223633 null 23.42 true false Example The example below shows how JSON values are created from initializer lists. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_empty_init_list = json ({}); json j_object = { { \"one\" , 1 }, { \"two\" , 2 } }; json j_array = { 1 , 2 , 3 , 4 }; json j_nested_object = { { \"one\" , { 1 }}, { \"two\" , { 1 , 2 }} }; json j_nested_array = { {{ 1 }, \"one\" }, {{ 1 , 2 }, \"two\" } }; // serialize the JSON value std :: cout << j_empty_init_list << '\\n' ; std :: cout << j_object << '\\n' ; std :: cout << j_array << '\\n' ; std :: cout << j_nested_object << '\\n' ; std :: cout << j_nested_array << '\\n' ; } Output: {} { \"one\" : 1 , \"two\" : 2 } [ 1 , 2 , 3 , 4 ] { \"one\" :[ 1 ], \"two\" :[ 1 , 2 ]} [[[ 1 ], \"one\" ],[[ 1 , 2 ], \"two\" ]] Example The following code shows examples for creating arrays with several copies of a given value. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array by creating copies of a JSON value json value = \"Hello\" ; json array_0 = json ( 0 , value ); json array_1 = json ( 1 , value ); json array_5 = json ( 5 , value ); // serialize the JSON arrays std :: cout << array_0 << '\\n' ; std :: cout << array_1 << '\\n' ; std :: cout << array_5 << '\\n' ; } Output: [] [ \"Hello\" ] [ \"Hello\" , \"Hello\" , \"Hello\" , \"Hello\" , \"Hello\" ] Example The example below shows several ways to create JSON values by specifying a subrange with iterators. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_array = { \"alpha\" , \"bravo\" , \"charly\" , \"delta\" , \"easy\" }; json j_number = 42 ; json j_object = {{ \"one\" , \"eins\" }, { \"two\" , \"zwei\" }}; // create copies using iterators json j_array_range ( j_array . begin () + 1 , j_array . end () - 2 ); json j_number_range ( j_number . begin (), j_number . end ()); json j_object_range ( j_object . begin (), j_object . find ( \"two\" )); // serialize the values std :: cout << j_array_range << '\\n' ; std :: cout << j_number_range << '\\n' ; std :: cout << j_object_range << '\\n' ; // example for an exception try { json j_invalid ( j_number . begin () + 1 , j_number . end ()); } catch ( json :: invalid_iterator & e ) { std :: cout << e . what () << '\\n' ; } } Output: [ \"bravo\" , \"charly\" ] 42 { \"one\" : \"eins\" } [ json.exception.invalid_iterator. 204 ] iterators out of range Example The following code shows an example for the copy constructor. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON array json j1 = { \"one\" , \"two\" , 3 , 4.5 , false }; // create a copy json j2 ( j1 ); // serialize the JSON array std :: cout << j1 << \" = \" << j2 << '\\n' ; std :: cout << std :: boolalpha << ( j1 == j2 ) << '\\n' ; } Output: [ \"one\" , \"two\" , 3 , 4.5 , false ] = [ \"one\" , \"two\" , 3 , 4.5 , false ] true Example The code below shows the move constructor explicitly called via std::move . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json a = 23 ; // move contents of a to b json b ( std :: move ( a )); // serialize the JSON arrays std :: cout << a << '\\n' ; std :: cout << b << '\\n' ; } Output: null 23","title":"Example"},{"location":"api/basic_json/basic_json/#version-history","text":"Since version 1.0.0. Since version 1.0.0. Since version 2.1.0. Since version 3.2.0. Since version 1.0.0. Since version 1.0.0. Since version 1.0.0. Since version 1.0.0. Since version 1.0.0.","title":"Version history"},{"location":"api/basic_json/begin/","text":"basic_json::begin \u00b6 iterator begin () noexcept ; const_iterator begin () const noexcept ; Returns an iterator to the first element. Return value \u00b6 iterator to the first element Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code shows an example for begin() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array value json array = { 1 , 2 , 3 , 4 , 5 }; // get an iterator to the first element json :: iterator it = array . begin (); // serialize the element that the iterator points to std :: cout << * it << '\\n' ; } Output: 1 Version history \u00b6 Added in version 1.0.0.","title":"basic_json::begin"},{"location":"api/basic_json/begin/#basic_jsonbegin","text":"iterator begin () noexcept ; const_iterator begin () const noexcept ; Returns an iterator to the first element.","title":"basic_json::begin"},{"location":"api/basic_json/begin/#return-value","text":"iterator to the first element","title":"Return value"},{"location":"api/basic_json/begin/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/begin/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/begin/#example","text":"Example The following code shows an example for begin() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array value json array = { 1 , 2 , 3 , 4 , 5 }; // get an iterator to the first element json :: iterator it = array . begin (); // serialize the element that the iterator points to std :: cout << * it << '\\n' ; } Output: 1","title":"Example"},{"location":"api/basic_json/begin/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/binary/","text":"basic_json::binary \u00b6 // (1) static basic_json binary ( const typename binary_t :: container_type & init ); static basic_json binary ( typename binary_t :: container_type && init ); // (2) static basic_json binary ( const typename binary_t :: container_type & init , std :: uint8_t subtype ); static basic_json binary ( typename binary_t :: container_type && init , std :: uint8_t subtype ); Creates a JSON binary array value from a given binary container. Creates a JSON binary array value from a given binary container with subtype. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats. Parameters \u00b6 init (in) container containing bytes to use as binary type subtype (in) subtype to use in CBOR, MessagePack, and BSON Return value \u00b6 JSON binary array value Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Linear in the size of init ; constant for typename binary_t::container_type&& init versions. Notes \u00b6 Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a std::vector . Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident. Version history \u00b6 Added in version 3.8.0.","title":"basic_json::binary"},{"location":"api/basic_json/binary/#basic_jsonbinary","text":"// (1) static basic_json binary ( const typename binary_t :: container_type & init ); static basic_json binary ( typename binary_t :: container_type && init ); // (2) static basic_json binary ( const typename binary_t :: container_type & init , std :: uint8_t subtype ); static basic_json binary ( typename binary_t :: container_type && init , std :: uint8_t subtype ); Creates a JSON binary array value from a given binary container. Creates a JSON binary array value from a given binary container with subtype. Binary values are part of various binary formats, such as CBOR, MessagePack, and BSON. This constructor is used to create a value for serialization to those formats.","title":"basic_json::binary"},{"location":"api/basic_json/binary/#parameters","text":"init (in) container containing bytes to use as binary type subtype (in) subtype to use in CBOR, MessagePack, and BSON","title":"Parameters"},{"location":"api/basic_json/binary/#return-value","text":"JSON binary array value","title":"Return value"},{"location":"api/basic_json/binary/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/binary/#complexity","text":"Linear in the size of init ; constant for typename binary_t::container_type&& init versions.","title":"Complexity"},{"location":"api/basic_json/binary/#notes","text":"Note, this function exists because of the difficulty in correctly specifying the correct template overload in the standard value ctor, as both JSON arrays and JSON binary arrays are backed with some form of a std::vector . Because JSON binary arrays are a non-standard extension it was decided that it would be best to prevent automatic initialization of a binary array type, for backwards compatibility and so it does not happen on accident.","title":"Notes"},{"location":"api/basic_json/binary/#version-history","text":"Added in version 3.8.0.","title":"Version history"},{"location":"api/basic_json/boolean_t/","text":"basic_json::boolean_t \u00b6 using boolean_t = BooleanType ; The type used to store JSON booleans. RFC 7159 implicitly describes a boolean as a type which differentiates the two literals true and false . To store objects in C++, a type is defined by the template parameter BooleanType which chooses the type to use. Notes \u00b6 Default type \u00b6 With the default values for BooleanType ( bool ), the default value for boolean_t is bool . Storage \u00b6 Boolean values are stored directly inside a basic_json type. Version history \u00b6 Added in version 1.0.0.","title":"basic_json::boolean_t"},{"location":"api/basic_json/boolean_t/#basic_jsonboolean_t","text":"using boolean_t = BooleanType ; The type used to store JSON booleans. RFC 7159 implicitly describes a boolean as a type which differentiates the two literals true and false . To store objects in C++, a type is defined by the template parameter BooleanType which chooses the type to use.","title":"basic_json::boolean_t"},{"location":"api/basic_json/boolean_t/#notes","text":"","title":"Notes"},{"location":"api/basic_json/boolean_t/#default-type","text":"With the default values for BooleanType ( bool ), the default value for boolean_t is bool .","title":"Default type"},{"location":"api/basic_json/boolean_t/#storage","text":"Boolean values are stored directly inside a basic_json type.","title":"Storage"},{"location":"api/basic_json/boolean_t/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/cbegin/","text":"basic_json::cbegin \u00b6 const_iterator cbegin () const noexcept ; Returns an iterator to the first element. Return value \u00b6 iterator to the first element Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code shows an example for cbegin() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array value const json array = { 1 , 2 , 3 , 4 , 5 }; // get an iterator to the first element json :: const_iterator it = array . cbegin (); // serialize the element that the iterator points to std :: cout << * it << '\\n' ; } Output: 1 Version history \u00b6 Added in version 1.0.0.","title":"basic_json::cbegin"},{"location":"api/basic_json/cbegin/#basic_jsoncbegin","text":"const_iterator cbegin () const noexcept ; Returns an iterator to the first element.","title":"basic_json::cbegin"},{"location":"api/basic_json/cbegin/#return-value","text":"iterator to the first element","title":"Return value"},{"location":"api/basic_json/cbegin/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/cbegin/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/cbegin/#example","text":"Example The following code shows an example for cbegin() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array value const json array = { 1 , 2 , 3 , 4 , 5 }; // get an iterator to the first element json :: const_iterator it = array . cbegin (); // serialize the element that the iterator points to std :: cout << * it << '\\n' ; } Output: 1","title":"Example"},{"location":"api/basic_json/cbegin/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/cend/","text":"basic_json::cend \u00b6 const_iterator cend () const noexcept ; Returns an iterator to one past the last element. Return value \u00b6 iterator one past the last element Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code shows an example for cend() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array value json array = { 1 , 2 , 3 , 4 , 5 }; // get an iterator to one past the last element json :: const_iterator it = array . cend (); // decrement the iterator to point to the last element -- it ; // serialize the element that the iterator points to std :: cout << * it << '\\n' ; } Output: 5 Version history \u00b6 Added in version 1.0.0.","title":"basic_json::cend"},{"location":"api/basic_json/cend/#basic_jsoncend","text":"const_iterator cend () const noexcept ; Returns an iterator to one past the last element.","title":"basic_json::cend"},{"location":"api/basic_json/cend/#return-value","text":"iterator one past the last element","title":"Return value"},{"location":"api/basic_json/cend/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/cend/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/cend/#example","text":"Example The following code shows an example for cend() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array value json array = { 1 , 2 , 3 , 4 , 5 }; // get an iterator to one past the last element json :: const_iterator it = array . cend (); // decrement the iterator to point to the last element -- it ; // serialize the element that the iterator points to std :: cout << * it << '\\n' ; } Output: 5","title":"Example"},{"location":"api/basic_json/cend/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/clear/","text":"basic_json::clear \u00b6 void clear () noexcept ; Clears the content of a JSON value and resets it to the default value as if basic_json(value_t) would have been called with the current value type from type() : Value type initial value null null boolean false string \"\" number 0 binary An empty byte vector object {} array [] Has the same effect as calling * this = basic_json ( type ()); Exception safety \u00b6 No-throw guarantee: this function never throws exceptions. Complexity \u00b6 Linear in the size of the JSON value. Notes \u00b6 All iterators, pointers and references related to this container are invalidated. Example \u00b6 Example The example below shows the effect of clear() to different JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; // call clear() j_null . clear (); j_boolean . clear (); j_number_integer . clear (); j_number_float . clear (); j_object . clear (); j_array . clear (); j_string . clear (); // serialize the cleared values() std :: cout << j_null << '\\n' ; std :: cout << j_boolean << '\\n' ; std :: cout << j_number_integer << '\\n' ; std :: cout << j_number_float << '\\n' ; std :: cout << j_object << '\\n' ; std :: cout << j_array << '\\n' ; std :: cout << j_string << '\\n' ; } Output: null false 0 0.0 {} [] \"\" Version history \u00b6 Added in version 1.0.0. Added support for binary types in version 3.8.0.","title":"basic_json::clear"},{"location":"api/basic_json/clear/#basic_jsonclear","text":"void clear () noexcept ; Clears the content of a JSON value and resets it to the default value as if basic_json(value_t) would have been called with the current value type from type() : Value type initial value null null boolean false string \"\" number 0 binary An empty byte vector object {} array [] Has the same effect as calling * this = basic_json ( type ());","title":"basic_json::clear"},{"location":"api/basic_json/clear/#exception-safety","text":"No-throw guarantee: this function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/clear/#complexity","text":"Linear in the size of the JSON value.","title":"Complexity"},{"location":"api/basic_json/clear/#notes","text":"All iterators, pointers and references related to this container are invalidated.","title":"Notes"},{"location":"api/basic_json/clear/#example","text":"Example The example below shows the effect of clear() to different JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; // call clear() j_null . clear (); j_boolean . clear (); j_number_integer . clear (); j_number_float . clear (); j_object . clear (); j_array . clear (); j_string . clear (); // serialize the cleared values() std :: cout << j_null << '\\n' ; std :: cout << j_boolean << '\\n' ; std :: cout << j_number_integer << '\\n' ; std :: cout << j_number_float << '\\n' ; std :: cout << j_object << '\\n' ; std :: cout << j_array << '\\n' ; std :: cout << j_string << '\\n' ; } Output: null false 0 0.0 {} [] \"\"","title":"Example"},{"location":"api/basic_json/clear/#version-history","text":"Added in version 1.0.0. Added support for binary types in version 3.8.0.","title":"Version history"},{"location":"api/basic_json/contains/","text":"basic_json::contains \u00b6 template < typename KeyT > bool contains ( KeyT && key ) const ; Check whether an element exists in a JSON object with key equivalent to key . If the element is not found or the JSON value is not an object, false is returned. Template parameters \u00b6 KeyT A type for an object key other than basic_json::json_pointer . Parameters \u00b6 key (in) key value to check its existence. Return value \u00b6 true if an element with specified key exists. If no such element with such key is found or the JSON value is not an object, false is returned. Exception safety \u00b6 Strong exception safety: if an exception occurs, the original value stays intact. Complexity \u00b6 Logarithmic in the size of the JSON object. Notes \u00b6 This method always returns false when executed on a JSON type that is not an object. Example \u00b6 Example The example shows how contains() is used. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create some JSON values json j_object = R \" ( {\"key\": \"value\"} ) \" _json ; json j_array = R \" ( [1, 2, 3] ) \" _json ; // call contains std :: cout << std :: boolalpha << \"j_object contains 'key': \" << j_object . contains ( \"key\" ) << '\\n' << \"j_object contains 'another': \" << j_object . contains ( \"another\" ) << '\\n' << \"j_array contains 'key': \" << j_array . contains ( \"key\" ) << std :: endl ; } Output: j_object contains 'key': true j_object contains 'another': false j_array contains 'key': false Version history \u00b6 Added in version 3.6.0.","title":"basic_json::contains"},{"location":"api/basic_json/contains/#basic_jsoncontains","text":"template < typename KeyT > bool contains ( KeyT && key ) const ; Check whether an element exists in a JSON object with key equivalent to key . If the element is not found or the JSON value is not an object, false is returned.","title":"basic_json::contains"},{"location":"api/basic_json/contains/#template-parameters","text":"KeyT A type for an object key other than basic_json::json_pointer .","title":"Template parameters"},{"location":"api/basic_json/contains/#parameters","text":"key (in) key value to check its existence.","title":"Parameters"},{"location":"api/basic_json/contains/#return-value","text":"true if an element with specified key exists. If no such element with such key is found or the JSON value is not an object, false is returned.","title":"Return value"},{"location":"api/basic_json/contains/#exception-safety","text":"Strong exception safety: if an exception occurs, the original value stays intact.","title":"Exception safety"},{"location":"api/basic_json/contains/#complexity","text":"Logarithmic in the size of the JSON object.","title":"Complexity"},{"location":"api/basic_json/contains/#notes","text":"This method always returns false when executed on a JSON type that is not an object.","title":"Notes"},{"location":"api/basic_json/contains/#example","text":"Example The example shows how contains() is used. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create some JSON values json j_object = R \" ( {\"key\": \"value\"} ) \" _json ; json j_array = R \" ( [1, 2, 3] ) \" _json ; // call contains std :: cout << std :: boolalpha << \"j_object contains 'key': \" << j_object . contains ( \"key\" ) << '\\n' << \"j_object contains 'another': \" << j_object . contains ( \"another\" ) << '\\n' << \"j_array contains 'key': \" << j_array . contains ( \"key\" ) << std :: endl ; } Output: j_object contains 'key': true j_object contains 'another': false j_array contains 'key': false","title":"Example"},{"location":"api/basic_json/contains/#version-history","text":"Added in version 3.6.0.","title":"Version history"},{"location":"api/basic_json/count/","text":"basic_json::count \u00b6 template < typename KeyT > size_type count ( KeyT && key ) const ; Returns the number of elements with key key . If ObjectType is the default std::map type, the return value will always be 0 ( key was not found) or 1 ( key was found). Template parameters \u00b6 KeyT A type for an object key. Parameters \u00b6 key (in) key value of the element to count. Return value \u00b6 Number of elements with key key . If the JSON value is not an object, the return value will be 0 . Exception safety \u00b6 Strong exception safety: if an exception occurs, the original value stays intact. Complexity \u00b6 Logarithmic in the size of the JSON object. Notes \u00b6 This method always returns 0 when executed on a JSON type that is not an object. Example \u00b6 Example The example shows how count() is used. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON object json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; // call count() auto count_two = j_object . count ( \"two\" ); auto count_three = j_object . count ( \"three\" ); // print values std :: cout << \"number of elements with key \\\" two \\\" : \" << count_two << '\\n' ; std :: cout << \"number of elements with key \\\" three \\\" : \" << count_three << '\\n' ; } Output: number of elements with key \"two\" : 1 number of elements with key \"three\" : 0 Version history \u00b6 Added in version 1.0.0.","title":"basic_json::count"},{"location":"api/basic_json/count/#basic_jsoncount","text":"template < typename KeyT > size_type count ( KeyT && key ) const ; Returns the number of elements with key key . If ObjectType is the default std::map type, the return value will always be 0 ( key was not found) or 1 ( key was found).","title":"basic_json::count"},{"location":"api/basic_json/count/#template-parameters","text":"KeyT A type for an object key.","title":"Template parameters"},{"location":"api/basic_json/count/#parameters","text":"key (in) key value of the element to count.","title":"Parameters"},{"location":"api/basic_json/count/#return-value","text":"Number of elements with key key . If the JSON value is not an object, the return value will be 0 .","title":"Return value"},{"location":"api/basic_json/count/#exception-safety","text":"Strong exception safety: if an exception occurs, the original value stays intact.","title":"Exception safety"},{"location":"api/basic_json/count/#complexity","text":"Logarithmic in the size of the JSON object.","title":"Complexity"},{"location":"api/basic_json/count/#notes","text":"This method always returns 0 when executed on a JSON type that is not an object.","title":"Notes"},{"location":"api/basic_json/count/#example","text":"Example The example shows how count() is used. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON object json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; // call count() auto count_two = j_object . count ( \"two\" ); auto count_three = j_object . count ( \"three\" ); // print values std :: cout << \"number of elements with key \\\" two \\\" : \" << count_two << '\\n' ; std :: cout << \"number of elements with key \\\" three \\\" : \" << count_three << '\\n' ; } Output: number of elements with key \"two\" : 1 number of elements with key \"three\" : 0","title":"Example"},{"location":"api/basic_json/count/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/crbegin/","text":"basic_json::crbegin \u00b6 const_reverse_iterator crbegin () const noexcept ; Returns an iterator to the reverse-beginning; that is, the last element. Return value \u00b6 reverse iterator to the first element Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code shows an example for crbegin() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array value json array = { 1 , 2 , 3 , 4 , 5 }; // get an iterator to the reverse-beginning json :: const_reverse_iterator it = array . crbegin (); // serialize the element that the iterator points to std :: cout << * it << '\\n' ; } Output: 5 Version history \u00b6 Added in version 1.0.0.","title":"basic_json::crbegin"},{"location":"api/basic_json/crbegin/#basic_jsoncrbegin","text":"const_reverse_iterator crbegin () const noexcept ; Returns an iterator to the reverse-beginning; that is, the last element.","title":"basic_json::crbegin"},{"location":"api/basic_json/crbegin/#return-value","text":"reverse iterator to the first element","title":"Return value"},{"location":"api/basic_json/crbegin/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/crbegin/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/crbegin/#example","text":"Example The following code shows an example for crbegin() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array value json array = { 1 , 2 , 3 , 4 , 5 }; // get an iterator to the reverse-beginning json :: const_reverse_iterator it = array . crbegin (); // serialize the element that the iterator points to std :: cout << * it << '\\n' ; } Output: 5","title":"Example"},{"location":"api/basic_json/crbegin/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/crend/","text":"basic_json::rend \u00b6 const_reverse_iterator crend () const noexcept ; Returns an iterator to the reverse-end; that is, one before the first element. This element acts as a placeholder, attempting to access it results in undefined behavior. Return value \u00b6 reverse iterator to the element following the last element Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code shows an example for eend() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array value json array = { 1 , 2 , 3 , 4 , 5 }; // get an iterator to the reverse-end json :: const_reverse_iterator it = array . crend (); // increment the iterator to point to the first element -- it ; // serialize the element that the iterator points to std :: cout << * it << '\\n' ; } Output: 1 Version history \u00b6 Added in version 1.0.0.","title":"basic_json::rend"},{"location":"api/basic_json/crend/#basic_jsonrend","text":"const_reverse_iterator crend () const noexcept ; Returns an iterator to the reverse-end; that is, one before the first element. This element acts as a placeholder, attempting to access it results in undefined behavior.","title":"basic_json::rend"},{"location":"api/basic_json/crend/#return-value","text":"reverse iterator to the element following the last element","title":"Return value"},{"location":"api/basic_json/crend/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/crend/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/crend/#example","text":"Example The following code shows an example for eend() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array value json array = { 1 , 2 , 3 , 4 , 5 }; // get an iterator to the reverse-end json :: const_reverse_iterator it = array . crend (); // increment the iterator to point to the first element -- it ; // serialize the element that the iterator points to std :: cout << * it << '\\n' ; } Output: 1","title":"Example"},{"location":"api/basic_json/crend/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/diff/","text":"basic_json::diff \u00b6 static basic_json diff ( const basic_json & source , const basic_json & target ); Creates a JSON Patch so that value source can be changed into the value target by calling patch function. For two JSON values source and target , the following code yields always true : source . patch ( diff ( source , target )) == target ; Parameters \u00b6 source (in) JSON value to compare from target (in) JSON value to compare against Return value \u00b6 a JSON patch to convert the source to target Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Linear in the lengths of source and target . Note \u00b6 Currently, only remove , add , and replace operations are generated. Example \u00b6 Example The following code shows how a JSON patch is created as a diff for two JSON values. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // the source document json source = R \" ( { \"baz\": \"qux\", \"foo\": \"bar\" } ) \" _json ; // the target document json target = R \" ( { \"baz\": \"boo\", \"hello\": [ \"world\" ] } ) \" _json ; // create the patch json patch = json :: diff ( source , target ); // roundtrip json patched_source = source . patch ( patch ); // output patch and roundtrip result std :: cout << std :: setw ( 4 ) << patch << \" \\n\\n \" << std :: setw ( 4 ) << patched_source << std :: endl ; } Output: [ { \"op\" : \"replace\" , \"path\" : \"/baz\" , \"value\" : \"boo\" }, { \"op\" : \"remove\" , \"path\" : \"/foo\" }, { \"op\" : \"add\" , \"path\" : \"/hello\" , \"value\" : [ \"world\" ] } ] { \"baz\" : \"boo\" , \"hello\" : [ \"world\" ] } Version history \u00b6 Added in version 2.0.0.","title":"basic_json::diff"},{"location":"api/basic_json/diff/#basic_jsondiff","text":"static basic_json diff ( const basic_json & source , const basic_json & target ); Creates a JSON Patch so that value source can be changed into the value target by calling patch function. For two JSON values source and target , the following code yields always true : source . patch ( diff ( source , target )) == target ;","title":"basic_json::diff"},{"location":"api/basic_json/diff/#parameters","text":"source (in) JSON value to compare from target (in) JSON value to compare against","title":"Parameters"},{"location":"api/basic_json/diff/#return-value","text":"a JSON patch to convert the source to target","title":"Return value"},{"location":"api/basic_json/diff/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/diff/#complexity","text":"Linear in the lengths of source and target .","title":"Complexity"},{"location":"api/basic_json/diff/#note","text":"Currently, only remove , add , and replace operations are generated.","title":"Note"},{"location":"api/basic_json/diff/#example","text":"Example The following code shows how a JSON patch is created as a diff for two JSON values. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // the source document json source = R \" ( { \"baz\": \"qux\", \"foo\": \"bar\" } ) \" _json ; // the target document json target = R \" ( { \"baz\": \"boo\", \"hello\": [ \"world\" ] } ) \" _json ; // create the patch json patch = json :: diff ( source , target ); // roundtrip json patched_source = source . patch ( patch ); // output patch and roundtrip result std :: cout << std :: setw ( 4 ) << patch << \" \\n\\n \" << std :: setw ( 4 ) << patched_source << std :: endl ; } Output: [ { \"op\" : \"replace\" , \"path\" : \"/baz\" , \"value\" : \"boo\" }, { \"op\" : \"remove\" , \"path\" : \"/foo\" }, { \"op\" : \"add\" , \"path\" : \"/hello\" , \"value\" : [ \"world\" ] } ] { \"baz\" : \"boo\" , \"hello\" : [ \"world\" ] }","title":"Example"},{"location":"api/basic_json/diff/#version-history","text":"Added in version 2.0.0.","title":"Version history"},{"location":"api/basic_json/dump/","text":"basic_json::dump \u00b6 string_t dump ( const int indent = - 1 , const char indent_char = ' ' , const bool ensure_ascii = false , const error_handler_t error_handler = error_handler_t :: strict ) const ; Serialization function for JSON values. The function tries to mimic Python's json.dumps() function, and currently supports its indent and ensure_ascii parameters. Parameters \u00b6 indent (in) If indent is nonnegative, then array elements and object members will be pretty-printed with that indent level. An indent level of 0 will only insert newlines. -1 (the default) selects the most compact representation. indent_char (in) The character to use for indentation if indent is greater than 0 . The default is (space). ensure_ascii (in) If ensure_ascii is true, all non-ASCII characters in the output are escaped with \\uXXXX sequences, and the result consists of ASCII characters only. error_handler (in) how to react on decoding errors; there are three possible values (see error_handler_t : strict (throws and exception in case a decoding error occurs; default), replace (replace invalid UTF-8 sequences with U+FFFD), and ignore (ignore invalid UTF-8 sequences during serialization; all bytes are copied to the output unchanged). Return value \u00b6 string containing the serialization of the JSON value Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes to any JSON value. Complexity \u00b6 Linear. Notes \u00b6 Binary values are serialized as object containing two keys: \"bytes\": an array of bytes as integers \"subtype\": the subtype as integer or null if the binary has no subtype Example \u00b6 Example The following example shows the effect of different indent , indent_char , and ensure_ascii parameters to the result of the serialization. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hell\u00f6 \ud83d\ude00!\" ; // call dump() std :: cout << \"objects:\" << '\\n' << j_object . dump () << \" \\n\\n \" << j_object . dump ( - 1 ) << \" \\n\\n \" << j_object . dump ( 0 ) << \" \\n\\n \" << j_object . dump ( 4 ) << \" \\n\\n \" << j_object . dump ( 1 , '\\t' ) << \" \\n\\n \" ; std :: cout << \"arrays:\" << '\\n' << j_array . dump () << \" \\n\\n \" << j_array . dump ( - 1 ) << \" \\n\\n \" << j_array . dump ( 0 ) << \" \\n\\n \" << j_array . dump ( 4 ) << \" \\n\\n \" << j_array . dump ( 1 , '\\t' ) << \" \\n\\n \" ; std :: cout << \"strings:\" << '\\n' << j_string . dump () << '\\n' << j_string . dump ( - 1 , ' ' , true ) << '\\n' ; // create JSON value with invalid UTF-8 byte sequence json j_invalid = \"\u00e4 \\xA9 \u00fc\" ; try { std :: cout << j_invalid . dump () << std :: endl ; } catch ( json :: type_error & e ) { std :: cout << e . what () << std :: endl ; } std :: cout << \"string with replaced invalid characters: \" << j_invalid . dump ( - 1 , ' ' , false , json :: error_handler_t :: replace ) << \" \\n string with ignored invalid characters: \" << j_invalid . dump ( - 1 , ' ' , false , json :: error_handler_t :: ignore ) << '\\n' ; } Output: objects: { \"one\" : 1 , \"two\" : 2 } { \"one\" : 1 , \"two\" : 2 } { \"one\" : 1 , \"two\" : 2 } { \"one\" : 1 , \"two\" : 2 } { \"one\" : 1 , \"two\" : 2 } arrays: [ 1 , 2 , 4 , 8 , 16 ] [ 1 , 2 , 4 , 8 , 16 ] [ 1 , 2 , 4 , 8 , 16 ] [ 1 , 2 , 4 , 8 , 16 ] [ 1 , 2 , 4 , 8 , 16 ] strings: \"Hell\u00f6 \ud83d\ude00!\" \"Hell\\u00f6 \\ud83d\\ude00!\" [ json.exception.type_error. 316 ] invalid UTF -8 byte at index 2 : 0 xA 9 string with replaced invalid characters: \"\u00e4\ufffd\u00fc\" string with ignored invalid characters: \"\u00e4\u00fc\"","title":"basic_json::dump"},{"location":"api/basic_json/dump/#basic_jsondump","text":"string_t dump ( const int indent = - 1 , const char indent_char = ' ' , const bool ensure_ascii = false , const error_handler_t error_handler = error_handler_t :: strict ) const ; Serialization function for JSON values. The function tries to mimic Python's json.dumps() function, and currently supports its indent and ensure_ascii parameters.","title":"basic_json::dump"},{"location":"api/basic_json/dump/#parameters","text":"indent (in) If indent is nonnegative, then array elements and object members will be pretty-printed with that indent level. An indent level of 0 will only insert newlines. -1 (the default) selects the most compact representation. indent_char (in) The character to use for indentation if indent is greater than 0 . The default is (space). ensure_ascii (in) If ensure_ascii is true, all non-ASCII characters in the output are escaped with \\uXXXX sequences, and the result consists of ASCII characters only. error_handler (in) how to react on decoding errors; there are three possible values (see error_handler_t : strict (throws and exception in case a decoding error occurs; default), replace (replace invalid UTF-8 sequences with U+FFFD), and ignore (ignore invalid UTF-8 sequences during serialization; all bytes are copied to the output unchanged).","title":"Parameters"},{"location":"api/basic_json/dump/#return-value","text":"string containing the serialization of the JSON value","title":"Return value"},{"location":"api/basic_json/dump/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes to any JSON value.","title":"Exception safety"},{"location":"api/basic_json/dump/#complexity","text":"Linear.","title":"Complexity"},{"location":"api/basic_json/dump/#notes","text":"Binary values are serialized as object containing two keys: \"bytes\": an array of bytes as integers \"subtype\": the subtype as integer or null if the binary has no subtype","title":"Notes"},{"location":"api/basic_json/dump/#example","text":"Example The following example shows the effect of different indent , indent_char , and ensure_ascii parameters to the result of the serialization. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hell\u00f6 \ud83d\ude00!\" ; // call dump() std :: cout << \"objects:\" << '\\n' << j_object . dump () << \" \\n\\n \" << j_object . dump ( - 1 ) << \" \\n\\n \" << j_object . dump ( 0 ) << \" \\n\\n \" << j_object . dump ( 4 ) << \" \\n\\n \" << j_object . dump ( 1 , '\\t' ) << \" \\n\\n \" ; std :: cout << \"arrays:\" << '\\n' << j_array . dump () << \" \\n\\n \" << j_array . dump ( - 1 ) << \" \\n\\n \" << j_array . dump ( 0 ) << \" \\n\\n \" << j_array . dump ( 4 ) << \" \\n\\n \" << j_array . dump ( 1 , '\\t' ) << \" \\n\\n \" ; std :: cout << \"strings:\" << '\\n' << j_string . dump () << '\\n' << j_string . dump ( - 1 , ' ' , true ) << '\\n' ; // create JSON value with invalid UTF-8 byte sequence json j_invalid = \"\u00e4 \\xA9 \u00fc\" ; try { std :: cout << j_invalid . dump () << std :: endl ; } catch ( json :: type_error & e ) { std :: cout << e . what () << std :: endl ; } std :: cout << \"string with replaced invalid characters: \" << j_invalid . dump ( - 1 , ' ' , false , json :: error_handler_t :: replace ) << \" \\n string with ignored invalid characters: \" << j_invalid . dump ( - 1 , ' ' , false , json :: error_handler_t :: ignore ) << '\\n' ; } Output: objects: { \"one\" : 1 , \"two\" : 2 } { \"one\" : 1 , \"two\" : 2 } { \"one\" : 1 , \"two\" : 2 } { \"one\" : 1 , \"two\" : 2 } { \"one\" : 1 , \"two\" : 2 } arrays: [ 1 , 2 , 4 , 8 , 16 ] [ 1 , 2 , 4 , 8 , 16 ] [ 1 , 2 , 4 , 8 , 16 ] [ 1 , 2 , 4 , 8 , 16 ] [ 1 , 2 , 4 , 8 , 16 ] strings: \"Hell\u00f6 \ud83d\ude00!\" \"Hell\\u00f6 \\ud83d\\ude00!\" [ json.exception.type_error. 316 ] invalid UTF -8 byte at index 2 : 0 xA 9 string with replaced invalid characters: \"\u00e4\ufffd\u00fc\" string with ignored invalid characters: \"\u00e4\u00fc\"","title":"Example"},{"location":"api/basic_json/emplace/","text":"basic_json::emplace \u00b6 template < class ... Args > std :: pair < iterator , bool > emplace ( Args && ... args ); Inserts a new element into a JSON object constructed in-place with the given args if there is no element with the key in the container. If the function is called on a JSON null value, an empty object is created before appending the value created from args . Template parameters \u00b6 Args compatible types to create a basic_json object Parameters \u00b6 args (in) arguments to forward to a constructor of basic_json Return value \u00b6 a pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place. Exceptions \u00b6 Throws type_error.311 when called on a type other than JSON object or null ; example: \"cannot use emplace() with number\" Complexity \u00b6 Logarithmic in the size of the container, O(log( size() )). Examples \u00b6 Example The example shows how emplace() can be used to add elements to a JSON object. Note how the null value was silently converted to a JSON object. Further note how no value is added if there was already one value stored with the same key. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json null ; // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; // add values auto res1 = object . emplace ( \"three\" , 3 ); null . emplace ( \"A\" , \"a\" ); null . emplace ( \"B\" , \"b\" ); // the following call will not add an object, because there is already // a value stored at key \"B\" auto res2 = null . emplace ( \"B\" , \"c\" ); // print values std :: cout << object << '\\n' ; std :: cout << * res1 . first << \" \" << std :: boolalpha << res1 . second << '\\n' ; std :: cout << null << '\\n' ; std :: cout << * res2 . first << \" \" << std :: boolalpha << res2 . second << '\\n' ; } Output: { \"one\" : 1 , \"two\" : 2 } null { \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } 3 true { \"A\" : \"a\" , \"B\" : \"b\" } \"b\" false Version history \u00b6 Since version 2.0.8.","title":"basic_json::emplace"},{"location":"api/basic_json/emplace/#basic_jsonemplace","text":"template < class ... Args > std :: pair < iterator , bool > emplace ( Args && ... args ); Inserts a new element into a JSON object constructed in-place with the given args if there is no element with the key in the container. If the function is called on a JSON null value, an empty object is created before appending the value created from args .","title":"basic_json::emplace"},{"location":"api/basic_json/emplace/#template-parameters","text":"Args compatible types to create a basic_json object","title":"Template parameters"},{"location":"api/basic_json/emplace/#parameters","text":"args (in) arguments to forward to a constructor of basic_json","title":"Parameters"},{"location":"api/basic_json/emplace/#return-value","text":"a pair consisting of an iterator to the inserted element, or the already-existing element if no insertion happened, and a bool denoting whether the insertion took place.","title":"Return value"},{"location":"api/basic_json/emplace/#exceptions","text":"Throws type_error.311 when called on a type other than JSON object or null ; example: \"cannot use emplace() with number\"","title":"Exceptions"},{"location":"api/basic_json/emplace/#complexity","text":"Logarithmic in the size of the container, O(log( size() )).","title":"Complexity"},{"location":"api/basic_json/emplace/#examples","text":"Example The example shows how emplace() can be used to add elements to a JSON object. Note how the null value was silently converted to a JSON object. Further note how no value is added if there was already one value stored with the same key. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json null ; // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; // add values auto res1 = object . emplace ( \"three\" , 3 ); null . emplace ( \"A\" , \"a\" ); null . emplace ( \"B\" , \"b\" ); // the following call will not add an object, because there is already // a value stored at key \"B\" auto res2 = null . emplace ( \"B\" , \"c\" ); // print values std :: cout << object << '\\n' ; std :: cout << * res1 . first << \" \" << std :: boolalpha << res1 . second << '\\n' ; std :: cout << null << '\\n' ; std :: cout << * res2 . first << \" \" << std :: boolalpha << res2 . second << '\\n' ; } Output: { \"one\" : 1 , \"two\" : 2 } null { \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } 3 true { \"A\" : \"a\" , \"B\" : \"b\" } \"b\" false","title":"Examples"},{"location":"api/basic_json/emplace/#version-history","text":"Since version 2.0.8.","title":"Version history"},{"location":"api/basic_json/emplace_back/","text":"basic_json::emplace_back \u00b6 template < class ... Args > reference emplace_back ( Args && ... args ); Creates a JSON value from the passed parameters args to the end of the JSON value. If the function is called on a JSON null value, an empty array is created before appending the value created from args . Template parameters \u00b6 Args compatible types to create a basic_json object Parameters \u00b6 args (in) arguments to forward to a constructor of basic_json Return value \u00b6 reference to the inserted element Exceptions \u00b6 Throws type_error.311 when called on a type other than JSON array or null ; example: \"cannot use emplace_back() with number\" Complexity \u00b6 Amortized constant. Examples \u00b6 Example The example shows how emplace_back() can be used to add elements to a JSON array. Note how the null value was silently converted to a JSON array. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json array = { 1 , 2 , 3 , 4 , 5 }; json null ; // print values std :: cout << array << '\\n' ; std :: cout << null << '\\n' ; // add values array . emplace_back ( 6 ); null . emplace_back ( \"first\" ); null . emplace_back ( 3 , \"second\" ); // print values std :: cout << array << '\\n' ; std :: cout << null << '\\n' ; } Output: [ 1 , 2 , 3 , 4 , 5 ] null [ 1 , 2 , 3 , 4 , 5 , 6 ] [ \"first\" ,[ \"second\" , \"second\" , \"second\" ]] Version history \u00b6 Since version 2.0.8. Returns reference since 3.7.0.","title":"basic_json::emplace_back"},{"location":"api/basic_json/emplace_back/#basic_jsonemplace_back","text":"template < class ... Args > reference emplace_back ( Args && ... args ); Creates a JSON value from the passed parameters args to the end of the JSON value. If the function is called on a JSON null value, an empty array is created before appending the value created from args .","title":"basic_json::emplace_back"},{"location":"api/basic_json/emplace_back/#template-parameters","text":"Args compatible types to create a basic_json object","title":"Template parameters"},{"location":"api/basic_json/emplace_back/#parameters","text":"args (in) arguments to forward to a constructor of basic_json","title":"Parameters"},{"location":"api/basic_json/emplace_back/#return-value","text":"reference to the inserted element","title":"Return value"},{"location":"api/basic_json/emplace_back/#exceptions","text":"Throws type_error.311 when called on a type other than JSON array or null ; example: \"cannot use emplace_back() with number\"","title":"Exceptions"},{"location":"api/basic_json/emplace_back/#complexity","text":"Amortized constant.","title":"Complexity"},{"location":"api/basic_json/emplace_back/#examples","text":"Example The example shows how emplace_back() can be used to add elements to a JSON array. Note how the null value was silently converted to a JSON array. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json array = { 1 , 2 , 3 , 4 , 5 }; json null ; // print values std :: cout << array << '\\n' ; std :: cout << null << '\\n' ; // add values array . emplace_back ( 6 ); null . emplace_back ( \"first\" ); null . emplace_back ( 3 , \"second\" ); // print values std :: cout << array << '\\n' ; std :: cout << null << '\\n' ; } Output: [ 1 , 2 , 3 , 4 , 5 ] null [ 1 , 2 , 3 , 4 , 5 , 6 ] [ \"first\" ,[ \"second\" , \"second\" , \"second\" ]]","title":"Examples"},{"location":"api/basic_json/emplace_back/#version-history","text":"Since version 2.0.8. Returns reference since 3.7.0.","title":"Version history"},{"location":"api/basic_json/empty/","text":"basic_json::empty \u00b6 bool empty () const noexcept ; Checks if a JSON value has no elements (i.e. whether its size() is 0 ). Return value \u00b6 The return value depends on the different types and is defined as follows: Value type return value null true boolean false string false number false binary false object result of function object_t::empty() array result of function array_t::empty() Exception safety \u00b6 No-throw guarantee: this function never throws exceptions. Complexity \u00b6 Constant, as long as array_t and object_t satisfy the Container concept; that is, their empty() functions have constant complexity. Possible implementation \u00b6 bool empty () const noexcept { return size () == 0 ; } Notes \u00b6 This function does not return whether a string stored as JSON value is empty -- it returns whether the JSON container itself is empty which is false in the case of a string. Example \u00b6 Example The following code uses empty() to check if a JSON object contains any elements. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_object_empty ( json :: value_t :: object ); json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_array_empty ( json :: value_t :: array ); json j_string = \"Hello, world\" ; // call empty() std :: cout << std :: boolalpha ; std :: cout << j_null . empty () << '\\n' ; std :: cout << j_boolean . empty () << '\\n' ; std :: cout << j_number_integer . empty () << '\\n' ; std :: cout << j_number_float . empty () << '\\n' ; std :: cout << j_object . empty () << '\\n' ; std :: cout << j_object_empty . empty () << '\\n' ; std :: cout << j_array . empty () << '\\n' ; std :: cout << j_array_empty . empty () << '\\n' ; std :: cout << j_string . empty () << '\\n' ; } Output: true false false false false true false true false Version history \u00b6 Added in version 1.0.0. Extended to return false for binary types in version 3.8.0.","title":"basic_json::empty"},{"location":"api/basic_json/empty/#basic_jsonempty","text":"bool empty () const noexcept ; Checks if a JSON value has no elements (i.e. whether its size() is 0 ).","title":"basic_json::empty"},{"location":"api/basic_json/empty/#return-value","text":"The return value depends on the different types and is defined as follows: Value type return value null true boolean false string false number false binary false object result of function object_t::empty() array result of function array_t::empty()","title":"Return value"},{"location":"api/basic_json/empty/#exception-safety","text":"No-throw guarantee: this function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/empty/#complexity","text":"Constant, as long as array_t and object_t satisfy the Container concept; that is, their empty() functions have constant complexity.","title":"Complexity"},{"location":"api/basic_json/empty/#possible-implementation","text":"bool empty () const noexcept { return size () == 0 ; }","title":"Possible implementation"},{"location":"api/basic_json/empty/#notes","text":"This function does not return whether a string stored as JSON value is empty -- it returns whether the JSON container itself is empty which is false in the case of a string.","title":"Notes"},{"location":"api/basic_json/empty/#example","text":"Example The following code uses empty() to check if a JSON object contains any elements. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_object_empty ( json :: value_t :: object ); json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_array_empty ( json :: value_t :: array ); json j_string = \"Hello, world\" ; // call empty() std :: cout << std :: boolalpha ; std :: cout << j_null . empty () << '\\n' ; std :: cout << j_boolean . empty () << '\\n' ; std :: cout << j_number_integer . empty () << '\\n' ; std :: cout << j_number_float . empty () << '\\n' ; std :: cout << j_object . empty () << '\\n' ; std :: cout << j_object_empty . empty () << '\\n' ; std :: cout << j_array . empty () << '\\n' ; std :: cout << j_array_empty . empty () << '\\n' ; std :: cout << j_string . empty () << '\\n' ; } Output: true false false false false true false true false","title":"Example"},{"location":"api/basic_json/empty/#version-history","text":"Added in version 1.0.0. Extended to return false for binary types in version 3.8.0.","title":"Version history"},{"location":"api/basic_json/end/","text":"basic_json::end \u00b6 iterator end () noexcept ; const_iterator end () const noexcept ; Returns an iterator to one past the last element. Return value \u00b6 iterator one past the last element Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code shows an example for end() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array value json array = { 1 , 2 , 3 , 4 , 5 }; // get an iterator to one past the last element json :: iterator it = array . end (); // decrement the iterator to point to the last element -- it ; // serialize the element that the iterator points to std :: cout << * it << '\\n' ; } Output: 5 Version history \u00b6 Added in version 1.0.0.","title":"basic_json::end"},{"location":"api/basic_json/end/#basic_jsonend","text":"iterator end () noexcept ; const_iterator end () const noexcept ; Returns an iterator to one past the last element.","title":"basic_json::end"},{"location":"api/basic_json/end/#return-value","text":"iterator one past the last element","title":"Return value"},{"location":"api/basic_json/end/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/end/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/end/#example","text":"Example The following code shows an example for end() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array value json array = { 1 , 2 , 3 , 4 , 5 }; // get an iterator to one past the last element json :: iterator it = array . end (); // decrement the iterator to point to the last element -- it ; // serialize the element that the iterator points to std :: cout << * it << '\\n' ; } Output: 5","title":"Example"},{"location":"api/basic_json/end/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/erase/","text":"basic_json::erase \u00b6 // (1) iterator erase ( iterator pos ); const_iterator erase ( const_iterator pos ); // (2) iterator erase ( iterator first , iterator last ); const_iterator erase ( const_iterator first , const_iterator last ); // (3) size_type erase ( const typename object_t :: key_type & key ); // (4) void erase ( const size_type idx ); Removes an element from a JSON value specified by iterator pos . The iterator pos must be valid and dereferenceable. Thus the end() iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos . If called on a primitive type other than null , the resulting JSON value will be null . Remove an element range specified by [first; last) from a JSON value. The iterator first does not need to be dereferenceable if first == last : erasing an empty range is a no-op. If called on a primitive type other than null , the resulting JSON value will be null . Removes an element from a JSON object by key. Removes an element from a JSON array by index. Parameters \u00b6 pos (in) iterator to the element to remove first (in) iterator to the beginning of the range to remove last (in) iterator past the end of the range to remove key (in) object key of the elements to remove idx (in) array index of the element to remove Return value \u00b6 Iterator following the last removed element. If the iterator pos refers to the last element, the end() iterator is returned. Iterator following the last removed element. If the iterator last refers to the last element, the end() iterator is returned. Number of elements removed. If ObjectType is the default std::map type, the return value will always be 0 ( key was not found) or 1 ( key was found). / Exceptions \u00b6 The function can throw the following exceptions: Throws type_error.307 if called on a null value; example: \"cannot use erase() with null\" Throws invalid_iterator.202 if called on an iterator which does not belong to the current JSON value; example: \"iterator does not fit current value\" Throws invalid_iterator.205 if called on a primitive type with invalid iterator (i.e., any iterator which is not begin() ); example: \"iterator out of range\" The function can throw thw following exceptions: Throws type_error.307 if called on a null value; example: \"cannot use erase() with null\" Throws invalid_iterator.203 if called on iterators which does not belong to the current JSON value; example: \"iterators do not fit current value\" Throws invalid_iterator.204 if called on a primitive type with invalid iterators (i.e., if first != begin() and last != end() ); example: \"iterators out of range\" The function can throw thw following exceptions: Throws type_error.307 when called on a type other than JSON object; example: \"cannot use erase() with null\" The function can throw thw following exceptions: Throws type_error.307 when called on a type other than JSON object; example: \"cannot use erase() with null\" Throws out_of_range.401 when idx >= size() ; example: \"array index 17 is out of range\" Exception safety \u00b6 Strong exception safety: if an exception occurs, the original value stays intact. Complexity \u00b6 The complexity depends on the type: objects: amortized constant arrays: linear in distance between pos and the end of the container strings and binary: linear in the length of the member other types: constant The complexity depends on the type: objects: log(size()) + std::distance(first, last) arrays: linear in the distance between first and last , plus linear in the distance between last and end of the container strings and binary: linear in the length of the member other types: constant log(size()) + count(key) Linear in distance between idx and the end of the container. Notes \u00b6 Invalidates iterators and references at or after the point of the erase, including the end() iterator. / References and iterators to the erased elements are invalidated. Other references and iterators are not affected. / Example \u00b6 Example The example shows the effect of erase() for different JSON types using an iterator. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; // call erase() j_boolean . erase ( j_boolean . begin ()); j_number_integer . erase ( j_number_integer . begin ()); j_number_float . erase ( j_number_float . begin ()); j_object . erase ( j_object . find ( \"two\" )); j_array . erase ( j_array . begin () + 2 ); j_string . erase ( j_string . begin ()); // print values std :: cout << j_boolean << '\\n' ; std :: cout << j_number_integer << '\\n' ; std :: cout << j_number_float << '\\n' ; std :: cout << j_object << '\\n' ; std :: cout << j_array << '\\n' ; std :: cout << j_string << '\\n' ; } Output: null null null { \"one\" : 1 } [ 1 , 2 , 8 , 16 ] null Example The example shows the effect of erase() for different JSON types using an iterator range. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; // call erase() j_boolean . erase ( j_boolean . begin (), j_boolean . end ()); j_number_integer . erase ( j_number_integer . begin (), j_number_integer . end ()); j_number_float . erase ( j_number_float . begin (), j_number_float . end ()); j_object . erase ( j_object . find ( \"two\" ), j_object . end ()); j_array . erase ( j_array . begin () + 1 , j_array . begin () + 3 ); j_string . erase ( j_string . begin (), j_string . end ()); // print values std :: cout << j_boolean << '\\n' ; std :: cout << j_number_integer << '\\n' ; std :: cout << j_number_float << '\\n' ; std :: cout << j_object << '\\n' ; std :: cout << j_array << '\\n' ; std :: cout << j_string << '\\n' ; } Output: null null null { \"one\" : 1 } [ 1 , 8 , 16 ] null Example The example shows the effect of erase() for different JSON types using an object key. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON object json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; // call erase() auto count_one = j_object . erase ( \"one\" ); auto count_three = j_object . erase ( \"three\" ); // print values std :: cout << j_object << '\\n' ; std :: cout << count_one << \" \" << count_three << '\\n' ; } Output: { \"two\" : 2 } 1 0 Example The example shows the effect of erase() using an array index. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON array json j_array = { 0 , 1 , 2 , 3 , 4 , 5 }; // call erase() j_array . erase ( 2 ); // print values std :: cout << j_array << '\\n' ; } Output: [ 0 , 1 , 3 , 4 , 5 ] Version history \u00b6 Added in version 1.0.0. Added support for binary types in version 3.8.0.","title":"basic_json::erase"},{"location":"api/basic_json/erase/#basic_jsonerase","text":"// (1) iterator erase ( iterator pos ); const_iterator erase ( const_iterator pos ); // (2) iterator erase ( iterator first , iterator last ); const_iterator erase ( const_iterator first , const_iterator last ); // (3) size_type erase ( const typename object_t :: key_type & key ); // (4) void erase ( const size_type idx ); Removes an element from a JSON value specified by iterator pos . The iterator pos must be valid and dereferenceable. Thus the end() iterator (which is valid, but is not dereferenceable) cannot be used as a value for pos . If called on a primitive type other than null , the resulting JSON value will be null . Remove an element range specified by [first; last) from a JSON value. The iterator first does not need to be dereferenceable if first == last : erasing an empty range is a no-op. If called on a primitive type other than null , the resulting JSON value will be null . Removes an element from a JSON object by key. Removes an element from a JSON array by index.","title":"basic_json::erase"},{"location":"api/basic_json/erase/#parameters","text":"pos (in) iterator to the element to remove first (in) iterator to the beginning of the range to remove last (in) iterator past the end of the range to remove key (in) object key of the elements to remove idx (in) array index of the element to remove","title":"Parameters"},{"location":"api/basic_json/erase/#return-value","text":"Iterator following the last removed element. If the iterator pos refers to the last element, the end() iterator is returned. Iterator following the last removed element. If the iterator last refers to the last element, the end() iterator is returned. Number of elements removed. If ObjectType is the default std::map type, the return value will always be 0 ( key was not found) or 1 ( key was found). /","title":"Return value"},{"location":"api/basic_json/erase/#exceptions","text":"The function can throw the following exceptions: Throws type_error.307 if called on a null value; example: \"cannot use erase() with null\" Throws invalid_iterator.202 if called on an iterator which does not belong to the current JSON value; example: \"iterator does not fit current value\" Throws invalid_iterator.205 if called on a primitive type with invalid iterator (i.e., any iterator which is not begin() ); example: \"iterator out of range\" The function can throw thw following exceptions: Throws type_error.307 if called on a null value; example: \"cannot use erase() with null\" Throws invalid_iterator.203 if called on iterators which does not belong to the current JSON value; example: \"iterators do not fit current value\" Throws invalid_iterator.204 if called on a primitive type with invalid iterators (i.e., if first != begin() and last != end() ); example: \"iterators out of range\" The function can throw thw following exceptions: Throws type_error.307 when called on a type other than JSON object; example: \"cannot use erase() with null\" The function can throw thw following exceptions: Throws type_error.307 when called on a type other than JSON object; example: \"cannot use erase() with null\" Throws out_of_range.401 when idx >= size() ; example: \"array index 17 is out of range\"","title":"Exceptions"},{"location":"api/basic_json/erase/#exception-safety","text":"Strong exception safety: if an exception occurs, the original value stays intact.","title":"Exception safety"},{"location":"api/basic_json/erase/#complexity","text":"The complexity depends on the type: objects: amortized constant arrays: linear in distance between pos and the end of the container strings and binary: linear in the length of the member other types: constant The complexity depends on the type: objects: log(size()) + std::distance(first, last) arrays: linear in the distance between first and last , plus linear in the distance between last and end of the container strings and binary: linear in the length of the member other types: constant log(size()) + count(key) Linear in distance between idx and the end of the container.","title":"Complexity"},{"location":"api/basic_json/erase/#notes","text":"Invalidates iterators and references at or after the point of the erase, including the end() iterator. / References and iterators to the erased elements are invalidated. Other references and iterators are not affected. /","title":"Notes"},{"location":"api/basic_json/erase/#example","text":"Example The example shows the effect of erase() for different JSON types using an iterator. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; // call erase() j_boolean . erase ( j_boolean . begin ()); j_number_integer . erase ( j_number_integer . begin ()); j_number_float . erase ( j_number_float . begin ()); j_object . erase ( j_object . find ( \"two\" )); j_array . erase ( j_array . begin () + 2 ); j_string . erase ( j_string . begin ()); // print values std :: cout << j_boolean << '\\n' ; std :: cout << j_number_integer << '\\n' ; std :: cout << j_number_float << '\\n' ; std :: cout << j_object << '\\n' ; std :: cout << j_array << '\\n' ; std :: cout << j_string << '\\n' ; } Output: null null null { \"one\" : 1 } [ 1 , 2 , 8 , 16 ] null Example The example shows the effect of erase() for different JSON types using an iterator range. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; // call erase() j_boolean . erase ( j_boolean . begin (), j_boolean . end ()); j_number_integer . erase ( j_number_integer . begin (), j_number_integer . end ()); j_number_float . erase ( j_number_float . begin (), j_number_float . end ()); j_object . erase ( j_object . find ( \"two\" ), j_object . end ()); j_array . erase ( j_array . begin () + 1 , j_array . begin () + 3 ); j_string . erase ( j_string . begin (), j_string . end ()); // print values std :: cout << j_boolean << '\\n' ; std :: cout << j_number_integer << '\\n' ; std :: cout << j_number_float << '\\n' ; std :: cout << j_object << '\\n' ; std :: cout << j_array << '\\n' ; std :: cout << j_string << '\\n' ; } Output: null null null { \"one\" : 1 } [ 1 , 8 , 16 ] null Example The example shows the effect of erase() for different JSON types using an object key. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON object json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; // call erase() auto count_one = j_object . erase ( \"one\" ); auto count_three = j_object . erase ( \"three\" ); // print values std :: cout << j_object << '\\n' ; std :: cout << count_one << \" \" << count_three << '\\n' ; } Output: { \"two\" : 2 } 1 0 Example The example shows the effect of erase() using an array index. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON array json j_array = { 0 , 1 , 2 , 3 , 4 , 5 }; // call erase() j_array . erase ( 2 ); // print values std :: cout << j_array << '\\n' ; } Output: [ 0 , 1 , 3 , 4 , 5 ]","title":"Example"},{"location":"api/basic_json/erase/#version-history","text":"Added in version 1.0.0. Added support for binary types in version 3.8.0.","title":"Version history"},{"location":"api/basic_json/error_handler_t/","text":"basic_json::error_handler_t \u00b6 enum class error_handler_t { strict , replace , ignore }; This enumeration is used in the dump function to choose how to treat decoding errors while serializing a basic_json value. Three values are differentiated: strict throw a type_error exception in case of invalid UTF-8 replace replace invalid UTF-8 sequences with U+FFFD (\ufffd REPLACEMENT CHARACTER) ignore ignore invalid UTF-8 sequences; all bytes are copied to the output unchanged Version history \u00b6 Added in version 3.4.0.","title":"basic_json::error_handler_t"},{"location":"api/basic_json/error_handler_t/#basic_jsonerror_handler_t","text":"enum class error_handler_t { strict , replace , ignore }; This enumeration is used in the dump function to choose how to treat decoding errors while serializing a basic_json value. Three values are differentiated: strict throw a type_error exception in case of invalid UTF-8 replace replace invalid UTF-8 sequences with U+FFFD (\ufffd REPLACEMENT CHARACTER) ignore ignore invalid UTF-8 sequences; all bytes are copied to the output unchanged","title":"basic_json::error_handler_t"},{"location":"api/basic_json/error_handler_t/#version-history","text":"Added in version 3.4.0.","title":"Version history"},{"location":"api/basic_json/find/","text":"basic_json::find \u00b6 template < typename KeyT > iterator find ( KeyT && key ); template < typename KeyT > const_iterator find ( KeyT && key ) const Finds an element in a JSON object with key equivalent to key . If the element is not found or the JSON value is not an object, end() is returned. Template parameters \u00b6 KeyT A type for an object key. Parameters \u00b6 key (in) key value of the element to search for. Return value \u00b6 Iterator to an element with key equivalent to key . If no such element is found or the JSON value is not an object, past-the-end (see end() ) iterator is returned. Exception safety \u00b6 Strong exception safety: if an exception occurs, the original value stays intact. Complexity \u00b6 Logarithmic in the size of the JSON object. Notes \u00b6 This method always returns end() when executed on a JSON type that is not an object. Example \u00b6 Example The example shows how find() is used. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON object json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; // call find auto it_two = j_object . find ( \"two\" ); auto it_three = j_object . find ( \"three\" ); // print values std :: cout << std :: boolalpha ; std :: cout << \" \\\" two \\\" was found: \" << ( it_two != j_object . end ()) << '\\n' ; std :: cout << \"value at key \\\" two \\\" : \" << * it_two << '\\n' ; std :: cout << \" \\\" three \\\" was found: \" << ( it_three != j_object . end ()) << '\\n' ; } Output: \"two\" was found: true value at key \"two\" : 2 \"three\" was found: false Version history \u00b6 Added in version 1.0.0.","title":"basic_json::find"},{"location":"api/basic_json/find/#basic_jsonfind","text":"template < typename KeyT > iterator find ( KeyT && key ); template < typename KeyT > const_iterator find ( KeyT && key ) const Finds an element in a JSON object with key equivalent to key . If the element is not found or the JSON value is not an object, end() is returned.","title":"basic_json::find"},{"location":"api/basic_json/find/#template-parameters","text":"KeyT A type for an object key.","title":"Template parameters"},{"location":"api/basic_json/find/#parameters","text":"key (in) key value of the element to search for.","title":"Parameters"},{"location":"api/basic_json/find/#return-value","text":"Iterator to an element with key equivalent to key . If no such element is found or the JSON value is not an object, past-the-end (see end() ) iterator is returned.","title":"Return value"},{"location":"api/basic_json/find/#exception-safety","text":"Strong exception safety: if an exception occurs, the original value stays intact.","title":"Exception safety"},{"location":"api/basic_json/find/#complexity","text":"Logarithmic in the size of the JSON object.","title":"Complexity"},{"location":"api/basic_json/find/#notes","text":"This method always returns end() when executed on a JSON type that is not an object.","title":"Notes"},{"location":"api/basic_json/find/#example","text":"Example The example shows how find() is used. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON object json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; // call find auto it_two = j_object . find ( \"two\" ); auto it_three = j_object . find ( \"three\" ); // print values std :: cout << std :: boolalpha ; std :: cout << \" \\\" two \\\" was found: \" << ( it_two != j_object . end ()) << '\\n' ; std :: cout << \"value at key \\\" two \\\" : \" << * it_two << '\\n' ; std :: cout << \" \\\" three \\\" was found: \" << ( it_three != j_object . end ()) << '\\n' ; } Output: \"two\" was found: true value at key \"two\" : 2 \"three\" was found: false","title":"Example"},{"location":"api/basic_json/find/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/flatten/","text":"basic_json::flatten \u00b6 basic_json flatten () const ; The function creates a JSON object whose keys are JSON pointers (see RFC 6901 ) and whose values are all primitive (see is_primitive() for more information). The original JSON value can be restored using the unflatten() function. Return value \u00b6 an object that maps JSON pointers to primitive values Exception safety \u00b6 Strong exception safety: if an exception occurs, the original value stays intact. Complexity \u00b6 Linear in the size the JSON value. Notes \u00b6 Empty objects and arrays are flattened to null and will not be reconstructed correctly by the unflatten() function. Example \u00b6 Example The following code shows how a JSON object is flattened to an object whose keys consist of JSON pointers. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON value json j = { { \"pi\" , 3.141 }, { \"happy\" , true }, { \"name\" , \"Niels\" }, { \"nothing\" , nullptr }, { \"answer\" , { { \"everything\" , 42 } } }, { \"list\" , { 1 , 0 , 2 }}, { \"object\" , { { \"currency\" , \"USD\" }, { \"value\" , 42.99 } } } }; // call flatten() std :: cout << std :: setw ( 4 ) << j . flatten () << '\\n' ; } Output: { \"/answer/everything\" : 42 , \"/happy\" : true , \"/list/0\" : 1 , \"/list/1\" : 0 , \"/list/2\" : 2 , \"/name\" : \"Niels\" , \"/nothing\" : null , \"/object/currency\" : \"USD\" , \"/object/value\" : 42.99 , \"/pi\" : 3.141 } Version history \u00b6 Added in version 2.0.0.","title":"basic_json::flatten"},{"location":"api/basic_json/flatten/#basic_jsonflatten","text":"basic_json flatten () const ; The function creates a JSON object whose keys are JSON pointers (see RFC 6901 ) and whose values are all primitive (see is_primitive() for more information). The original JSON value can be restored using the unflatten() function.","title":"basic_json::flatten"},{"location":"api/basic_json/flatten/#return-value","text":"an object that maps JSON pointers to primitive values","title":"Return value"},{"location":"api/basic_json/flatten/#exception-safety","text":"Strong exception safety: if an exception occurs, the original value stays intact.","title":"Exception safety"},{"location":"api/basic_json/flatten/#complexity","text":"Linear in the size the JSON value.","title":"Complexity"},{"location":"api/basic_json/flatten/#notes","text":"Empty objects and arrays are flattened to null and will not be reconstructed correctly by the unflatten() function.","title":"Notes"},{"location":"api/basic_json/flatten/#example","text":"Example The following code shows how a JSON object is flattened to an object whose keys consist of JSON pointers. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON value json j = { { \"pi\" , 3.141 }, { \"happy\" , true }, { \"name\" , \"Niels\" }, { \"nothing\" , nullptr }, { \"answer\" , { { \"everything\" , 42 } } }, { \"list\" , { 1 , 0 , 2 }}, { \"object\" , { { \"currency\" , \"USD\" }, { \"value\" , 42.99 } } } }; // call flatten() std :: cout << std :: setw ( 4 ) << j . flatten () << '\\n' ; } Output: { \"/answer/everything\" : 42 , \"/happy\" : true , \"/list/0\" : 1 , \"/list/1\" : 0 , \"/list/2\" : 2 , \"/name\" : \"Niels\" , \"/nothing\" : null , \"/object/currency\" : \"USD\" , \"/object/value\" : 42.99 , \"/pi\" : 3.141 }","title":"Example"},{"location":"api/basic_json/flatten/#version-history","text":"Added in version 2.0.0.","title":"Version history"},{"location":"api/basic_json/from_bson/","text":"basic_json::from_bson \u00b6 // (1) template < typename InputType > static basic_json from_bson ( InputType && i , const bool strict = true , const bool allow_exceptions = true ); // (2) template < typename IteratorType > static basic_json from_bson ( IteratorType first , IteratorType last , const bool strict = true , const bool allow_exceptions = true ); Deserializes a given input to a JSON value using the BSON (Binary JSON) serialization format. Reads from a compatible input. Reads from an iterator range. Template parameters \u00b6 InputType A compatible input, for instance: an std::istream object a FILE pointer a C-style array of characters a pointer to a null-terminated string of single byte characters an object obj for which begin(obj) and end(obj) produces a valid pair of iterators. IteratorType a compatible iterator type Parameters \u00b6 i (in) an input in BSON format convertible to an input adapter first (in) iterator to start of the input last (in) iterator to end of the input strict (in) whether to expect the input to be consumed until EOF ( true by default) allow_exceptions (in) whether to throw exceptions in case of a parse error (optional, true by default) Return value \u00b6 deserialized JSON value; in case of a parse error and allow_exceptions set to false , the return value will be value_t::discarded . Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Linear in the size of the input. Example \u00b6 Example The example shows the deserialization of a byte vector in BSON format to a JSON value. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x1b , 0x00 , 0x00 , 0x00 , 0x08 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0x00 , 0x01 , 0x10 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 }; // deserialize it with BSON json j = json :: from_bson ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 } Version history \u00b6 Added in version 3.4.0.","title":"basic_json::from_bson"},{"location":"api/basic_json/from_bson/#basic_jsonfrom_bson","text":"// (1) template < typename InputType > static basic_json from_bson ( InputType && i , const bool strict = true , const bool allow_exceptions = true ); // (2) template < typename IteratorType > static basic_json from_bson ( IteratorType first , IteratorType last , const bool strict = true , const bool allow_exceptions = true ); Deserializes a given input to a JSON value using the BSON (Binary JSON) serialization format. Reads from a compatible input. Reads from an iterator range.","title":"basic_json::from_bson"},{"location":"api/basic_json/from_bson/#template-parameters","text":"InputType A compatible input, for instance: an std::istream object a FILE pointer a C-style array of characters a pointer to a null-terminated string of single byte characters an object obj for which begin(obj) and end(obj) produces a valid pair of iterators. IteratorType a compatible iterator type","title":"Template parameters"},{"location":"api/basic_json/from_bson/#parameters","text":"i (in) an input in BSON format convertible to an input adapter first (in) iterator to start of the input last (in) iterator to end of the input strict (in) whether to expect the input to be consumed until EOF ( true by default) allow_exceptions (in) whether to throw exceptions in case of a parse error (optional, true by default)","title":"Parameters"},{"location":"api/basic_json/from_bson/#return-value","text":"deserialized JSON value; in case of a parse error and allow_exceptions set to false , the return value will be value_t::discarded .","title":"Return value"},{"location":"api/basic_json/from_bson/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/from_bson/#complexity","text":"Linear in the size of the input.","title":"Complexity"},{"location":"api/basic_json/from_bson/#example","text":"Example The example shows the deserialization of a byte vector in BSON format to a JSON value. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x1b , 0x00 , 0x00 , 0x00 , 0x08 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0x00 , 0x01 , 0x10 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 }; // deserialize it with BSON json j = json :: from_bson ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"Example"},{"location":"api/basic_json/from_bson/#version-history","text":"Added in version 3.4.0.","title":"Version history"},{"location":"api/basic_json/from_cbor/","text":"basic_json::from_cbor \u00b6 // (1) template < typename InputType > static basic_json from_cbor ( InputType && i , const bool strict = true , const bool allow_exceptions = true , const cbor_tag_handler_t tag_handler = cbor_tag_handler_t :: error ); // (2) template < typename IteratorType > static basic_json from_cbor ( IteratorType first , IteratorType last , const bool strict = true , const bool allow_exceptions = true , const cbor_tag_handler_t tag_handler = cbor_tag_handler_t :: error ); Deserializes a given input to a JSON value using the CBOR (Concise Binary Object Representation) serialization format. Reads from a compatible input. Reads from an iterator range. Template parameters \u00b6 InputType A compatible input, for instance: an std::istream object a FILE pointer a C-style array of characters a pointer to a null-terminated string of single byte characters an object obj for which begin(obj) and end(obj) produces a valid pair of iterators. IteratorType a compatible iterator type Parameters \u00b6 i (in) an input in CBOR format convertible to an input adapter first (in) iterator to start of the input last (in) iterator to end of the input strict (in) whether to expect the input to be consumed until EOF ( true by default) allow_exceptions (in) whether to throw exceptions in case of a parse error (optional, true by default) tag_handler (in) how to treat CBOR tags (optional, error by default) Return value \u00b6 deserialized JSON value; in case of a parse error and allow_exceptions set to false , the return value will be value_t::discarded . Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Linear in the size of the input. Example \u00b6 Example The example shows the deserialization of a byte vector in CBOR format to a JSON value. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0xa2 , 0x67 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0xf5 , 0x66 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 }; // deserialize it with CBOR json j = json :: from_cbor ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 } Version history \u00b6 Added in version 2.0.9. Parameter start_index since version 2.1.1. Changed to consume input adapters, removed start_index parameter, and added strict parameter in version 3.0.0. Added allow_exceptions parameter in version 3.2.0. Added tag_handler parameter in version 3.9.0.","title":"basic_json::from_cbor"},{"location":"api/basic_json/from_cbor/#basic_jsonfrom_cbor","text":"// (1) template < typename InputType > static basic_json from_cbor ( InputType && i , const bool strict = true , const bool allow_exceptions = true , const cbor_tag_handler_t tag_handler = cbor_tag_handler_t :: error ); // (2) template < typename IteratorType > static basic_json from_cbor ( IteratorType first , IteratorType last , const bool strict = true , const bool allow_exceptions = true , const cbor_tag_handler_t tag_handler = cbor_tag_handler_t :: error ); Deserializes a given input to a JSON value using the CBOR (Concise Binary Object Representation) serialization format. Reads from a compatible input. Reads from an iterator range.","title":"basic_json::from_cbor"},{"location":"api/basic_json/from_cbor/#template-parameters","text":"InputType A compatible input, for instance: an std::istream object a FILE pointer a C-style array of characters a pointer to a null-terminated string of single byte characters an object obj for which begin(obj) and end(obj) produces a valid pair of iterators. IteratorType a compatible iterator type","title":"Template parameters"},{"location":"api/basic_json/from_cbor/#parameters","text":"i (in) an input in CBOR format convertible to an input adapter first (in) iterator to start of the input last (in) iterator to end of the input strict (in) whether to expect the input to be consumed until EOF ( true by default) allow_exceptions (in) whether to throw exceptions in case of a parse error (optional, true by default) tag_handler (in) how to treat CBOR tags (optional, error by default)","title":"Parameters"},{"location":"api/basic_json/from_cbor/#return-value","text":"deserialized JSON value; in case of a parse error and allow_exceptions set to false , the return value will be value_t::discarded .","title":"Return value"},{"location":"api/basic_json/from_cbor/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/from_cbor/#complexity","text":"Linear in the size of the input.","title":"Complexity"},{"location":"api/basic_json/from_cbor/#example","text":"Example The example shows the deserialization of a byte vector in CBOR format to a JSON value. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0xa2 , 0x67 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0xf5 , 0x66 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 }; // deserialize it with CBOR json j = json :: from_cbor ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"Example"},{"location":"api/basic_json/from_cbor/#version-history","text":"Added in version 2.0.9. Parameter start_index since version 2.1.1. Changed to consume input adapters, removed start_index parameter, and added strict parameter in version 3.0.0. Added allow_exceptions parameter in version 3.2.0. Added tag_handler parameter in version 3.9.0.","title":"Version history"},{"location":"api/basic_json/from_msgpack/","text":"basic_json::from_msgpack \u00b6 // (1) template < typename InputType > static basic_json from_msgpack ( InputType && i , const bool strict = true , const bool allow_exceptions = true ); // (2) template < typename IteratorType > static basic_json from_msgpack ( IteratorType first , IteratorType last , const bool strict = true , const bool allow_exceptions = true ); Deserializes a given input to a JSON value using the MessagePack serialization format. Reads from a compatible input. Reads from an iterator range. Template parameters \u00b6 InputType A compatible input, for instance: an std::istream object a FILE pointer a C-style array of characters a pointer to a null-terminated string of single byte characters an object obj for which begin(obj) and end(obj) produces a valid pair of iterators. IteratorType a compatible iterator type Parameters \u00b6 i (in) an input in MessagePack format convertible to an input adapter first (in) iterator to start of the input last (in) iterator to end of the input strict (in) whether to expect the input to be consumed until EOF ( true by default) allow_exceptions (in) whether to throw exceptions in case of a parse error (optional, true by default) Return value \u00b6 deserialized JSON value; in case of a parse error and allow_exceptions set to false , the return value will be value_t::discarded . Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Linear in the size of the input. Example \u00b6 Example The example shows the deserialization of a byte vector in MessagePack format to a JSON value. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x82 , 0xa7 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0xc3 , 0xa6 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 }; // deserialize it with MessagePack json j = json :: from_msgpack ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 } Version history \u00b6 Added in version 2.0.9. Parameter start_index since version 2.1.1. Changed to consume input adapters, removed start_index parameter, and added strict parameter in version 3.0.0. Added allow_exceptions parameter in version 3.2.0.","title":"basic_json::from_msgpack"},{"location":"api/basic_json/from_msgpack/#basic_jsonfrom_msgpack","text":"// (1) template < typename InputType > static basic_json from_msgpack ( InputType && i , const bool strict = true , const bool allow_exceptions = true ); // (2) template < typename IteratorType > static basic_json from_msgpack ( IteratorType first , IteratorType last , const bool strict = true , const bool allow_exceptions = true ); Deserializes a given input to a JSON value using the MessagePack serialization format. Reads from a compatible input. Reads from an iterator range.","title":"basic_json::from_msgpack"},{"location":"api/basic_json/from_msgpack/#template-parameters","text":"InputType A compatible input, for instance: an std::istream object a FILE pointer a C-style array of characters a pointer to a null-terminated string of single byte characters an object obj for which begin(obj) and end(obj) produces a valid pair of iterators. IteratorType a compatible iterator type","title":"Template parameters"},{"location":"api/basic_json/from_msgpack/#parameters","text":"i (in) an input in MessagePack format convertible to an input adapter first (in) iterator to start of the input last (in) iterator to end of the input strict (in) whether to expect the input to be consumed until EOF ( true by default) allow_exceptions (in) whether to throw exceptions in case of a parse error (optional, true by default)","title":"Parameters"},{"location":"api/basic_json/from_msgpack/#return-value","text":"deserialized JSON value; in case of a parse error and allow_exceptions set to false , the return value will be value_t::discarded .","title":"Return value"},{"location":"api/basic_json/from_msgpack/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/from_msgpack/#complexity","text":"Linear in the size of the input.","title":"Complexity"},{"location":"api/basic_json/from_msgpack/#example","text":"Example The example shows the deserialization of a byte vector in MessagePack format to a JSON value. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x82 , 0xa7 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0xc3 , 0xa6 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 }; // deserialize it with MessagePack json j = json :: from_msgpack ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"Example"},{"location":"api/basic_json/from_msgpack/#version-history","text":"Added in version 2.0.9. Parameter start_index since version 2.1.1. Changed to consume input adapters, removed start_index parameter, and added strict parameter in version 3.0.0. Added allow_exceptions parameter in version 3.2.0.","title":"Version history"},{"location":"api/basic_json/from_ubjson/","text":"basic_json::from_ubjson \u00b6 // (1) template < typename InputType > static basic_json from_ubjson ( InputType && i , const bool strict = true , const bool allow_exceptions = true ); // (2) template < typename IteratorType > static basic_json from_ubjson ( IteratorType first , IteratorType last , const bool strict = true , const bool allow_exceptions = true ); Deserializes a given input to a JSON value using the UBJSON (Universal Binary JSON) serialization format. Reads from a compatible input. Reads from an iterator range. Template parameters \u00b6 InputType A compatible input, for instance: an std::istream object a FILE pointer a C-style array of characters a pointer to a null-terminated string of single byte characters an object obj for which begin(obj) and end(obj) produces a valid pair of iterators. IteratorType a compatible iterator type Parameters \u00b6 i (in) an input in UBJSON format convertible to an input adapter first (in) iterator to start of the input last (in) iterator to end of the input strict (in) whether to expect the input to be consumed until EOF ( true by default) allow_exceptions (in) whether to throw exceptions in case of a parse error (optional, true by default) Return value \u00b6 deserialized JSON value; in case of a parse error and allow_exceptions set to false , the return value will be value_t::discarded . Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Linear in the size of the input. Example \u00b6 Example The example shows the deserialization of a byte vector in UBJSON format to a JSON value. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x7B , 0x69 , 0x07 , 0x63 , 0x6F , 0x6D , 0x70 , 0x61 , 0x63 , 0x74 , 0x54 , 0x69 , 0x06 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6D , 0x61 , 0x69 , 0x00 , 0x7D }; // deserialize it with UBJSON json j = json :: from_ubjson ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 } Version history \u00b6 Added in version 3.1.0. Added allow_exceptions parameter in version 3.2.0.","title":"basic_json::from_ubjson"},{"location":"api/basic_json/from_ubjson/#basic_jsonfrom_ubjson","text":"// (1) template < typename InputType > static basic_json from_ubjson ( InputType && i , const bool strict = true , const bool allow_exceptions = true ); // (2) template < typename IteratorType > static basic_json from_ubjson ( IteratorType first , IteratorType last , const bool strict = true , const bool allow_exceptions = true ); Deserializes a given input to a JSON value using the UBJSON (Universal Binary JSON) serialization format. Reads from a compatible input. Reads from an iterator range.","title":"basic_json::from_ubjson"},{"location":"api/basic_json/from_ubjson/#template-parameters","text":"InputType A compatible input, for instance: an std::istream object a FILE pointer a C-style array of characters a pointer to a null-terminated string of single byte characters an object obj for which begin(obj) and end(obj) produces a valid pair of iterators. IteratorType a compatible iterator type","title":"Template parameters"},{"location":"api/basic_json/from_ubjson/#parameters","text":"i (in) an input in UBJSON format convertible to an input adapter first (in) iterator to start of the input last (in) iterator to end of the input strict (in) whether to expect the input to be consumed until EOF ( true by default) allow_exceptions (in) whether to throw exceptions in case of a parse error (optional, true by default)","title":"Parameters"},{"location":"api/basic_json/from_ubjson/#return-value","text":"deserialized JSON value; in case of a parse error and allow_exceptions set to false , the return value will be value_t::discarded .","title":"Return value"},{"location":"api/basic_json/from_ubjson/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/from_ubjson/#complexity","text":"Linear in the size of the input.","title":"Complexity"},{"location":"api/basic_json/from_ubjson/#example","text":"Example The example shows the deserialization of a byte vector in UBJSON format to a JSON value. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x7B , 0x69 , 0x07 , 0x63 , 0x6F , 0x6D , 0x70 , 0x61 , 0x63 , 0x74 , 0x54 , 0x69 , 0x06 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6D , 0x61 , 0x69 , 0x00 , 0x7D }; // deserialize it with UBJSON json j = json :: from_ubjson ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"Example"},{"location":"api/basic_json/from_ubjson/#version-history","text":"Added in version 3.1.0. Added allow_exceptions parameter in version 3.2.0.","title":"Version history"},{"location":"api/basic_json/front/","text":"basic_json::front \u00b6 reference front (); const_reference front () const ; Returns a reference to the first element in the container. For a JSON container c , the expression c . front () is equivalent to * c . begin () . Return value \u00b6 In case of a structured type (array or object), a reference to the first element is returned. In case of number, string, boolean, or binary values, a reference to the value is returned. Exceptions \u00b6 If the JSON value is null , exception invalid_iterator.214 is thrown. Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Constant. Note \u00b6 Danger Calling front on an empty array or object is undefined behavior and is guarded by an assertion ! Example \u00b6 Example The following code shows an example for front() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_object_empty ( json :: value_t :: object ); json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_array_empty ( json :: value_t :: array ); json j_string = \"Hello, world\" ; // call front() //std::cout << j_null.front() << '\\n'; // would throw std :: cout << j_boolean . front () << '\\n' ; std :: cout << j_number_integer . front () << '\\n' ; std :: cout << j_number_float . front () << '\\n' ; std :: cout << j_object . front () << '\\n' ; //std::cout << j_object_empty.front() << '\\n'; // undefined behavior std :: cout << j_array . front () << '\\n' ; //std::cout << j_array_empty.front() << '\\n'; // undefined behavior std :: cout << j_string . front () << '\\n' ; } Output: true 17 23.42 1 1 \"Hello, world\" Version history \u00b6 Added in version 1.0.0. Adjusted code to return reference to binary values in version 3.8.0.","title":"basic_json::front"},{"location":"api/basic_json/front/#basic_jsonfront","text":"reference front (); const_reference front () const ; Returns a reference to the first element in the container. For a JSON container c , the expression c . front () is equivalent to * c . begin () .","title":"basic_json::front"},{"location":"api/basic_json/front/#return-value","text":"In case of a structured type (array or object), a reference to the first element is returned. In case of number, string, boolean, or binary values, a reference to the value is returned.","title":"Return value"},{"location":"api/basic_json/front/#exceptions","text":"If the JSON value is null , exception invalid_iterator.214 is thrown.","title":"Exceptions"},{"location":"api/basic_json/front/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/front/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/front/#note","text":"Danger Calling front on an empty array or object is undefined behavior and is guarded by an assertion !","title":"Note"},{"location":"api/basic_json/front/#example","text":"Example The following code shows an example for front() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_object_empty ( json :: value_t :: object ); json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_array_empty ( json :: value_t :: array ); json j_string = \"Hello, world\" ; // call front() //std::cout << j_null.front() << '\\n'; // would throw std :: cout << j_boolean . front () << '\\n' ; std :: cout << j_number_integer . front () << '\\n' ; std :: cout << j_number_float . front () << '\\n' ; std :: cout << j_object . front () << '\\n' ; //std::cout << j_object_empty.front() << '\\n'; // undefined behavior std :: cout << j_array . front () << '\\n' ; //std::cout << j_array_empty.front() << '\\n'; // undefined behavior std :: cout << j_string . front () << '\\n' ; } Output: true 17 23.42 1 1 \"Hello, world\"","title":"Example"},{"location":"api/basic_json/front/#version-history","text":"Added in version 1.0.0. Adjusted code to return reference to binary values in version 3.8.0.","title":"Version history"},{"location":"api/basic_json/insert/","text":"basic_json::insert \u00b6 // (1) iterator insert ( const_iterator pos , const basic_json & val ); iterator insert ( const_iterator pos , basic_json && val ); // (2) iterator insert ( const_iterator pos , size_type cnt , const basic_json & val ); // (3) iterator insert ( const_iterator pos , const_iterator first , const_iterator last ); // (4) iterator insert ( const_iterator pos , initializer_list_t ilist ); // (5) void insert ( const_iterator first , const_iterator last ); Inserts element val to array before iterator pos . Inserts cnt copies of val to array before iterator pos . Inserts elements from range [first, last) to array before iterator pos . Inserts elements from initializer list ilist to array before iterator pos . Inserts elements from range [first, last) to object. Parameters \u00b6 pos (in) iterator before which the content will be inserted; may be the end() iterator val (in) value to insert cnt (in) number of copies of val to insert first (in) begin of the range of elements to insert last (in) end of the range of elements to insert ilist (in) initializer list to insert the values from Return value \u00b6 iterator pointing to the inserted val . iterator pointing to the first element inserted, or pos if cnt == 0 iterator pointing to the first element inserted, or pos if first == last iterator pointing to the first element inserted, or pos if ilist is empty / Exceptions \u00b6 The function can throw the following exceptions: Throws type_error.309 if called on JSON values other than arrays; example: \"cannot use insert() with string\" Throws invalid_iterator.202 if called on an iterator which does not belong to the current JSON value; example: \"iterator does not fit current value\" The function can throw thw following exceptions: Throws type_error.309 if called on JSON values other than arrays; example: \"cannot use insert() with string\" Throws invalid_iterator.202 if called on an iterator which does not belong to the current JSON value; example: \"iterator does not fit current value\" The function can throw thw following exceptions: Throws type_error.309 if called on JSON values other than arrays; example: \"cannot use insert() with string\" Throws invalid_iterator.202 if called on an iterator which does not belong to the current JSON value; example: \"iterator does not fit current value\" Throws invalid_iterator.210 if first and last do not belong to the same JSON value; example: \"iterators do not fit\" Throws invalid_iterator.211 if first or last are iterators into container for which insert is called; example: \"passed iterators may not belong to container\" The function can throw thw following exceptions: Throws type_error.309 if called on JSON values other than arrays; example: \"cannot use insert() with string\" Throws invalid_iterator.202 if called on an iterator which does not belong to the current JSON value; example: \"iterator does not fit current value\" The function can throw thw following exceptions: Throws type_error.309 if called on JSON values other than objects; example: \"cannot use insert() with string\" Throws invalid_iterator.202 if called on an iterator which does not belong to the current JSON value; example: \"iterator does not fit current value\" Throws invalid_iterator.210 if first and last do not belong to the same JSON value; example: \"iterators do not fit\" Exception safety \u00b6 Strong exception safety: if an exception occurs, the original value stays intact. Complexity \u00b6 Constant plus linear in the distance between pos and end of the container. Linear in cnt plus linear in the distance between pos and end of the container. Linear in std :: distance ( first , last ) plus linear in the distance between pos and end of the container. Linear in ilist.size() plus linear in the distance between pos and end of the container. Logarithmic: O(N*log(size() + N)) , where N is the number of elements to insert. Example \u00b6 Example The example shows how insert() is used. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON array json v = { 1 , 2 , 3 , 4 }; // insert number 10 before number 3 auto new_pos = v . insert ( v . begin () + 2 , 10 ); // output new array and result of insert call std :: cout << * new_pos << '\\n' ; std :: cout << v << '\\n' ; } Output: 10 [ 1 , 2 , 10 , 3 , 4 ] Example The example shows how insert() is used. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON array json v = { 1 , 2 , 3 , 4 }; // insert number 7 copies of number 7 before number 3 auto new_pos = v . insert ( v . begin () + 2 , 7 , 7 ); // output new array and result of insert call std :: cout << * new_pos << '\\n' ; std :: cout << v << '\\n' ; } Output: 7 [ 1 , 2 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 3 , 4 ] Example The example shows how insert() is used. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON array json v = { 1 , 2 , 3 , 4 }; // create a JSON array to copy values from json v2 = { \"one\" , \"two\" , \"three\" , \"four\" }; // insert range from v2 before the end of array v auto new_pos = v . insert ( v . end (), v2 . begin (), v2 . end ()); // output new array and result of insert call std :: cout << * new_pos << '\\n' ; std :: cout << v << '\\n' ; } Output: \"one\" [ 1 , 2 , 3 , 4 , \"one\" , \"two\" , \"three\" , \"four\" ] Example The example shows how insert() is used. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON array json v = { 1 , 2 , 3 , 4 }; // insert range from v2 before the end of array v auto new_pos = v . insert ( v . end (), { 7 , 8 , 9 }); // output new array and result of insert call std :: cout << * new_pos << '\\n' ; std :: cout << v << '\\n' ; } Output: 7 [ 1 , 2 , 3 , 4 , 7 , 8 , 9 ] Example The example shows how insert() is used. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create two JSON objects json j1 = {{ \"one\" , \"eins\" }, { \"two\" , \"zwei\" }}; json j2 = {{ \"eleven\" , \"elf\" }, { \"seventeen\" , \"siebzehn\" }}; // output objects std :: cout << j1 << '\\n' ; std :: cout << j2 << '\\n' ; // insert range from j2 to j1 j1 . insert ( j2 . begin (), j2 . end ()); // output result of insert call std :: cout << j1 << '\\n' ; } Output: { \"one\" : \"eins\" , \"two\" : \"zwei\" } { \"eleven\" : \"elf\" , \"seventeen\" : \"siebzehn\" } { \"eleven\" : \"elf\" , \"one\" : \"eins\" , \"seventeen\" : \"siebzehn\" , \"two\" : \"zwei\" } Version history \u00b6 Added in version 1.0.0. Added in version 1.0.0. Added in version 1.0.0. Added in version 1.0.0. Added in version 3.0.0.","title":"basic_json::insert"},{"location":"api/basic_json/insert/#basic_jsoninsert","text":"// (1) iterator insert ( const_iterator pos , const basic_json & val ); iterator insert ( const_iterator pos , basic_json && val ); // (2) iterator insert ( const_iterator pos , size_type cnt , const basic_json & val ); // (3) iterator insert ( const_iterator pos , const_iterator first , const_iterator last ); // (4) iterator insert ( const_iterator pos , initializer_list_t ilist ); // (5) void insert ( const_iterator first , const_iterator last ); Inserts element val to array before iterator pos . Inserts cnt copies of val to array before iterator pos . Inserts elements from range [first, last) to array before iterator pos . Inserts elements from initializer list ilist to array before iterator pos . Inserts elements from range [first, last) to object.","title":"basic_json::insert"},{"location":"api/basic_json/insert/#parameters","text":"pos (in) iterator before which the content will be inserted; may be the end() iterator val (in) value to insert cnt (in) number of copies of val to insert first (in) begin of the range of elements to insert last (in) end of the range of elements to insert ilist (in) initializer list to insert the values from","title":"Parameters"},{"location":"api/basic_json/insert/#return-value","text":"iterator pointing to the inserted val . iterator pointing to the first element inserted, or pos if cnt == 0 iterator pointing to the first element inserted, or pos if first == last iterator pointing to the first element inserted, or pos if ilist is empty /","title":"Return value"},{"location":"api/basic_json/insert/#exceptions","text":"The function can throw the following exceptions: Throws type_error.309 if called on JSON values other than arrays; example: \"cannot use insert() with string\" Throws invalid_iterator.202 if called on an iterator which does not belong to the current JSON value; example: \"iterator does not fit current value\" The function can throw thw following exceptions: Throws type_error.309 if called on JSON values other than arrays; example: \"cannot use insert() with string\" Throws invalid_iterator.202 if called on an iterator which does not belong to the current JSON value; example: \"iterator does not fit current value\" The function can throw thw following exceptions: Throws type_error.309 if called on JSON values other than arrays; example: \"cannot use insert() with string\" Throws invalid_iterator.202 if called on an iterator which does not belong to the current JSON value; example: \"iterator does not fit current value\" Throws invalid_iterator.210 if first and last do not belong to the same JSON value; example: \"iterators do not fit\" Throws invalid_iterator.211 if first or last are iterators into container for which insert is called; example: \"passed iterators may not belong to container\" The function can throw thw following exceptions: Throws type_error.309 if called on JSON values other than arrays; example: \"cannot use insert() with string\" Throws invalid_iterator.202 if called on an iterator which does not belong to the current JSON value; example: \"iterator does not fit current value\" The function can throw thw following exceptions: Throws type_error.309 if called on JSON values other than objects; example: \"cannot use insert() with string\" Throws invalid_iterator.202 if called on an iterator which does not belong to the current JSON value; example: \"iterator does not fit current value\" Throws invalid_iterator.210 if first and last do not belong to the same JSON value; example: \"iterators do not fit\"","title":"Exceptions"},{"location":"api/basic_json/insert/#exception-safety","text":"Strong exception safety: if an exception occurs, the original value stays intact.","title":"Exception safety"},{"location":"api/basic_json/insert/#complexity","text":"Constant plus linear in the distance between pos and end of the container. Linear in cnt plus linear in the distance between pos and end of the container. Linear in std :: distance ( first , last ) plus linear in the distance between pos and end of the container. Linear in ilist.size() plus linear in the distance between pos and end of the container. Logarithmic: O(N*log(size() + N)) , where N is the number of elements to insert.","title":"Complexity"},{"location":"api/basic_json/insert/#example","text":"Example The example shows how insert() is used. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON array json v = { 1 , 2 , 3 , 4 }; // insert number 10 before number 3 auto new_pos = v . insert ( v . begin () + 2 , 10 ); // output new array and result of insert call std :: cout << * new_pos << '\\n' ; std :: cout << v << '\\n' ; } Output: 10 [ 1 , 2 , 10 , 3 , 4 ] Example The example shows how insert() is used. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON array json v = { 1 , 2 , 3 , 4 }; // insert number 7 copies of number 7 before number 3 auto new_pos = v . insert ( v . begin () + 2 , 7 , 7 ); // output new array and result of insert call std :: cout << * new_pos << '\\n' ; std :: cout << v << '\\n' ; } Output: 7 [ 1 , 2 , 7 , 7 , 7 , 7 , 7 , 7 , 7 , 3 , 4 ] Example The example shows how insert() is used. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON array json v = { 1 , 2 , 3 , 4 }; // create a JSON array to copy values from json v2 = { \"one\" , \"two\" , \"three\" , \"four\" }; // insert range from v2 before the end of array v auto new_pos = v . insert ( v . end (), v2 . begin (), v2 . end ()); // output new array and result of insert call std :: cout << * new_pos << '\\n' ; std :: cout << v << '\\n' ; } Output: \"one\" [ 1 , 2 , 3 , 4 , \"one\" , \"two\" , \"three\" , \"four\" ] Example The example shows how insert() is used. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON array json v = { 1 , 2 , 3 , 4 }; // insert range from v2 before the end of array v auto new_pos = v . insert ( v . end (), { 7 , 8 , 9 }); // output new array and result of insert call std :: cout << * new_pos << '\\n' ; std :: cout << v << '\\n' ; } Output: 7 [ 1 , 2 , 3 , 4 , 7 , 8 , 9 ] Example The example shows how insert() is used. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create two JSON objects json j1 = {{ \"one\" , \"eins\" }, { \"two\" , \"zwei\" }}; json j2 = {{ \"eleven\" , \"elf\" }, { \"seventeen\" , \"siebzehn\" }}; // output objects std :: cout << j1 << '\\n' ; std :: cout << j2 << '\\n' ; // insert range from j2 to j1 j1 . insert ( j2 . begin (), j2 . end ()); // output result of insert call std :: cout << j1 << '\\n' ; } Output: { \"one\" : \"eins\" , \"two\" : \"zwei\" } { \"eleven\" : \"elf\" , \"seventeen\" : \"siebzehn\" } { \"eleven\" : \"elf\" , \"one\" : \"eins\" , \"seventeen\" : \"siebzehn\" , \"two\" : \"zwei\" }","title":"Example"},{"location":"api/basic_json/insert/#version-history","text":"Added in version 1.0.0. Added in version 1.0.0. Added in version 1.0.0. Added in version 1.0.0. Added in version 3.0.0.","title":"Version history"},{"location":"api/basic_json/is_array/","text":"basic_json::is_array \u00b6 constexpr bool is_array () const noexcept ; This function returns true if and only if the JSON value is an array. Return value \u00b6 true if type is an array, false otherwise. Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code exemplifies is_array() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_array() std :: cout << std :: boolalpha ; std :: cout << j_null . is_array () << '\\n' ; std :: cout << j_boolean . is_array () << '\\n' ; std :: cout << j_number_integer . is_array () << '\\n' ; std :: cout << j_number_unsigned_integer . is_array () << '\\n' ; std :: cout << j_number_float . is_array () << '\\n' ; std :: cout << j_object . is_array () << '\\n' ; std :: cout << j_array . is_array () << '\\n' ; std :: cout << j_string . is_array () << '\\n' ; std :: cout << j_binary . is_array () << '\\n' ; } Output: false false false false false false true false false Version history \u00b6 Added in version 1.0.0.","title":"basic_json::is_array"},{"location":"api/basic_json/is_array/#basic_jsonis_array","text":"constexpr bool is_array () const noexcept ; This function returns true if and only if the JSON value is an array.","title":"basic_json::is_array"},{"location":"api/basic_json/is_array/#return-value","text":"true if type is an array, false otherwise.","title":"Return value"},{"location":"api/basic_json/is_array/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/is_array/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/is_array/#example","text":"Example The following code exemplifies is_array() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_array() std :: cout << std :: boolalpha ; std :: cout << j_null . is_array () << '\\n' ; std :: cout << j_boolean . is_array () << '\\n' ; std :: cout << j_number_integer . is_array () << '\\n' ; std :: cout << j_number_unsigned_integer . is_array () << '\\n' ; std :: cout << j_number_float . is_array () << '\\n' ; std :: cout << j_object . is_array () << '\\n' ; std :: cout << j_array . is_array () << '\\n' ; std :: cout << j_string . is_array () << '\\n' ; std :: cout << j_binary . is_array () << '\\n' ; } Output: false false false false false false true false false","title":"Example"},{"location":"api/basic_json/is_array/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/is_binary/","text":"basic_json::is_binary \u00b6 constexpr bool is_binary () const noexcept ; This function returns true if and only if the JSON value is binary array. Return value \u00b6 true if type is binary, false otherwise. Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code exemplifies is_binary() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_binary() std :: cout << std :: boolalpha ; std :: cout << j_null . is_binary () << '\\n' ; std :: cout << j_boolean . is_binary () << '\\n' ; std :: cout << j_number_integer . is_binary () << '\\n' ; std :: cout << j_number_unsigned_integer . is_binary () << '\\n' ; std :: cout << j_number_float . is_binary () << '\\n' ; std :: cout << j_object . is_binary () << '\\n' ; std :: cout << j_array . is_binary () << '\\n' ; std :: cout << j_string . is_binary () << '\\n' ; std :: cout << j_binary . is_binary () << '\\n' ; } Output: false false false false false false false false true Version history \u00b6 Added in version 3.8.0.","title":"basic_json::is_binary"},{"location":"api/basic_json/is_binary/#basic_jsonis_binary","text":"constexpr bool is_binary () const noexcept ; This function returns true if and only if the JSON value is binary array.","title":"basic_json::is_binary"},{"location":"api/basic_json/is_binary/#return-value","text":"true if type is binary, false otherwise.","title":"Return value"},{"location":"api/basic_json/is_binary/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/is_binary/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/is_binary/#example","text":"Example The following code exemplifies is_binary() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_binary() std :: cout << std :: boolalpha ; std :: cout << j_null . is_binary () << '\\n' ; std :: cout << j_boolean . is_binary () << '\\n' ; std :: cout << j_number_integer . is_binary () << '\\n' ; std :: cout << j_number_unsigned_integer . is_binary () << '\\n' ; std :: cout << j_number_float . is_binary () << '\\n' ; std :: cout << j_object . is_binary () << '\\n' ; std :: cout << j_array . is_binary () << '\\n' ; std :: cout << j_string . is_binary () << '\\n' ; std :: cout << j_binary . is_binary () << '\\n' ; } Output: false false false false false false false false true","title":"Example"},{"location":"api/basic_json/is_binary/#version-history","text":"Added in version 3.8.0.","title":"Version history"},{"location":"api/basic_json/is_boolean/","text":"basic_json::is_boolean \u00b6 constexpr bool is_boolean () const noexcept ; This function returns true if and only if the JSON value is true or false . Return value \u00b6 true if type is boolean, false otherwise. Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code exemplifies is_boolean() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_boolean() std :: cout << std :: boolalpha ; std :: cout << j_null . is_boolean () << '\\n' ; std :: cout << j_boolean . is_boolean () << '\\n' ; std :: cout << j_number_integer . is_boolean () << '\\n' ; std :: cout << j_number_unsigned_integer . is_boolean () << '\\n' ; std :: cout << j_number_float . is_boolean () << '\\n' ; std :: cout << j_object . is_boolean () << '\\n' ; std :: cout << j_array . is_boolean () << '\\n' ; std :: cout << j_string . is_boolean () << '\\n' ; std :: cout << j_binary . is_boolean () << '\\n' ; } Output: false true false false false false false false false Version history \u00b6 Added in version 1.0.0.","title":"basic_json::is_boolean"},{"location":"api/basic_json/is_boolean/#basic_jsonis_boolean","text":"constexpr bool is_boolean () const noexcept ; This function returns true if and only if the JSON value is true or false .","title":"basic_json::is_boolean"},{"location":"api/basic_json/is_boolean/#return-value","text":"true if type is boolean, false otherwise.","title":"Return value"},{"location":"api/basic_json/is_boolean/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/is_boolean/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/is_boolean/#example","text":"Example The following code exemplifies is_boolean() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_boolean() std :: cout << std :: boolalpha ; std :: cout << j_null . is_boolean () << '\\n' ; std :: cout << j_boolean . is_boolean () << '\\n' ; std :: cout << j_number_integer . is_boolean () << '\\n' ; std :: cout << j_number_unsigned_integer . is_boolean () << '\\n' ; std :: cout << j_number_float . is_boolean () << '\\n' ; std :: cout << j_object . is_boolean () << '\\n' ; std :: cout << j_array . is_boolean () << '\\n' ; std :: cout << j_string . is_boolean () << '\\n' ; std :: cout << j_binary . is_boolean () << '\\n' ; } Output: false true false false false false false false false","title":"Example"},{"location":"api/basic_json/is_boolean/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/is_discarded/","text":"basic_json::is_discarded \u00b6 constexpr bool is_discarded () const noexcept ; This function returns true if and only if the JSON value was discarded during parsing with a callback function (see parser_callback_t ). Return value \u00b6 true if type is discarded, false otherwise. Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Notes \u00b6 This function will always be false for JSON values after parsing. That is, discarded values can only occur during parsing, but will be removed when inside a structured value or replaced by null in other cases. Example \u00b6 Example The following code exemplifies is_discarded() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_discarded() std :: cout << std :: boolalpha ; std :: cout << j_null . is_discarded () << '\\n' ; std :: cout << j_boolean . is_discarded () << '\\n' ; std :: cout << j_number_integer . is_discarded () << '\\n' ; std :: cout << j_number_unsigned_integer . is_discarded () << '\\n' ; std :: cout << j_number_float . is_discarded () << '\\n' ; std :: cout << j_object . is_discarded () << '\\n' ; std :: cout << j_array . is_discarded () << '\\n' ; std :: cout << j_string . is_discarded () << '\\n' ; std :: cout << j_binary . is_discarded () << '\\n' ; } Output: false false false false false false false false false Version history \u00b6 Added in version 1.0.0.","title":"basic_json::is_discarded"},{"location":"api/basic_json/is_discarded/#basic_jsonis_discarded","text":"constexpr bool is_discarded () const noexcept ; This function returns true if and only if the JSON value was discarded during parsing with a callback function (see parser_callback_t ).","title":"basic_json::is_discarded"},{"location":"api/basic_json/is_discarded/#return-value","text":"true if type is discarded, false otherwise.","title":"Return value"},{"location":"api/basic_json/is_discarded/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/is_discarded/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/is_discarded/#notes","text":"This function will always be false for JSON values after parsing. That is, discarded values can only occur during parsing, but will be removed when inside a structured value or replaced by null in other cases.","title":"Notes"},{"location":"api/basic_json/is_discarded/#example","text":"Example The following code exemplifies is_discarded() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_discarded() std :: cout << std :: boolalpha ; std :: cout << j_null . is_discarded () << '\\n' ; std :: cout << j_boolean . is_discarded () << '\\n' ; std :: cout << j_number_integer . is_discarded () << '\\n' ; std :: cout << j_number_unsigned_integer . is_discarded () << '\\n' ; std :: cout << j_number_float . is_discarded () << '\\n' ; std :: cout << j_object . is_discarded () << '\\n' ; std :: cout << j_array . is_discarded () << '\\n' ; std :: cout << j_string . is_discarded () << '\\n' ; std :: cout << j_binary . is_discarded () << '\\n' ; } Output: false false false false false false false false false","title":"Example"},{"location":"api/basic_json/is_discarded/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/is_null/","text":"basic_json::is_null \u00b6 constexpr bool is_null () const noexcept ; This function returns true if and only if the JSON value is null . Return value \u00b6 true if type is null , false otherwise. Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code exemplifies is_null() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_null() std :: cout << std :: boolalpha ; std :: cout << j_null . is_null () << '\\n' ; std :: cout << j_boolean . is_null () << '\\n' ; std :: cout << j_number_integer . is_null () << '\\n' ; std :: cout << j_number_unsigned_integer . is_null () << '\\n' ; std :: cout << j_number_float . is_null () << '\\n' ; std :: cout << j_object . is_null () << '\\n' ; std :: cout << j_array . is_null () << '\\n' ; std :: cout << j_string . is_null () << '\\n' ; std :: cout << j_binary . is_null () << '\\n' ; } Output: true false false false false false false false false Version history \u00b6 Added in version 1.0.0.","title":"basic_json::is_null"},{"location":"api/basic_json/is_null/#basic_jsonis_null","text":"constexpr bool is_null () const noexcept ; This function returns true if and only if the JSON value is null .","title":"basic_json::is_null"},{"location":"api/basic_json/is_null/#return-value","text":"true if type is null , false otherwise.","title":"Return value"},{"location":"api/basic_json/is_null/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/is_null/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/is_null/#example","text":"Example The following code exemplifies is_null() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_null() std :: cout << std :: boolalpha ; std :: cout << j_null . is_null () << '\\n' ; std :: cout << j_boolean . is_null () << '\\n' ; std :: cout << j_number_integer . is_null () << '\\n' ; std :: cout << j_number_unsigned_integer . is_null () << '\\n' ; std :: cout << j_number_float . is_null () << '\\n' ; std :: cout << j_object . is_null () << '\\n' ; std :: cout << j_array . is_null () << '\\n' ; std :: cout << j_string . is_null () << '\\n' ; std :: cout << j_binary . is_null () << '\\n' ; } Output: true false false false false false false false false","title":"Example"},{"location":"api/basic_json/is_null/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/is_number/","text":"basic_json::is_number \u00b6 constexpr bool is_number () const noexcept ; This function returns true if and only if the JSON value is a number. This includes both integer (signed and unsigned) and floating-point values. Return value \u00b6 true if type is number (regardless whether integer, unsigned integer or floating-type), false otherwise. Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Possible implementation \u00b6 constexpr bool is_number () const noexcept { return is_number_integer () || is_number_float (); } Example \u00b6 Example The following code exemplifies is_number() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_number() std :: cout << std :: boolalpha ; std :: cout << j_null . is_number () << '\\n' ; std :: cout << j_boolean . is_number () << '\\n' ; std :: cout << j_number_integer . is_number () << '\\n' ; std :: cout << j_number_unsigned_integer . is_number () << '\\n' ; std :: cout << j_number_float . is_number () << '\\n' ; std :: cout << j_object . is_number () << '\\n' ; std :: cout << j_array . is_number () << '\\n' ; std :: cout << j_string . is_number () << '\\n' ; std :: cout << j_binary . is_number () << '\\n' ; } Output: false false true true true false false false false Version history \u00b6 Added in version 1.0.0. Extended to also return true for unsigned integers in 2.0.0.","title":"basic_json::is_number"},{"location":"api/basic_json/is_number/#basic_jsonis_number","text":"constexpr bool is_number () const noexcept ; This function returns true if and only if the JSON value is a number. This includes both integer (signed and unsigned) and floating-point values.","title":"basic_json::is_number"},{"location":"api/basic_json/is_number/#return-value","text":"true if type is number (regardless whether integer, unsigned integer or floating-type), false otherwise.","title":"Return value"},{"location":"api/basic_json/is_number/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/is_number/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/is_number/#possible-implementation","text":"constexpr bool is_number () const noexcept { return is_number_integer () || is_number_float (); }","title":"Possible implementation"},{"location":"api/basic_json/is_number/#example","text":"Example The following code exemplifies is_number() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_number() std :: cout << std :: boolalpha ; std :: cout << j_null . is_number () << '\\n' ; std :: cout << j_boolean . is_number () << '\\n' ; std :: cout << j_number_integer . is_number () << '\\n' ; std :: cout << j_number_unsigned_integer . is_number () << '\\n' ; std :: cout << j_number_float . is_number () << '\\n' ; std :: cout << j_object . is_number () << '\\n' ; std :: cout << j_array . is_number () << '\\n' ; std :: cout << j_string . is_number () << '\\n' ; std :: cout << j_binary . is_number () << '\\n' ; } Output: false false true true true false false false false","title":"Example"},{"location":"api/basic_json/is_number/#version-history","text":"Added in version 1.0.0. Extended to also return true for unsigned integers in 2.0.0.","title":"Version history"},{"location":"api/basic_json/is_number_float/","text":"basic_json::is_number_float \u00b6 constexpr bool is_number_float () const noexcept ; This function returns true if and only if the JSON value is a floating-point number. This excludes signed and unsigned integer values. Return value \u00b6 true if type is a floating-point number, false otherwise. Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code exemplifies is_number_float() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_number_float() std :: cout << std :: boolalpha ; std :: cout << j_null . is_number_float () << '\\n' ; std :: cout << j_boolean . is_number_float () << '\\n' ; std :: cout << j_number_integer . is_number_float () << '\\n' ; std :: cout << j_number_unsigned_integer . is_number_float () << '\\n' ; std :: cout << j_number_float . is_number_float () << '\\n' ; std :: cout << j_object . is_number_float () << '\\n' ; std :: cout << j_array . is_number_float () << '\\n' ; std :: cout << j_string . is_number_float () << '\\n' ; std :: cout << j_binary . is_number_float () << '\\n' ; } Output: false false false false true false false false false Version history \u00b6 Added in version 1.0.0.","title":"basic_json::is_number_float"},{"location":"api/basic_json/is_number_float/#basic_jsonis_number_float","text":"constexpr bool is_number_float () const noexcept ; This function returns true if and only if the JSON value is a floating-point number. This excludes signed and unsigned integer values.","title":"basic_json::is_number_float"},{"location":"api/basic_json/is_number_float/#return-value","text":"true if type is a floating-point number, false otherwise.","title":"Return value"},{"location":"api/basic_json/is_number_float/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/is_number_float/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/is_number_float/#example","text":"Example The following code exemplifies is_number_float() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_number_float() std :: cout << std :: boolalpha ; std :: cout << j_null . is_number_float () << '\\n' ; std :: cout << j_boolean . is_number_float () << '\\n' ; std :: cout << j_number_integer . is_number_float () << '\\n' ; std :: cout << j_number_unsigned_integer . is_number_float () << '\\n' ; std :: cout << j_number_float . is_number_float () << '\\n' ; std :: cout << j_object . is_number_float () << '\\n' ; std :: cout << j_array . is_number_float () << '\\n' ; std :: cout << j_string . is_number_float () << '\\n' ; std :: cout << j_binary . is_number_float () << '\\n' ; } Output: false false false false true false false false false","title":"Example"},{"location":"api/basic_json/is_number_float/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/is_number_integer/","text":"basic_json::is_number_integer \u00b6 constexpr bool is_number_integer () const noexcept ; This function returns true if and only if the JSON value is a signed or unsigned integer number. This excludes floating-point values. Return value \u00b6 true if type is an integer or unsigned integer number, false otherwise. Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code exemplifies is_number_integer() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_number_integer() std :: cout << std :: boolalpha ; std :: cout << j_null . is_number_integer () << '\\n' ; std :: cout << j_boolean . is_number_integer () << '\\n' ; std :: cout << j_number_integer . is_number_integer () << '\\n' ; std :: cout << j_number_unsigned_integer . is_number_integer () << '\\n' ; std :: cout << j_number_float . is_number_integer () << '\\n' ; std :: cout << j_object . is_number_integer () << '\\n' ; std :: cout << j_array . is_number_integer () << '\\n' ; std :: cout << j_string . is_number_integer () << '\\n' ; std :: cout << j_binary . is_number_integer () << '\\n' ; } Output: false false true true false false false false false Version history \u00b6 Added in version 1.0.0. Extended to also return true for unsigned integers in 2.0.0.","title":"basic_json::is_number_integer"},{"location":"api/basic_json/is_number_integer/#basic_jsonis_number_integer","text":"constexpr bool is_number_integer () const noexcept ; This function returns true if and only if the JSON value is a signed or unsigned integer number. This excludes floating-point values.","title":"basic_json::is_number_integer"},{"location":"api/basic_json/is_number_integer/#return-value","text":"true if type is an integer or unsigned integer number, false otherwise.","title":"Return value"},{"location":"api/basic_json/is_number_integer/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/is_number_integer/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/is_number_integer/#example","text":"Example The following code exemplifies is_number_integer() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_number_integer() std :: cout << std :: boolalpha ; std :: cout << j_null . is_number_integer () << '\\n' ; std :: cout << j_boolean . is_number_integer () << '\\n' ; std :: cout << j_number_integer . is_number_integer () << '\\n' ; std :: cout << j_number_unsigned_integer . is_number_integer () << '\\n' ; std :: cout << j_number_float . is_number_integer () << '\\n' ; std :: cout << j_object . is_number_integer () << '\\n' ; std :: cout << j_array . is_number_integer () << '\\n' ; std :: cout << j_string . is_number_integer () << '\\n' ; std :: cout << j_binary . is_number_integer () << '\\n' ; } Output: false false true true false false false false false","title":"Example"},{"location":"api/basic_json/is_number_integer/#version-history","text":"Added in version 1.0.0. Extended to also return true for unsigned integers in 2.0.0.","title":"Version history"},{"location":"api/basic_json/is_number_unsigned/","text":"basic_json::is_number_unsigned \u00b6 constexpr bool is_number_unsigned () const noexcept ; This function returns true if and only if the JSON value is an unsigned integer number. This excludes floating-point and signed integer values. Return value \u00b6 true if type is an unsigned integer number, false otherwise. Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code exemplifies is_number_unsigned() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_number_unsigned() std :: cout << std :: boolalpha ; std :: cout << j_null . is_number_unsigned () << '\\n' ; std :: cout << j_boolean . is_number_unsigned () << '\\n' ; std :: cout << j_number_integer . is_number_unsigned () << '\\n' ; std :: cout << j_number_unsigned_integer . is_number_unsigned () << '\\n' ; std :: cout << j_number_float . is_number_unsigned () << '\\n' ; std :: cout << j_object . is_number_unsigned () << '\\n' ; std :: cout << j_array . is_number_unsigned () << '\\n' ; std :: cout << j_string . is_number_unsigned () << '\\n' ; std :: cout << j_binary . is_number_unsigned () << '\\n' ; } Output: false false false true false false false false false Version history \u00b6 Added in version 2.0.0.","title":"basic_json::is_number_unsigned"},{"location":"api/basic_json/is_number_unsigned/#basic_jsonis_number_unsigned","text":"constexpr bool is_number_unsigned () const noexcept ; This function returns true if and only if the JSON value is an unsigned integer number. This excludes floating-point and signed integer values.","title":"basic_json::is_number_unsigned"},{"location":"api/basic_json/is_number_unsigned/#return-value","text":"true if type is an unsigned integer number, false otherwise.","title":"Return value"},{"location":"api/basic_json/is_number_unsigned/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/is_number_unsigned/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/is_number_unsigned/#example","text":"Example The following code exemplifies is_number_unsigned() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_unsigned_integer = 12345678987654321u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_number_unsigned() std :: cout << std :: boolalpha ; std :: cout << j_null . is_number_unsigned () << '\\n' ; std :: cout << j_boolean . is_number_unsigned () << '\\n' ; std :: cout << j_number_integer . is_number_unsigned () << '\\n' ; std :: cout << j_number_unsigned_integer . is_number_unsigned () << '\\n' ; std :: cout << j_number_float . is_number_unsigned () << '\\n' ; std :: cout << j_object . is_number_unsigned () << '\\n' ; std :: cout << j_array . is_number_unsigned () << '\\n' ; std :: cout << j_string . is_number_unsigned () << '\\n' ; std :: cout << j_binary . is_number_unsigned () << '\\n' ; } Output: false false false true false false false false false","title":"Example"},{"location":"api/basic_json/is_number_unsigned/#version-history","text":"Added in version 2.0.0.","title":"Version history"},{"location":"api/basic_json/is_object/","text":"basic_json::is_object \u00b6 constexpr bool is_object () const noexcept ; This function returns true if and only if the JSON value is an object. Return value \u00b6 true if type is an object, false otherwise. Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code exemplifies is_object() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_number_unsigned_integer = 12345678987654321u ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_object() std :: cout << std :: boolalpha ; std :: cout << j_null . is_object () << '\\n' ; std :: cout << j_boolean . is_object () << '\\n' ; std :: cout << j_number_integer . is_object () << '\\n' ; std :: cout << j_number_unsigned_integer . is_object () << '\\n' ; std :: cout << j_number_float . is_object () << '\\n' ; std :: cout << j_object . is_object () << '\\n' ; std :: cout << j_array . is_object () << '\\n' ; std :: cout << j_string . is_object () << '\\n' ; std :: cout << j_binary . is_object () << '\\n' ; } Output: false false false false false true false false false Version history \u00b6 Added in version 1.0.0.","title":"basic_json::is_object"},{"location":"api/basic_json/is_object/#basic_jsonis_object","text":"constexpr bool is_object () const noexcept ; This function returns true if and only if the JSON value is an object.","title":"basic_json::is_object"},{"location":"api/basic_json/is_object/#return-value","text":"true if type is an object, false otherwise.","title":"Return value"},{"location":"api/basic_json/is_object/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/is_object/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/is_object/#example","text":"Example The following code exemplifies is_object() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_number_unsigned_integer = 12345678987654321u ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_object() std :: cout << std :: boolalpha ; std :: cout << j_null . is_object () << '\\n' ; std :: cout << j_boolean . is_object () << '\\n' ; std :: cout << j_number_integer . is_object () << '\\n' ; std :: cout << j_number_unsigned_integer . is_object () << '\\n' ; std :: cout << j_number_float . is_object () << '\\n' ; std :: cout << j_object . is_object () << '\\n' ; std :: cout << j_array . is_object () << '\\n' ; std :: cout << j_string . is_object () << '\\n' ; std :: cout << j_binary . is_object () << '\\n' ; } Output: false false false false false true false false false","title":"Example"},{"location":"api/basic_json/is_object/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/is_primitive/","text":"basic_json::is_primitive \u00b6 constexpr bool is_primitive () const noexcept ; This function returns true if and only if the JSON type is primitive (string, number, boolean, null , binary). Return value \u00b6 true if type is primitive (string, number, boolean, null , or binary), false otherwise. Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Possible implementation \u00b6 constexpr bool is_primitive () const noexcept { return is_null () || is_string () || is_boolean () || is_number () || is_binary (); } Notes \u00b6 The term primitive stems from RFC 8259 : JSON can represent four primitive types (strings, numbers, booleans, and null) and two structured types (objects and arrays). This library extends primitive types to binary types, because binary types are roughly comparable to strings. Hence, is_primitive() returns true for binary values. Example \u00b6 Example The following code exemplifies is_primitive() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_number_unsigned_integer = 12345678987654321u ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_primitive() std :: cout << std :: boolalpha ; std :: cout << j_null . is_primitive () << '\\n' ; std :: cout << j_boolean . is_primitive () << '\\n' ; std :: cout << j_number_integer . is_primitive () << '\\n' ; std :: cout << j_number_unsigned_integer . is_primitive () << '\\n' ; std :: cout << j_number_float . is_primitive () << '\\n' ; std :: cout << j_object . is_primitive () << '\\n' ; std :: cout << j_array . is_primitive () << '\\n' ; std :: cout << j_string . is_primitive () << '\\n' ; std :: cout << j_binary . is_primitive () << '\\n' ; } Output: true true true true true false false true true Version history \u00b6 Added in version 1.0.0. Extended to return true for binary types in version 3.8.0.","title":"basic_json::is_primitive"},{"location":"api/basic_json/is_primitive/#basic_jsonis_primitive","text":"constexpr bool is_primitive () const noexcept ; This function returns true if and only if the JSON type is primitive (string, number, boolean, null , binary).","title":"basic_json::is_primitive"},{"location":"api/basic_json/is_primitive/#return-value","text":"true if type is primitive (string, number, boolean, null , or binary), false otherwise.","title":"Return value"},{"location":"api/basic_json/is_primitive/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/is_primitive/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/is_primitive/#possible-implementation","text":"constexpr bool is_primitive () const noexcept { return is_null () || is_string () || is_boolean () || is_number () || is_binary (); }","title":"Possible implementation"},{"location":"api/basic_json/is_primitive/#notes","text":"The term primitive stems from RFC 8259 : JSON can represent four primitive types (strings, numbers, booleans, and null) and two structured types (objects and arrays). This library extends primitive types to binary types, because binary types are roughly comparable to strings. Hence, is_primitive() returns true for binary values.","title":"Notes"},{"location":"api/basic_json/is_primitive/#example","text":"Example The following code exemplifies is_primitive() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_number_unsigned_integer = 12345678987654321u ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_primitive() std :: cout << std :: boolalpha ; std :: cout << j_null . is_primitive () << '\\n' ; std :: cout << j_boolean . is_primitive () << '\\n' ; std :: cout << j_number_integer . is_primitive () << '\\n' ; std :: cout << j_number_unsigned_integer . is_primitive () << '\\n' ; std :: cout << j_number_float . is_primitive () << '\\n' ; std :: cout << j_object . is_primitive () << '\\n' ; std :: cout << j_array . is_primitive () << '\\n' ; std :: cout << j_string . is_primitive () << '\\n' ; std :: cout << j_binary . is_primitive () << '\\n' ; } Output: true true true true true false false true true","title":"Example"},{"location":"api/basic_json/is_primitive/#version-history","text":"Added in version 1.0.0. Extended to return true for binary types in version 3.8.0.","title":"Version history"},{"location":"api/basic_json/is_string/","text":"basic_json::is_string \u00b6 constexpr bool is_string () const noexcept ; This function returns true if and only if the JSON value is a string. Return value \u00b6 true if type is a string, false otherwise. Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code exemplifies is_string() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_number_unsigned_integer = 12345678987654321u ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_string() std :: cout << std :: boolalpha ; std :: cout << j_null . is_string () << '\\n' ; std :: cout << j_boolean . is_string () << '\\n' ; std :: cout << j_number_integer . is_string () << '\\n' ; std :: cout << j_number_unsigned_integer . is_string () << '\\n' ; std :: cout << j_number_float . is_string () << '\\n' ; std :: cout << j_object . is_string () << '\\n' ; std :: cout << j_array . is_string () << '\\n' ; std :: cout << j_string . is_string () << '\\n' ; std :: cout << j_binary . is_string () << '\\n' ; } Output: false false false false false false false true false Version history \u00b6 Added in version 1.0.0.","title":"basic_json::is_string"},{"location":"api/basic_json/is_string/#basic_jsonis_string","text":"constexpr bool is_string () const noexcept ; This function returns true if and only if the JSON value is a string.","title":"basic_json::is_string"},{"location":"api/basic_json/is_string/#return-value","text":"true if type is a string, false otherwise.","title":"Return value"},{"location":"api/basic_json/is_string/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/is_string/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/is_string/#example","text":"Example The following code exemplifies is_string() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_number_unsigned_integer = 12345678987654321u ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_string() std :: cout << std :: boolalpha ; std :: cout << j_null . is_string () << '\\n' ; std :: cout << j_boolean . is_string () << '\\n' ; std :: cout << j_number_integer . is_string () << '\\n' ; std :: cout << j_number_unsigned_integer . is_string () << '\\n' ; std :: cout << j_number_float . is_string () << '\\n' ; std :: cout << j_object . is_string () << '\\n' ; std :: cout << j_array . is_string () << '\\n' ; std :: cout << j_string . is_string () << '\\n' ; std :: cout << j_binary . is_string () << '\\n' ; } Output: false false false false false false false true false","title":"Example"},{"location":"api/basic_json/is_string/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/is_structured/","text":"basic_json::is_structured \u00b6 constexpr bool is_structured () const noexcept ; This function returns true if and only if the JSON type is structured (array or object). Return value \u00b6 true if type is structured (array or object), false otherwise. Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Notes \u00b6 The term structured stems from RFC 8259 : JSON can represent four primitive types (strings, numbers, booleans, and null) and two structured types (objects and arrays). Note that though strings are containers in C++, they are treated as primitive values in JSON. Example \u00b6 Example The following code exemplifies is_structured() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_number_unsigned_integer = 12345678987654321u ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_structured() std :: cout << std :: boolalpha ; std :: cout << j_null . is_structured () << '\\n' ; std :: cout << j_boolean . is_structured () << '\\n' ; std :: cout << j_number_integer . is_structured () << '\\n' ; std :: cout << j_number_unsigned_integer . is_structured () << '\\n' ; std :: cout << j_number_float . is_structured () << '\\n' ; std :: cout << j_object . is_structured () << '\\n' ; std :: cout << j_array . is_structured () << '\\n' ; std :: cout << j_string . is_structured () << '\\n' ; std :: cout << j_binary . is_structured () << '\\n' ; } Output: false false false false false true true false false Version history \u00b6 Added in version 1.0.0.","title":"basic_json::is_structured"},{"location":"api/basic_json/is_structured/#basic_jsonis_structured","text":"constexpr bool is_structured () const noexcept ; This function returns true if and only if the JSON type is structured (array or object).","title":"basic_json::is_structured"},{"location":"api/basic_json/is_structured/#return-value","text":"true if type is structured (array or object), false otherwise.","title":"Return value"},{"location":"api/basic_json/is_structured/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/is_structured/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/is_structured/#notes","text":"The term structured stems from RFC 8259 : JSON can represent four primitive types (strings, numbers, booleans, and null) and two structured types (objects and arrays). Note that though strings are containers in C++, they are treated as primitive values in JSON.","title":"Notes"},{"location":"api/basic_json/is_structured/#example","text":"Example The following code exemplifies is_structured() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_number_unsigned_integer = 12345678987654321u ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; json j_binary = json :: binary ({ 1 , 2 , 3 }); // call is_structured() std :: cout << std :: boolalpha ; std :: cout << j_null . is_structured () << '\\n' ; std :: cout << j_boolean . is_structured () << '\\n' ; std :: cout << j_number_integer . is_structured () << '\\n' ; std :: cout << j_number_unsigned_integer . is_structured () << '\\n' ; std :: cout << j_number_float . is_structured () << '\\n' ; std :: cout << j_object . is_structured () << '\\n' ; std :: cout << j_array . is_structured () << '\\n' ; std :: cout << j_string . is_structured () << '\\n' ; std :: cout << j_binary . is_structured () << '\\n' ; } Output: false false false false false true true false false","title":"Example"},{"location":"api/basic_json/is_structured/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/items/","text":"basic_json::items \u00b6 iteration_proxy < iterator > items () noexcept ; iteration_proxy < const_iterator > items () const noexcept ; This function allows to access iterator::key() and iterator::value() during range-based for loops. In these loops, a reference to the JSON values is returned, so there is no access to the underlying iterator. For loop without items() function: for ( auto it = j_object . begin (); it != j_object . end (); ++ it ) { std :: cout << \"key: \" << it . key () << \", value:\" << it . value () << '\\n' ; } Range-based for loop without items() function: for ( auto it : j_object ) { // \"it\" is of type json::reference and has no key() member std :: cout << \"value: \" << it << '\\n' ; } Range-based for loop with items() function: for ( auto & el : j_object . items ()) { std :: cout << \"key: \" << el . key () << \", value:\" << el . value () << '\\n' ; } The items() function also allows to use structured bindings (C++17): for ( auto & [ key , val ] : j_object . items ()) { std :: cout << \"key: \" << key << \", value:\" << val << '\\n' ; } Return value \u00b6 iteration proxy object wrapping the current value with an interface to use in range-based for loops Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Constant. Notes \u00b6 When iterating over an array, key() will return the index of the element as string (see example). For primitive types (e.g., numbers), key() returns an empty string. Warning Using items() on temporary objects is dangerous. Make sure the object's lifetime exeeds the iteration. See https://github.com/nlohmann/json/issues/2040 for more information. Example \u00b6 Example The following code shows an example for items() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; // example for an object for ( auto & x : j_object . items ()) { std :: cout << \"key: \" << x . key () << \", value: \" << x . value () << '\\n' ; } // example for an array for ( auto & x : j_array . items ()) { std :: cout << \"key: \" << x . key () << \", value: \" << x . value () << '\\n' ; } } Output: key: one, value: 1 key: two, value: 2 key: 0 , value: 1 key: 1 , value: 2 key: 2 , value: 4 key: 3 , value: 8 key: 4 , value: 16 Version history \u00b6 Added in version 3.0.0. Added structured binding support in version 3.5.0. Note This function replaces the static function iterator_wrapper which was introduced in version 1.0.0, but has been deprecated in version 3.1.0. Function iterator_wrapper will be removed in version 4.0.0. Please replace all occurrences of iterator_wrapper ( j ) with j . items () .","title":"basic_json::items"},{"location":"api/basic_json/items/#basic_jsonitems","text":"iteration_proxy < iterator > items () noexcept ; iteration_proxy < const_iterator > items () const noexcept ; This function allows to access iterator::key() and iterator::value() during range-based for loops. In these loops, a reference to the JSON values is returned, so there is no access to the underlying iterator. For loop without items() function: for ( auto it = j_object . begin (); it != j_object . end (); ++ it ) { std :: cout << \"key: \" << it . key () << \", value:\" << it . value () << '\\n' ; } Range-based for loop without items() function: for ( auto it : j_object ) { // \"it\" is of type json::reference and has no key() member std :: cout << \"value: \" << it << '\\n' ; } Range-based for loop with items() function: for ( auto & el : j_object . items ()) { std :: cout << \"key: \" << el . key () << \", value:\" << el . value () << '\\n' ; } The items() function also allows to use structured bindings (C++17): for ( auto & [ key , val ] : j_object . items ()) { std :: cout << \"key: \" << key << \", value:\" << val << '\\n' ; }","title":"basic_json::items"},{"location":"api/basic_json/items/#return-value","text":"iteration proxy object wrapping the current value with an interface to use in range-based for loops","title":"Return value"},{"location":"api/basic_json/items/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/items/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/items/#notes","text":"When iterating over an array, key() will return the index of the element as string (see example). For primitive types (e.g., numbers), key() returns an empty string. Warning Using items() on temporary objects is dangerous. Make sure the object's lifetime exeeds the iteration. See https://github.com/nlohmann/json/issues/2040 for more information.","title":"Notes"},{"location":"api/basic_json/items/#example","text":"Example The following code shows an example for items() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; // example for an object for ( auto & x : j_object . items ()) { std :: cout << \"key: \" << x . key () << \", value: \" << x . value () << '\\n' ; } // example for an array for ( auto & x : j_array . items ()) { std :: cout << \"key: \" << x . key () << \", value: \" << x . value () << '\\n' ; } } Output: key: one, value: 1 key: two, value: 2 key: 0 , value: 1 key: 1 , value: 2 key: 2 , value: 4 key: 3 , value: 8 key: 4 , value: 16","title":"Example"},{"location":"api/basic_json/items/#version-history","text":"Added in version 3.0.0. Added structured binding support in version 3.5.0. Note This function replaces the static function iterator_wrapper which was introduced in version 1.0.0, but has been deprecated in version 3.1.0. Function iterator_wrapper will be removed in version 4.0.0. Please replace all occurrences of iterator_wrapper ( j ) with j . items () .","title":"Version history"},{"location":"api/basic_json/max_size/","text":"basic_json::max_size \u00b6 size_type max_size () const noexcept ; Returns the maximum number of elements a JSON value is able to hold due to system or library implementation limitations, i.e. std::distance(begin(), end()) for the JSON value. Return value \u00b6 The return value depends on the different types and is defined as follows: Value type return value null 0 (same as size() ) boolean 1 (same as size() ) string 1 (same as size() ) number 1 (same as size() ) binary 1 (same as size() ) object result of function object_t::max_size() array result of function array_t::max_size() Exception safety \u00b6 No-throw guarantee: this function never throws exceptions. Complexity \u00b6 Constant, as long as array_t and object_t satisfy the Container concept; that is, their max_size() functions have constant complexity. Notes \u00b6 This function does not return the maximal length of a string stored as JSON value -- it returns the maximal number of string elements the JSON value can store which is 1 . Example \u00b6 Example The following code calls max_size() on the different value types. Note the output is implementation specific. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; // call max_size() std :: cout << j_null . max_size () << '\\n' ; std :: cout << j_boolean . max_size () << '\\n' ; std :: cout << j_number_integer . max_size () << '\\n' ; std :: cout << j_number_float . max_size () << '\\n' ; std :: cout << j_object . max_size () << '\\n' ; std :: cout << j_array . max_size () << '\\n' ; std :: cout << j_string . max_size () << '\\n' ; } Output: 0 1 1 1 256204778801521550 1152921504606846975 1 Version history \u00b6 Added in version 1.0.0. Extended to return 1 for binary types in version 3.8.0.","title":"basic_json::max_size"},{"location":"api/basic_json/max_size/#basic_jsonmax_size","text":"size_type max_size () const noexcept ; Returns the maximum number of elements a JSON value is able to hold due to system or library implementation limitations, i.e. std::distance(begin(), end()) for the JSON value.","title":"basic_json::max_size"},{"location":"api/basic_json/max_size/#return-value","text":"The return value depends on the different types and is defined as follows: Value type return value null 0 (same as size() ) boolean 1 (same as size() ) string 1 (same as size() ) number 1 (same as size() ) binary 1 (same as size() ) object result of function object_t::max_size() array result of function array_t::max_size()","title":"Return value"},{"location":"api/basic_json/max_size/#exception-safety","text":"No-throw guarantee: this function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/max_size/#complexity","text":"Constant, as long as array_t and object_t satisfy the Container concept; that is, their max_size() functions have constant complexity.","title":"Complexity"},{"location":"api/basic_json/max_size/#notes","text":"This function does not return the maximal length of a string stored as JSON value -- it returns the maximal number of string elements the JSON value can store which is 1 .","title":"Notes"},{"location":"api/basic_json/max_size/#example","text":"Example The following code calls max_size() on the different value types. Note the output is implementation specific. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; // call max_size() std :: cout << j_null . max_size () << '\\n' ; std :: cout << j_boolean . max_size () << '\\n' ; std :: cout << j_number_integer . max_size () << '\\n' ; std :: cout << j_number_float . max_size () << '\\n' ; std :: cout << j_object . max_size () << '\\n' ; std :: cout << j_array . max_size () << '\\n' ; std :: cout << j_string . max_size () << '\\n' ; } Output: 0 1 1 1 256204778801521550 1152921504606846975 1","title":"Example"},{"location":"api/basic_json/max_size/#version-history","text":"Added in version 1.0.0. Extended to return 1 for binary types in version 3.8.0.","title":"Version history"},{"location":"api/basic_json/merge_patch/","text":"basic_json::merge_patch \u00b6 void merge_patch ( const basic_json & apply_patch ); The merge patch format is primarily intended for use with the HTTP PATCH method as a means of describing a set of modifications to a target resource's content. This function applies a merge patch to the current JSON value. The function implements the following algorithm from Section 2 of RFC 7396 (JSON Merge Patch) : define MergePatch ( Target , Patch ): if Patch is an Object : if Target is not an Object : Target = {} // Ignore the contents and set it to an empty Object for each Name / Value pair in Patch : if Value is null : if Name exists in Target : remove the Name / Value pair from Target else : Target [ Name ] = MergePatch ( Target [ Name ], Value ) return Target else : return Patch Thereby, Target is the current object; that is, the patch is applied to the current value. Parameters \u00b6 apply_patch (in) the patch to apply Complexity \u00b6 Linear in the lengths of apply_patch . Example \u00b6 Example The following code shows how a JSON Merge Patch is applied to a JSON document. #include <iostream> #include <nlohmann/json.hpp> #include <iomanip> // for std::setw using json = nlohmann :: json ; int main () { // the original document json document = R \" ( { \"title\": \"Goodbye!\", \"author\": { \"givenName\": \"John\", \"familyName\": \"Doe\" }, \"tags\": [ \"example\", \"sample\" ], \"content\": \"This will be unchanged\" } ) \" _json ; // the patch json patch = R \" ( { \"title\": \"Hello!\", \"phoneNumber\": \"+01-123-456-7890\", \"author\": { \"familyName\": null }, \"tags\": [ \"example\" ] } ) \" _json ; // apply the patch document . merge_patch ( patch ); // output original and patched document std :: cout << std :: setw ( 4 ) << document << std :: endl ; } Output: { \"author\" : { \"givenName\" : \"John\" }, \"content\" : \"This will be unchanged\" , \"phoneNumber\" : \"+01-123-456-7890\" , \"tags\" : [ \"example\" ], \"title\" : \"Hello!\" } Version history \u00b6 Added in version 3.0.0.","title":"basic_json::merge_patch"},{"location":"api/basic_json/merge_patch/#basic_jsonmerge_patch","text":"void merge_patch ( const basic_json & apply_patch ); The merge patch format is primarily intended for use with the HTTP PATCH method as a means of describing a set of modifications to a target resource's content. This function applies a merge patch to the current JSON value. The function implements the following algorithm from Section 2 of RFC 7396 (JSON Merge Patch) : define MergePatch ( Target , Patch ): if Patch is an Object : if Target is not an Object : Target = {} // Ignore the contents and set it to an empty Object for each Name / Value pair in Patch : if Value is null : if Name exists in Target : remove the Name / Value pair from Target else : Target [ Name ] = MergePatch ( Target [ Name ], Value ) return Target else : return Patch Thereby, Target is the current object; that is, the patch is applied to the current value.","title":"basic_json::merge_patch"},{"location":"api/basic_json/merge_patch/#parameters","text":"apply_patch (in) the patch to apply","title":"Parameters"},{"location":"api/basic_json/merge_patch/#complexity","text":"Linear in the lengths of apply_patch .","title":"Complexity"},{"location":"api/basic_json/merge_patch/#example","text":"Example The following code shows how a JSON Merge Patch is applied to a JSON document. #include <iostream> #include <nlohmann/json.hpp> #include <iomanip> // for std::setw using json = nlohmann :: json ; int main () { // the original document json document = R \" ( { \"title\": \"Goodbye!\", \"author\": { \"givenName\": \"John\", \"familyName\": \"Doe\" }, \"tags\": [ \"example\", \"sample\" ], \"content\": \"This will be unchanged\" } ) \" _json ; // the patch json patch = R \" ( { \"title\": \"Hello!\", \"phoneNumber\": \"+01-123-456-7890\", \"author\": { \"familyName\": null }, \"tags\": [ \"example\" ] } ) \" _json ; // apply the patch document . merge_patch ( patch ); // output original and patched document std :: cout << std :: setw ( 4 ) << document << std :: endl ; } Output: { \"author\" : { \"givenName\" : \"John\" }, \"content\" : \"This will be unchanged\" , \"phoneNumber\" : \"+01-123-456-7890\" , \"tags\" : [ \"example\" ], \"title\" : \"Hello!\" }","title":"Example"},{"location":"api/basic_json/merge_patch/#version-history","text":"Added in version 3.0.0.","title":"Version history"},{"location":"api/basic_json/meta/","text":"basic_json::meta \u00b6 static basic_json meta (); This function returns a JSON object with information about the library, including the version number and information on the platform and compiler. Return value \u00b6 JSON object holding version information key description compiler Information on the used compiler. It is an object with the following keys: c++ (the used C++ standard), family (the compiler family; possible values are clang , icc , gcc , ilecpp , msvc , pgcpp , sunpro , and unknown ), and version (the compiler version). copyright The copyright line for the library as string. name The name of the library as string. platform The used platform as string. Possible values are win32 , linux , apple , unix , and unknown . url The URL of the project as string. version The version of the library. It is an object with the following keys: major , minor , and patch as defined by Semantic Versioning , and string (the version string). Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes to any JSON value. Complexity \u00b6 Constant. Example \u00b6 The following code shows an example output of the meta() function. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // call meta() std :: cout << std :: setw ( 4 ) << json :: meta () << '\\n' ; } Output: { \"compiler\" : { \"c++\" : \"201103\" , \"family\" : \"clang\" , \"version\" : \"12.0.0 (clang-1200.0.22.19)\" }, \"copyright\" : \"(C) 2013-2020 Niels Lohmann\" , \"name\" : \"JSON for Modern C++\" , \"platform\" : \"apple\" , \"url\" : \"https://github.com/nlohmann/json\" , \"version\" : { \"major\" : 3 , \"minor\" : 9 , \"patch\" : 1 , \"string\" : \"3.9.1\" } } Version history \u00b6 Added in version 2.1.0.","title":"basic_json::meta"},{"location":"api/basic_json/meta/#basic_jsonmeta","text":"static basic_json meta (); This function returns a JSON object with information about the library, including the version number and information on the platform and compiler.","title":"basic_json::meta"},{"location":"api/basic_json/meta/#return-value","text":"JSON object holding version information key description compiler Information on the used compiler. It is an object with the following keys: c++ (the used C++ standard), family (the compiler family; possible values are clang , icc , gcc , ilecpp , msvc , pgcpp , sunpro , and unknown ), and version (the compiler version). copyright The copyright line for the library as string. name The name of the library as string. platform The used platform as string. Possible values are win32 , linux , apple , unix , and unknown . url The URL of the project as string. version The version of the library. It is an object with the following keys: major , minor , and patch as defined by Semantic Versioning , and string (the version string).","title":"Return value"},{"location":"api/basic_json/meta/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes to any JSON value.","title":"Exception safety"},{"location":"api/basic_json/meta/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/meta/#example","text":"The following code shows an example output of the meta() function. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // call meta() std :: cout << std :: setw ( 4 ) << json :: meta () << '\\n' ; } Output: { \"compiler\" : { \"c++\" : \"201103\" , \"family\" : \"clang\" , \"version\" : \"12.0.0 (clang-1200.0.22.19)\" }, \"copyright\" : \"(C) 2013-2020 Niels Lohmann\" , \"name\" : \"JSON for Modern C++\" , \"platform\" : \"apple\" , \"url\" : \"https://github.com/nlohmann/json\" , \"version\" : { \"major\" : 3 , \"minor\" : 9 , \"patch\" : 1 , \"string\" : \"3.9.1\" } }","title":"Example"},{"location":"api/basic_json/meta/#version-history","text":"Added in version 2.1.0.","title":"Version history"},{"location":"api/basic_json/number_float_t/","text":"basic_json::number_float_t \u00b6 using number_float_t = NumberFloatType ; The type used to store JSON numbers (floating-point). RFC 7159 describes numbers as follows: The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted. This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer or a floating-point number. Therefore, three different types, number_integer_t , number_unsigned_t and number_float_t are used. To store floating-point numbers in C++, a type is defined by the template parameter NumberFloatType which chooses the type to use. Notes \u00b6 Default type \u00b6 With the default values for NumberFloatType ( double ), the default value for number_float_t is double . Default behavior \u00b6 The restrictions about leading zeros is not enforced in C++. Instead, leading zeros in floating-point literals will be ignored. Internally, the value will be stored as decimal number. For instance, the C++ floating-point literal 01.2 will be serialized to 1.2 . During deserialization, leading zeros yield an error. Not-a-number (NaN) values will be serialized to null . Limits \u00b6 RFC 7159 states: This specification allows implementations to set limits on the range and precision of numbers accepted. Since software that implements IEEE 754-2008 binary64 (double precision) numbers is generally available and widely used, good interoperability can be achieved by implementations that expect no more precision or range than these provide, in the sense that implementations will approximate JSON numbers within the expected precision. This implementation does exactly follow this approach, as it uses double precision floating-point numbers. Note values smaller than -1.79769313486232e+308 and values greater than 1.79769313486232e+308 will be stored as NaN internally and be serialized to null . Storage \u00b6 Floating-point number values are stored directly inside a basic_json type. Version history \u00b6 Added in version 1.0.0.","title":"basic_json::number_float_t"},{"location":"api/basic_json/number_float_t/#basic_jsonnumber_float_t","text":"using number_float_t = NumberFloatType ; The type used to store JSON numbers (floating-point). RFC 7159 describes numbers as follows: The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted. This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer or a floating-point number. Therefore, three different types, number_integer_t , number_unsigned_t and number_float_t are used. To store floating-point numbers in C++, a type is defined by the template parameter NumberFloatType which chooses the type to use.","title":"basic_json::number_float_t"},{"location":"api/basic_json/number_float_t/#notes","text":"","title":"Notes"},{"location":"api/basic_json/number_float_t/#default-type","text":"With the default values for NumberFloatType ( double ), the default value for number_float_t is double .","title":"Default type"},{"location":"api/basic_json/number_float_t/#default-behavior","text":"The restrictions about leading zeros is not enforced in C++. Instead, leading zeros in floating-point literals will be ignored. Internally, the value will be stored as decimal number. For instance, the C++ floating-point literal 01.2 will be serialized to 1.2 . During deserialization, leading zeros yield an error. Not-a-number (NaN) values will be serialized to null .","title":"Default behavior"},{"location":"api/basic_json/number_float_t/#limits","text":"RFC 7159 states: This specification allows implementations to set limits on the range and precision of numbers accepted. Since software that implements IEEE 754-2008 binary64 (double precision) numbers is generally available and widely used, good interoperability can be achieved by implementations that expect no more precision or range than these provide, in the sense that implementations will approximate JSON numbers within the expected precision. This implementation does exactly follow this approach, as it uses double precision floating-point numbers. Note values smaller than -1.79769313486232e+308 and values greater than 1.79769313486232e+308 will be stored as NaN internally and be serialized to null .","title":"Limits"},{"location":"api/basic_json/number_float_t/#storage","text":"Floating-point number values are stored directly inside a basic_json type.","title":"Storage"},{"location":"api/basic_json/number_float_t/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/number_integer_t/","text":"basic_json::number_integer_t \u00b6 using number_integer_t = NumberIntegerType ; The type used to store JSON numbers (integers). RFC 7159 describes numbers as follows: The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted. This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer or a floating-point number. Therefore, three different types, number_integer_t , number_unsigned_t and number_float_t are used. To store integer numbers in C++, a type is defined by the template parameter NumberIntegerType which chooses the type to use. Notes \u00b6 Default type \u00b6 With the default values for NumberIntegerType ( std::int64_t ), the default value for number_integer_t is std :: int64_t . Default behavior \u00b6 The restrictions about leading zeros is not enforced in C++. Instead, leading zeros in integer literals lead to an interpretation as octal number. Internally, the value will be stored as decimal number. For instance, the C++ integer literal 010 will be serialized to 8 . During deserialization, leading zeros yield an error. Not-a-number (NaN) values will be serialized to null . Limits \u00b6 RFC 7159 specifies: An implementation may set limits on the range and precision of numbers. When the default type is used, the maximal integer number that can be stored is 9223372036854775807 (INT64_MAX) and the minimal integer number that can be stored is -9223372036854775808 (INT64_MIN). Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will be automatically be stored as number_unsigned_t or number_float_t . RFC 7159 further states: Note that when such software is used, numbers that are integers and are in the range \\f [-2^{53}+1, 2^{53}-1]\\f [-2^{53}+1, 2^{53}-1]\\f are interoperable in the sense that implementations will agree exactly on their numeric values. As this range is a subrange of the exactly supported range [INT64_MIN, INT64_MAX], this class's integer type is interoperable. Storage \u00b6 Integer number values are stored directly inside a basic_json type. Version history \u00b6 Added in version 1.0.0.","title":"basic_json::number_integer_t"},{"location":"api/basic_json/number_integer_t/#basic_jsonnumber_integer_t","text":"using number_integer_t = NumberIntegerType ; The type used to store JSON numbers (integers). RFC 7159 describes numbers as follows: The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted. This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer or a floating-point number. Therefore, three different types, number_integer_t , number_unsigned_t and number_float_t are used. To store integer numbers in C++, a type is defined by the template parameter NumberIntegerType which chooses the type to use.","title":"basic_json::number_integer_t"},{"location":"api/basic_json/number_integer_t/#notes","text":"","title":"Notes"},{"location":"api/basic_json/number_integer_t/#default-type","text":"With the default values for NumberIntegerType ( std::int64_t ), the default value for number_integer_t is std :: int64_t .","title":"Default type"},{"location":"api/basic_json/number_integer_t/#default-behavior","text":"The restrictions about leading zeros is not enforced in C++. Instead, leading zeros in integer literals lead to an interpretation as octal number. Internally, the value will be stored as decimal number. For instance, the C++ integer literal 010 will be serialized to 8 . During deserialization, leading zeros yield an error. Not-a-number (NaN) values will be serialized to null .","title":"Default behavior"},{"location":"api/basic_json/number_integer_t/#limits","text":"RFC 7159 specifies: An implementation may set limits on the range and precision of numbers. When the default type is used, the maximal integer number that can be stored is 9223372036854775807 (INT64_MAX) and the minimal integer number that can be stored is -9223372036854775808 (INT64_MIN). Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will be automatically be stored as number_unsigned_t or number_float_t . RFC 7159 further states: Note that when such software is used, numbers that are integers and are in the range \\f [-2^{53}+1, 2^{53}-1]\\f [-2^{53}+1, 2^{53}-1]\\f are interoperable in the sense that implementations will agree exactly on their numeric values. As this range is a subrange of the exactly supported range [INT64_MIN, INT64_MAX], this class's integer type is interoperable.","title":"Limits"},{"location":"api/basic_json/number_integer_t/#storage","text":"Integer number values are stored directly inside a basic_json type.","title":"Storage"},{"location":"api/basic_json/number_integer_t/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/number_unsigned_t/","text":"basic_json::number_unsigned_t \u00b6 using number_unsigned_t = NumberUnsignedType ; The type used to store JSON numbers (unsigned). RFC 7159 describes numbers as follows: The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted. This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer or a floating-point number. Therefore, three different types, number_integer_t , number_unsigned_t and number_float_t are used. To store unsigned integer numbers in C++, a type is defined by the template parameter NumberUnsignedType which chooses the type to use. Notes \u00b6 Default type \u00b6 With the default values for NumberUnsignedType ( std::uint64_t ), the default value for number_unsigned_t is std :: uint64_t . Default behavior \u00b6 The restrictions about leading zeros is not enforced in C++. Instead, leading zeros in integer literals lead to an interpretation as octal number. Internally, the value will be stored as decimal number. For instance, the C++ integer literal 010 will be serialized to 8 . During deserialization, leading zeros yield an error. Not-a-number (NaN) values will be serialized to null . Limits \u00b6 RFC 7159 specifies: An implementation may set limits on the range and precision of numbers. When the default type is used, the maximal integer number that can be stored is 18446744073709551615 (UINT64_MAX) and the minimal integer number that can be stored is 0 . Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will be automatically be stored as number_integer_t or number_float_t . RFC 7159 further states: Note that when such software is used, numbers that are integers and are in the range \\f [-2^{53}+1, 2^{53}-1]\\f [-2^{53}+1, 2^{53}-1]\\f are interoperable in the sense that implementations will agree exactly on their numeric values. As this range is a subrange (when considered in conjunction with the number_integer_t type) of the exactly supported range [0, UINT64_MAX], this class's integer type is interoperable. Storage \u00b6 Integer number values are stored directly inside a basic_json type. Version history \u00b6 Added in version 2.0.0.","title":"basic_json::number_unsigned_t"},{"location":"api/basic_json/number_unsigned_t/#basic_jsonnumber_unsigned_t","text":"using number_unsigned_t = NumberUnsignedType ; The type used to store JSON numbers (unsigned). RFC 7159 describes numbers as follows: The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted. This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer or a floating-point number. Therefore, three different types, number_integer_t , number_unsigned_t and number_float_t are used. To store unsigned integer numbers in C++, a type is defined by the template parameter NumberUnsignedType which chooses the type to use.","title":"basic_json::number_unsigned_t"},{"location":"api/basic_json/number_unsigned_t/#notes","text":"","title":"Notes"},{"location":"api/basic_json/number_unsigned_t/#default-type","text":"With the default values for NumberUnsignedType ( std::uint64_t ), the default value for number_unsigned_t is std :: uint64_t .","title":"Default type"},{"location":"api/basic_json/number_unsigned_t/#default-behavior","text":"The restrictions about leading zeros is not enforced in C++. Instead, leading zeros in integer literals lead to an interpretation as octal number. Internally, the value will be stored as decimal number. For instance, the C++ integer literal 010 will be serialized to 8 . During deserialization, leading zeros yield an error. Not-a-number (NaN) values will be serialized to null .","title":"Default behavior"},{"location":"api/basic_json/number_unsigned_t/#limits","text":"RFC 7159 specifies: An implementation may set limits on the range and precision of numbers. When the default type is used, the maximal integer number that can be stored is 18446744073709551615 (UINT64_MAX) and the minimal integer number that can be stored is 0 . Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will be automatically be stored as number_integer_t or number_float_t . RFC 7159 further states: Note that when such software is used, numbers that are integers and are in the range \\f [-2^{53}+1, 2^{53}-1]\\f [-2^{53}+1, 2^{53}-1]\\f are interoperable in the sense that implementations will agree exactly on their numeric values. As this range is a subrange (when considered in conjunction with the number_integer_t type) of the exactly supported range [0, UINT64_MAX], this class's integer type is interoperable.","title":"Limits"},{"location":"api/basic_json/number_unsigned_t/#storage","text":"Integer number values are stored directly inside a basic_json type.","title":"Storage"},{"location":"api/basic_json/number_unsigned_t/#version-history","text":"Added in version 2.0.0.","title":"Version history"},{"location":"api/basic_json/object/","text":"basic_json::object \u00b6 static basic_json object ( initializer_list_t init = {}); Creates a JSON object value from a given initializer list. The initializer lists elements must be pairs, and their first elements must be strings. If the initializer list is empty, the empty object {} is created. Parameters \u00b6 init (in) initializer list with JSON values to create an object from (optional) Return value \u00b6 JSON object value Exceptions \u00b6 Throws type_error.301 if init is not a list of pairs whose first elements are strings. In this case, no object can be created. When such a value is passed to basic_json(initializer_list_t, bool, value_t) , an array would have been created from the passed initializer list init . See example below. Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Linear in the size of init . Notes \u00b6 This function is only added for symmetry reasons. In contrast to the related function array(initializer_list_t) , there are no cases which can only be expressed by this function. That is, any initializer list init can also be passed to the initializer list constructor basic_json(initializer_list_t, bool, value_t) . Examples \u00b6 Example The following code shows an example for the object function. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON objects json j_no_init_list = json :: object (); json j_empty_init_list = json :: object ({}); json j_list_of_pairs = json :: object ({ { \"one\" , 1 }, { \"two\" , 2 } }); // serialize the JSON objects std :: cout << j_no_init_list << '\\n' ; std :: cout << j_empty_init_list << '\\n' ; std :: cout << j_list_of_pairs << '\\n' ; // example for an exception try { // can only create an object from a list of pairs json j_invalid_object = json :: object ({{ \"one\" , 1 , 2 }}); } catch ( json :: type_error & e ) { std :: cout << e . what () << '\\n' ; } } Output: {} {} { \"one\" : 1 , \"two\" : 2 } [ json.exception.type_error. 301 ] cannot create object from initializer list Version history \u00b6 Added in version 1.0.0.","title":"basic_json::object"},{"location":"api/basic_json/object/#basic_jsonobject","text":"static basic_json object ( initializer_list_t init = {}); Creates a JSON object value from a given initializer list. The initializer lists elements must be pairs, and their first elements must be strings. If the initializer list is empty, the empty object {} is created.","title":"basic_json::object"},{"location":"api/basic_json/object/#parameters","text":"init (in) initializer list with JSON values to create an object from (optional)","title":"Parameters"},{"location":"api/basic_json/object/#return-value","text":"JSON object value","title":"Return value"},{"location":"api/basic_json/object/#exceptions","text":"Throws type_error.301 if init is not a list of pairs whose first elements are strings. In this case, no object can be created. When such a value is passed to basic_json(initializer_list_t, bool, value_t) , an array would have been created from the passed initializer list init . See example below.","title":"Exceptions"},{"location":"api/basic_json/object/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/object/#complexity","text":"Linear in the size of init .","title":"Complexity"},{"location":"api/basic_json/object/#notes","text":"This function is only added for symmetry reasons. In contrast to the related function array(initializer_list_t) , there are no cases which can only be expressed by this function. That is, any initializer list init can also be passed to the initializer list constructor basic_json(initializer_list_t, bool, value_t) .","title":"Notes"},{"location":"api/basic_json/object/#examples","text":"Example The following code shows an example for the object function. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON objects json j_no_init_list = json :: object (); json j_empty_init_list = json :: object ({}); json j_list_of_pairs = json :: object ({ { \"one\" , 1 }, { \"two\" , 2 } }); // serialize the JSON objects std :: cout << j_no_init_list << '\\n' ; std :: cout << j_empty_init_list << '\\n' ; std :: cout << j_list_of_pairs << '\\n' ; // example for an exception try { // can only create an object from a list of pairs json j_invalid_object = json :: object ({{ \"one\" , 1 , 2 }}); } catch ( json :: type_error & e ) { std :: cout << e . what () << '\\n' ; } } Output: {} {} { \"one\" : 1 , \"two\" : 2 } [ json.exception.type_error. 301 ] cannot create object from initializer list","title":"Examples"},{"location":"api/basic_json/object/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/object_t/","text":"basic_json::object_t \u00b6 using object_t = ObjectType < StringType , basic_json , object_comparator_t , AllocatorType < std :: pair < const StringType , basic_json >>> ; The type used to store JSON objects. RFC 7159 describes JSON objects as follows: An object is an unordered collection of zero or more name/value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array. To store objects in C++, a type is defined by the template parameters described below. Template parameters \u00b6 ObjectType the container to store objects (e.g., std::map or std::unordered_map ) StringType the type of the keys or names (e.g., std::string ). The comparison function std::less<StringType> is used to order elements inside the container. AllocatorType the allocator to use for objects (e.g., std::allocator ) Notes \u00b6 Default type \u00b6 With the default values for ObjectType ( std::map ), StringType ( std::string ), and AllocatorType ( std::allocator ), the default value for object_t is: std :: map < std :: string , // key_type basic_json , // value_type std :: less < std :: string > , // key_compare std :: allocator < std :: pair < const std :: string , basic_json >> // allocator_type > Behavior \u00b6 The choice of object_t influences the behavior of the JSON class. With the default type, objects have the following behavior: When all names are unique, objects will be interoperable in the sense that all software implementations receiving that object will agree on the name-value mappings. When the names within an object are not unique, it is unspecified which one of the values for a given key will be chosen. For instance, { \"key\" : 2 , \"key\" : 1 } could be equal to either { \"key\" : 1 } or { \"key\" : 2 } . Internally, name/value pairs are stored in lexicographical order of the names. Objects will also be serialized (see dump ) in this order. For instance, { \"b\" : 1 , \"a\" : 2 } and { \"a\" : 2 , \"b\" : 1 } will be stored and serialized as { \"a\" : 2 , \"b\" : 1 } . When comparing objects, the order of the name/value pairs is irrelevant. This makes objects interoperable in the sense that they will not be affected by these differences. For instance, { \"b\" : 1 , \"a\" : 2 } and { \"a\" : 2 , \"b\" : 1 } will be treated as equal. Limits \u00b6 RFC 7159 specifies: An implementation may set limits on the maximum depth of nesting. In this class, the object's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the max_size function of a JSON object. Storage \u00b6 Objects are stored as pointers in a basic_json type. That is, for any access to object values, a pointer of type object_t* must be dereferenced. Object key order \u00b6 The order name/value pairs are added to the object is not preserved by the library. Therefore, iterating an object may return name/value pairs in a different order than they were originally stored. In fact, keys will be traversed in alphabetical order as std::map with std::less is used by default. Please note this behavior conforms to RFC 7159 , because any order implements the specified \"unordered\" nature of JSON objects. Version history \u00b6 Added in version 1.0.0.","title":"basic_json::object_t"},{"location":"api/basic_json/object_t/#basic_jsonobject_t","text":"using object_t = ObjectType < StringType , basic_json , object_comparator_t , AllocatorType < std :: pair < const StringType , basic_json >>> ; The type used to store JSON objects. RFC 7159 describes JSON objects as follows: An object is an unordered collection of zero or more name/value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array. To store objects in C++, a type is defined by the template parameters described below.","title":"basic_json::object_t"},{"location":"api/basic_json/object_t/#template-parameters","text":"ObjectType the container to store objects (e.g., std::map or std::unordered_map ) StringType the type of the keys or names (e.g., std::string ). The comparison function std::less<StringType> is used to order elements inside the container. AllocatorType the allocator to use for objects (e.g., std::allocator )","title":"Template parameters"},{"location":"api/basic_json/object_t/#notes","text":"","title":"Notes"},{"location":"api/basic_json/object_t/#default-type","text":"With the default values for ObjectType ( std::map ), StringType ( std::string ), and AllocatorType ( std::allocator ), the default value for object_t is: std :: map < std :: string , // key_type basic_json , // value_type std :: less < std :: string > , // key_compare std :: allocator < std :: pair < const std :: string , basic_json >> // allocator_type >","title":"Default type"},{"location":"api/basic_json/object_t/#behavior","text":"The choice of object_t influences the behavior of the JSON class. With the default type, objects have the following behavior: When all names are unique, objects will be interoperable in the sense that all software implementations receiving that object will agree on the name-value mappings. When the names within an object are not unique, it is unspecified which one of the values for a given key will be chosen. For instance, { \"key\" : 2 , \"key\" : 1 } could be equal to either { \"key\" : 1 } or { \"key\" : 2 } . Internally, name/value pairs are stored in lexicographical order of the names. Objects will also be serialized (see dump ) in this order. For instance, { \"b\" : 1 , \"a\" : 2 } and { \"a\" : 2 , \"b\" : 1 } will be stored and serialized as { \"a\" : 2 , \"b\" : 1 } . When comparing objects, the order of the name/value pairs is irrelevant. This makes objects interoperable in the sense that they will not be affected by these differences. For instance, { \"b\" : 1 , \"a\" : 2 } and { \"a\" : 2 , \"b\" : 1 } will be treated as equal.","title":"Behavior"},{"location":"api/basic_json/object_t/#limits","text":"RFC 7159 specifies: An implementation may set limits on the maximum depth of nesting. In this class, the object's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the max_size function of a JSON object.","title":"Limits"},{"location":"api/basic_json/object_t/#storage","text":"Objects are stored as pointers in a basic_json type. That is, for any access to object values, a pointer of type object_t* must be dereferenced.","title":"Storage"},{"location":"api/basic_json/object_t/#object-key-order","text":"The order name/value pairs are added to the object is not preserved by the library. Therefore, iterating an object may return name/value pairs in a different order than they were originally stored. In fact, keys will be traversed in alphabetical order as std::map with std::less is used by default. Please note this behavior conforms to RFC 7159 , because any order implements the specified \"unordered\" nature of JSON objects.","title":"Object key order"},{"location":"api/basic_json/object_t/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/operator%21%3D/","text":"basic_json::operator!= \u00b6 bool operator != ( const_reference lhs , const_reference rhs ) noexcept ; template < typename ScalarType > bool operator != ( const_reference lhs , const ScalarType rhs ) noexcept ; template < typename ScalarType > bool operator != ( ScalarType lhs , const const_reference rhs ) noexcept ; Compares two JSON values for inequality by calculating ! ( lhs == rhs ) . Template parameters \u00b6 ScalarType a scalar type according to std::is_scalar<ScalarType>::value Parameters \u00b6 lhs (in) first value to consider rhs (in) second value to consider Return value \u00b6 whether the values lhs and rhs are not equal Exception safety \u00b6 No-throw guarantee: this function never throws exceptions. Complexity \u00b6 Linear. Example \u00b6 The example demonstrates comparing several JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create several JSON values json array_1 = { 1 , 2 , 3 }; json array_2 = { 1 , 2 , 4 }; json object_1 = {{ \"A\" , \"a\" }, { \"B\" , \"b\" }}; json object_2 = {{ \"B\" , \"b\" }, { \"A\" , \"a\" }}; json number_1 = 17 ; json number_2 = 17.000000000000001 L ; json string_1 = \"foo\" ; json string_2 = \"bar\" ; // output values and comparisons std :: cout << std :: boolalpha ; std :: cout << array_1 << \" != \" << array_2 << \" \" << ( array_1 != array_2 ) << '\\n' ; std :: cout << object_1 << \" != \" << object_2 << \" \" << ( object_1 != object_2 ) << '\\n' ; std :: cout << number_1 << \" != \" << number_2 << \" \" << ( number_1 != number_2 ) << '\\n' ; std :: cout << string_1 << \" != \" << string_2 << \" \" << ( string_1 != string_2 ) << '\\n' ; } Output: [ 1 , 2 , 3 ] != [ 1 , 2 , 4 ] true { \"A\" : \"a\" , \"B\" : \"b\" } != { \"A\" : \"a\" , \"B\" : \"b\" } false 17 != 17.0 false \"foo\" != \"bar\" true Version history \u00b6 Added in version 1.0.0.","title":"basic_json::operator!="},{"location":"api/basic_json/operator%21%3D/#basic_jsonoperator","text":"bool operator != ( const_reference lhs , const_reference rhs ) noexcept ; template < typename ScalarType > bool operator != ( const_reference lhs , const ScalarType rhs ) noexcept ; template < typename ScalarType > bool operator != ( ScalarType lhs , const const_reference rhs ) noexcept ; Compares two JSON values for inequality by calculating ! ( lhs == rhs ) .","title":"basic_json::operator!="},{"location":"api/basic_json/operator%21%3D/#template-parameters","text":"ScalarType a scalar type according to std::is_scalar<ScalarType>::value","title":"Template parameters"},{"location":"api/basic_json/operator%21%3D/#parameters","text":"lhs (in) first value to consider rhs (in) second value to consider","title":"Parameters"},{"location":"api/basic_json/operator%21%3D/#return-value","text":"whether the values lhs and rhs are not equal","title":"Return value"},{"location":"api/basic_json/operator%21%3D/#exception-safety","text":"No-throw guarantee: this function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/operator%21%3D/#complexity","text":"Linear.","title":"Complexity"},{"location":"api/basic_json/operator%21%3D/#example","text":"The example demonstrates comparing several JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create several JSON values json array_1 = { 1 , 2 , 3 }; json array_2 = { 1 , 2 , 4 }; json object_1 = {{ \"A\" , \"a\" }, { \"B\" , \"b\" }}; json object_2 = {{ \"B\" , \"b\" }, { \"A\" , \"a\" }}; json number_1 = 17 ; json number_2 = 17.000000000000001 L ; json string_1 = \"foo\" ; json string_2 = \"bar\" ; // output values and comparisons std :: cout << std :: boolalpha ; std :: cout << array_1 << \" != \" << array_2 << \" \" << ( array_1 != array_2 ) << '\\n' ; std :: cout << object_1 << \" != \" << object_2 << \" \" << ( object_1 != object_2 ) << '\\n' ; std :: cout << number_1 << \" != \" << number_2 << \" \" << ( number_1 != number_2 ) << '\\n' ; std :: cout << string_1 << \" != \" << string_2 << \" \" << ( string_1 != string_2 ) << '\\n' ; } Output: [ 1 , 2 , 3 ] != [ 1 , 2 , 4 ] true { \"A\" : \"a\" , \"B\" : \"b\" } != { \"A\" : \"a\" , \"B\" : \"b\" } false 17 != 17.0 false \"foo\" != \"bar\" true","title":"Example"},{"location":"api/basic_json/operator%21%3D/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/operator%2B%3D/","text":"basic_json::operator+= \u00b6 // (1) reference operator += ( basic_json && val ); reference operator += ( const basic_json & val ); // (2) reference operator += ( const typename object_t :: value_type & val ); // (3) reference operator += ( initializer_list_t init ); Appends the given element val to the end of the JSON array. If the function is called on a JSON null value, an empty array is created before appending val . Inserts the given element val to the JSON object. If the function is called on a JSON null value, an empty object is created before inserting val . This function allows to use operator+= with an initializer list. In case the current value is an object, the initializer list init contains only two elements, and the first element of init is a string, init is converted into an object element and added using operator+=(const typename object_t::value_type&) . Otherwise, init is converted to a JSON value and added using operator+=(basic_json&&) . Parameters \u00b6 val (in) the value to add to the JSON array/object init (in) an initializer list Return value \u00b6 * this Exceptions \u00b6 The function can throw the following exceptions: Throws type_error.308 when called on a type other than JSON array or null; example: \"cannot use operator+=() with number\" The function can throw the following exceptions: Throws type_error.308 when called on a type other than JSON object or null; example: \"cannot use operator+=() with number\" Complexity \u00b6 Amortized constant. Logarithmic in the size of the container, O(log( size() )). Linear in the size of the initializer list init . Notes \u00b6 (3) This function is required to resolve an ambiguous overload error, because pairs like {\"key\", \"value\"} can be both interpreted as object_t::value_type or std::initializer_list<basic_json> , see #235 for more information. Examples \u00b6 Example The example shows how push_back() and += can be used to add elements to a JSON array. Note how the null value was silently converted to a JSON array. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json array = { 1 , 2 , 3 , 4 , 5 }; json null ; // print values std :: cout << array << '\\n' ; std :: cout << null << '\\n' ; // add values array . push_back ( 6 ); array += 7 ; null += \"first\" ; null += \"second\" ; // print values std :: cout << array << '\\n' ; std :: cout << null << '\\n' ; } Output: [ 1 , 2 , 3 , 4 , 5 ] null [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] [ \"first\" , \"second\" ] Example The example shows how push_back() and += can be used to add elements to a JSON object. Note how the null value was silently converted to a JSON object. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json null ; // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; // add values object . push_back ( json :: object_t :: value_type ( \"three\" , 3 )); object += json :: object_t :: value_type ( \"four\" , 4 ); null += json :: object_t :: value_type ( \"A\" , \"a\" ); null += json :: object_t :: value_type ( \"B\" , \"b\" ); // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; } Output: { \"one\" : 1 , \"two\" : 2 } null { \"four\" : 4 , \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } { \"A\" : \"a\" , \"B\" : \"b\" } Example The example shows how initializer lists are treated as objects when possible. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json null ; // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; // add values: object . push_back ({ \"three\" , 3 }); // object is extended object += { \"four\" , 4 }; // object is extended null . push_back ({ \"five\" , 5 }); // null is converted to array // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; // would throw: //object.push_back({1, 2, 3}); } Output: { \"one\" : 1 , \"two\" : 2 } null { \"four\" : 4 , \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } [[ \"five\" , 5 ]] Version history \u00b6 Since version 1.0.0. Since version 1.0.0. Since version 2.0.0.","title":"basic_json::operator+="},{"location":"api/basic_json/operator%2B%3D/#basic_jsonoperator","text":"// (1) reference operator += ( basic_json && val ); reference operator += ( const basic_json & val ); // (2) reference operator += ( const typename object_t :: value_type & val ); // (3) reference operator += ( initializer_list_t init ); Appends the given element val to the end of the JSON array. If the function is called on a JSON null value, an empty array is created before appending val . Inserts the given element val to the JSON object. If the function is called on a JSON null value, an empty object is created before inserting val . This function allows to use operator+= with an initializer list. In case the current value is an object, the initializer list init contains only two elements, and the first element of init is a string, init is converted into an object element and added using operator+=(const typename object_t::value_type&) . Otherwise, init is converted to a JSON value and added using operator+=(basic_json&&) .","title":"basic_json::operator+="},{"location":"api/basic_json/operator%2B%3D/#parameters","text":"val (in) the value to add to the JSON array/object init (in) an initializer list","title":"Parameters"},{"location":"api/basic_json/operator%2B%3D/#return-value","text":"* this","title":"Return value"},{"location":"api/basic_json/operator%2B%3D/#exceptions","text":"The function can throw the following exceptions: Throws type_error.308 when called on a type other than JSON array or null; example: \"cannot use operator+=() with number\" The function can throw the following exceptions: Throws type_error.308 when called on a type other than JSON object or null; example: \"cannot use operator+=() with number\"","title":"Exceptions"},{"location":"api/basic_json/operator%2B%3D/#complexity","text":"Amortized constant. Logarithmic in the size of the container, O(log( size() )). Linear in the size of the initializer list init .","title":"Complexity"},{"location":"api/basic_json/operator%2B%3D/#notes","text":"(3) This function is required to resolve an ambiguous overload error, because pairs like {\"key\", \"value\"} can be both interpreted as object_t::value_type or std::initializer_list<basic_json> , see #235 for more information.","title":"Notes"},{"location":"api/basic_json/operator%2B%3D/#examples","text":"Example The example shows how push_back() and += can be used to add elements to a JSON array. Note how the null value was silently converted to a JSON array. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json array = { 1 , 2 , 3 , 4 , 5 }; json null ; // print values std :: cout << array << '\\n' ; std :: cout << null << '\\n' ; // add values array . push_back ( 6 ); array += 7 ; null += \"first\" ; null += \"second\" ; // print values std :: cout << array << '\\n' ; std :: cout << null << '\\n' ; } Output: [ 1 , 2 , 3 , 4 , 5 ] null [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] [ \"first\" , \"second\" ] Example The example shows how push_back() and += can be used to add elements to a JSON object. Note how the null value was silently converted to a JSON object. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json null ; // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; // add values object . push_back ( json :: object_t :: value_type ( \"three\" , 3 )); object += json :: object_t :: value_type ( \"four\" , 4 ); null += json :: object_t :: value_type ( \"A\" , \"a\" ); null += json :: object_t :: value_type ( \"B\" , \"b\" ); // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; } Output: { \"one\" : 1 , \"two\" : 2 } null { \"four\" : 4 , \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } { \"A\" : \"a\" , \"B\" : \"b\" } Example The example shows how initializer lists are treated as objects when possible. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json null ; // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; // add values: object . push_back ({ \"three\" , 3 }); // object is extended object += { \"four\" , 4 }; // object is extended null . push_back ({ \"five\" , 5 }); // null is converted to array // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; // would throw: //object.push_back({1, 2, 3}); } Output: { \"one\" : 1 , \"two\" : 2 } null { \"four\" : 4 , \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } [[ \"five\" , 5 ]]","title":"Examples"},{"location":"api/basic_json/operator%2B%3D/#version-history","text":"Since version 1.0.0. Since version 1.0.0. Since version 2.0.0.","title":"Version history"},{"location":"api/basic_json/operator%3D/","text":"basic_json::operator= \u00b6 basic_json & operator = ( basic_json other ) noexcept ( std :: is_nothrow_move_constructible < value_t >:: value && std :: is_nothrow_move_assignable < value_t >:: value && std :: is_nothrow_move_constructible < json_value >:: value && std :: is_nothrow_move_assignable < json_value >:: value ); Copy assignment operator. Copies a JSON value via the \"copy and swap\" strategy: It is expressed in terms of the copy constructor, destructor, and the swap() member function. Parameters \u00b6 other (in) value to copy from Complexity \u00b6 Linear. Example \u00b6 Example The code below shows and example for the copy assignment. It creates a copy of value a which is then swapped with b . Finally, the copy of a (which is the null value after the swap) is destroyed. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json a = 23 ; json b = 42 ; // copy-assign a to b b = a ; // serialize the JSON arrays std :: cout << a << '\\n' ; std :: cout << b << '\\n' ; } Output: 23 23 Version history \u00b6 Added in version 1.0.0.","title":"basic_json::operator="},{"location":"api/basic_json/operator%3D/#basic_jsonoperator","text":"basic_json & operator = ( basic_json other ) noexcept ( std :: is_nothrow_move_constructible < value_t >:: value && std :: is_nothrow_move_assignable < value_t >:: value && std :: is_nothrow_move_constructible < json_value >:: value && std :: is_nothrow_move_assignable < json_value >:: value ); Copy assignment operator. Copies a JSON value via the \"copy and swap\" strategy: It is expressed in terms of the copy constructor, destructor, and the swap() member function.","title":"basic_json::operator="},{"location":"api/basic_json/operator%3D/#parameters","text":"other (in) value to copy from","title":"Parameters"},{"location":"api/basic_json/operator%3D/#complexity","text":"Linear.","title":"Complexity"},{"location":"api/basic_json/operator%3D/#example","text":"Example The code below shows and example for the copy assignment. It creates a copy of value a which is then swapped with b . Finally, the copy of a (which is the null value after the swap) is destroyed. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json a = 23 ; json b = 42 ; // copy-assign a to b b = a ; // serialize the JSON arrays std :: cout << a << '\\n' ; std :: cout << b << '\\n' ; } Output: 23 23","title":"Example"},{"location":"api/basic_json/operator%3D/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/operator%3D%3D/","text":"basic_json::operator== \u00b6 bool operator == ( const_reference lhs , const_reference rhs ) noexcept ; template < typename ScalarType > bool operator == ( const_reference lhs , const ScalarType rhs ) noexcept ; template < typename ScalarType > bool operator == ( ScalarType lhs , const const_reference rhs ) noexcept ; Compares two JSON values for equality according to the following rules: Two JSON values are equal if (1) they are from the same type and (2) their stored values are the same according to their respective operator== . Integer and floating-point numbers are automatically converted before comparison. Note that two NaN values are always treated as unequal. Two JSON null values are equal. Template parameters \u00b6 ScalarType a scalar type according to std::is_scalar<ScalarType>::value Parameters \u00b6 lhs (in) first value to consider rhs (in) second value to consider Return value \u00b6 whether the values lhs and rhs are equal Exception safety \u00b6 No-throw guarantee: this function never throws exceptions. Complexity \u00b6 Linear. Notes \u00b6 Floating-point inside JSON values numbers are compared with json::number_float_t::operator== which is double::operator== by default. To compare floating-point while respecting an epsilon, an alternative comparison function could be used, for instance template < typename T , typename = typename std :: enable_if < std :: is_floating_point < T >:: value , T >:: type > inline bool is_same ( T a , T b , T epsilon = std :: numeric_limits < T >:: epsilon ()) noexcept { return std :: abs ( a - b ) <= epsilon ; } Or you can self-defined operator equal function like this: bool my_equal ( const_reference lhs , const_reference rhs ) { const auto lhs_type lhs . type (); const auto rhs_type rhs . type (); if ( lhs_type == rhs_type ) { switch ( lhs_type ) // self_defined case case value_t :: number_float : return std :: abs ( lhs - rhs ) <= std :: numeric_limits < float >:: epsilon (); // other cases remain the same with the original ... } ... } NaN values never compare equal to themselves or to other NaN values. Example \u00b6 Example The example demonstrates comparing several JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create several JSON values json array_1 = { 1 , 2 , 3 }; json array_2 = { 1 , 2 , 4 }; json object_1 = {{ \"A\" , \"a\" }, { \"B\" , \"b\" }}; json object_2 = {{ \"B\" , \"b\" }, { \"A\" , \"a\" }}; json number_1 = 17 ; json number_2 = 17.000000000000001 L ; json string_1 = \"foo\" ; json string_2 = \"bar\" ; // output values and comparisons std :: cout << std :: boolalpha ; std :: cout << array_1 << \" == \" << array_2 << \" \" << ( array_1 == array_2 ) << '\\n' ; std :: cout << object_1 << \" == \" << object_2 << \" \" << ( object_1 == object_2 ) << '\\n' ; std :: cout << number_1 << \" == \" << number_2 << \" \" << ( number_1 == number_2 ) << '\\n' ; std :: cout << string_1 << \" == \" << string_2 << \" \" << ( string_1 == string_2 ) << '\\n' ; } Output: [ 1 , 2 , 3 ] == [ 1 , 2 , 4 ] false { \"A\" : \"a\" , \"B\" : \"b\" } == { \"A\" : \"a\" , \"B\" : \"b\" } true 17 == 17.0 true \"foo\" == \"bar\" false Version history \u00b6 Added in version 1.0.0.","title":"basic_json::operator=="},{"location":"api/basic_json/operator%3D%3D/#basic_jsonoperator","text":"bool operator == ( const_reference lhs , const_reference rhs ) noexcept ; template < typename ScalarType > bool operator == ( const_reference lhs , const ScalarType rhs ) noexcept ; template < typename ScalarType > bool operator == ( ScalarType lhs , const const_reference rhs ) noexcept ; Compares two JSON values for equality according to the following rules: Two JSON values are equal if (1) they are from the same type and (2) their stored values are the same according to their respective operator== . Integer and floating-point numbers are automatically converted before comparison. Note that two NaN values are always treated as unequal. Two JSON null values are equal.","title":"basic_json::operator=="},{"location":"api/basic_json/operator%3D%3D/#template-parameters","text":"ScalarType a scalar type according to std::is_scalar<ScalarType>::value","title":"Template parameters"},{"location":"api/basic_json/operator%3D%3D/#parameters","text":"lhs (in) first value to consider rhs (in) second value to consider","title":"Parameters"},{"location":"api/basic_json/operator%3D%3D/#return-value","text":"whether the values lhs and rhs are equal","title":"Return value"},{"location":"api/basic_json/operator%3D%3D/#exception-safety","text":"No-throw guarantee: this function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/operator%3D%3D/#complexity","text":"Linear.","title":"Complexity"},{"location":"api/basic_json/operator%3D%3D/#notes","text":"Floating-point inside JSON values numbers are compared with json::number_float_t::operator== which is double::operator== by default. To compare floating-point while respecting an epsilon, an alternative comparison function could be used, for instance template < typename T , typename = typename std :: enable_if < std :: is_floating_point < T >:: value , T >:: type > inline bool is_same ( T a , T b , T epsilon = std :: numeric_limits < T >:: epsilon ()) noexcept { return std :: abs ( a - b ) <= epsilon ; } Or you can self-defined operator equal function like this: bool my_equal ( const_reference lhs , const_reference rhs ) { const auto lhs_type lhs . type (); const auto rhs_type rhs . type (); if ( lhs_type == rhs_type ) { switch ( lhs_type ) // self_defined case case value_t :: number_float : return std :: abs ( lhs - rhs ) <= std :: numeric_limits < float >:: epsilon (); // other cases remain the same with the original ... } ... } NaN values never compare equal to themselves or to other NaN values.","title":"Notes"},{"location":"api/basic_json/operator%3D%3D/#example","text":"Example The example demonstrates comparing several JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create several JSON values json array_1 = { 1 , 2 , 3 }; json array_2 = { 1 , 2 , 4 }; json object_1 = {{ \"A\" , \"a\" }, { \"B\" , \"b\" }}; json object_2 = {{ \"B\" , \"b\" }, { \"A\" , \"a\" }}; json number_1 = 17 ; json number_2 = 17.000000000000001 L ; json string_1 = \"foo\" ; json string_2 = \"bar\" ; // output values and comparisons std :: cout << std :: boolalpha ; std :: cout << array_1 << \" == \" << array_2 << \" \" << ( array_1 == array_2 ) << '\\n' ; std :: cout << object_1 << \" == \" << object_2 << \" \" << ( object_1 == object_2 ) << '\\n' ; std :: cout << number_1 << \" == \" << number_2 << \" \" << ( number_1 == number_2 ) << '\\n' ; std :: cout << string_1 << \" == \" << string_2 << \" \" << ( string_1 == string_2 ) << '\\n' ; } Output: [ 1 , 2 , 3 ] == [ 1 , 2 , 4 ] false { \"A\" : \"a\" , \"B\" : \"b\" } == { \"A\" : \"a\" , \"B\" : \"b\" } true 17 == 17.0 true \"foo\" == \"bar\" false","title":"Example"},{"location":"api/basic_json/operator%3D%3D/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/operator%5B%5D/","text":"basic_json::operator[] \u00b6 // (1) reference operator []( size_type idx ); const_reference operator []( size_type idx ) const ; // (2) reference operator []( const typename object_t :: key_type & key ); const_reference operator []( const typename object_t :: key_type & key ) const ; template < typename T > reference operator []( T * key ); template < typename T > const_reference operator []( T * key ) const ; // (3) reference operator []( const json_pointer & ptr ); const_reference operator []( const json_pointer & ptr ) const ; Returns a reference to the element at specified location idx . Returns a reference to the element at with specified key key . Returns a reference to the element at with specified JSON pointer ptr . Template parameters \u00b6 T string literal convertible to object_t::key_type Parameters \u00b6 idx (in) index of the element to access key (in) object key of the elements to remove ptr (in) JSON pointer to the desired element Return value \u00b6 reference to the element at index idx reference to the element at key key reference to the element pointed to by ptr Exceptions \u00b6 The function can throw the following exceptions: Throws type_error.305 if the JSON value is not an array or null; in that cases, using the [] operator with an index makes no sense. The function can throw the following exceptions: Throws type_error.305 if the JSON value is not an array or null; in that cases, using the [] operator with an index makes no sense. The function can throw the following exceptions: Throws parse_error.106 if an array index in the passed JSON pointer ptr begins with '0'. Throws parse_error.109 if an array index in the passed JSON pointer ptr is not a number. Throws out_of_range.402 if the array index '-' is used in the passed JSON pointer ptr for the const version. Throws out_of_range.404 if the JSON pointer ptr can not be resolved. Notes \u00b6 Danger If the element with key idx does not exist, the behavior is undefined. If the element with key key does not exist, the behavior is undefined and is guarded by an assertion ! The non-const version may add values: If idx is beyond the range of the array (i.e., idx >= size() ), then the array is silently filled up with null values to make idx a valid reference to the last stored element. In case the value was null before, it is converted to an array. If key is not found in the object, then it is silently added to the object and filled with a null value to make key a valid reference. In case the value was null before, it is converted to an object. null values are created in arrays and objects if necessary. In particular: If the JSON pointer points to an object key that does not exist, it is created an filled with a null value before a reference to it is returned. If the JSON pointer points to an array index that does not exist, it is created an filled with a null value before a reference to it is returned. All indices between the current maximum and the given index are also filled with null . The special value - is treated as a synonym for the index past the end. Exception safety \u00b6 Strong exception safety: if an exception occurs, the original value stays intact. Complexity \u00b6 Constant if idx is in the range of the array. Otherwise linear in idx - size() . Logarithmic in the size of the container. Constant Example \u00b6 Example The example below shows how array elements can be read and written using [] operator. Note the addition of null values. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON array json array = { 1 , 2 , 3 , 4 , 5 }; // output element at index 3 (fourth element) std :: cout << array [ 3 ] << '\\n' ; // change last element to 6 array [ array . size () - 1 ] = 6 ; // output changed array std :: cout << array << '\\n' ; // write beyond array limit array [ 10 ] = 11 ; // output changed array std :: cout << array << '\\n' ; } Output: 4 [ 1 , 2 , 3 , 4 , 6 ] [ 1 , 2 , 3 , 4 , 6 , null , null , null , null , null , 11 ] Example The example below shows how array elements can be read using the [] operator. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON array const json array = { \"first\" , \"2nd\" , \"third\" , \"fourth\" }; // output element at index 2 (third element) std :: cout << array . at ( 2 ) << '\\n' ; } Output: \"third\" Example The example below shows how object elements can be read and written using the [] operator. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON object json object = { { \"one\" , 1 }, { \"two\" , 2 }, { \"three\" , 2.9 } }; // output element with key \"two\" std :: cout << object [ \"two\" ] << \" \\n\\n \" ; // change element with key \"three\" object [ \"three\" ] = 3 ; // output changed array std :: cout << std :: setw ( 4 ) << object << \" \\n\\n \" ; // mention nonexisting key object [ \"four\" ]; // write to nonexisting key object [ \"five\" ][ \"really\" ][ \"nested\" ] = true ; // output changed object std :: cout << std :: setw ( 4 ) << object << '\\n' ; } Output: 2 { \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } { \"five\" : { \"really\" : { \"nested\" : true } }, \"four\" : null , \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } Example The example below shows how object elements can be read using the [] operator. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON object const json object = { { \"one\" , 1 }, { \"two\" , 2 }, { \"three\" , 2.9 } }; // output element with key \"two\" std :: cout << object [ \"two\" ] << '\\n' ; } Output: 2 Example The example below shows how values can be read and written using JSON Pointers. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = { { \"number\" , 1 }, { \"string\" , \"foo\" }, { \"array\" , { 1 , 2 }} }; // read-only access // output element with JSON pointer \"/number\" std :: cout << j [ \"/number\" _json_pointer ] << '\\n' ; // output element with JSON pointer \"/string\" std :: cout << j [ \"/string\" _json_pointer ] << '\\n' ; // output element with JSON pointer \"/array\" std :: cout << j [ \"/array\" _json_pointer ] << '\\n' ; // output element with JSON pointer \"/array/1\" std :: cout << j [ \"/array/1\" _json_pointer ] << '\\n' ; // writing access // change the string j [ \"/string\" _json_pointer ] = \"bar\" ; // output the changed string std :: cout << j [ \"string\" ] << '\\n' ; // \"change\" a nonexisting object entry j [ \"/boolean\" _json_pointer ] = true ; // output the changed object std :: cout << j << '\\n' ; // change an array element j [ \"/array/1\" _json_pointer ] = 21 ; // \"change\" an array element with nonexisting index j [ \"/array/4\" _json_pointer ] = 44 ; // output the changed array std :: cout << j [ \"array\" ] << '\\n' ; // \"change\" the array element past the end j [ \"/array/-\" _json_pointer ] = 55 ; // output the changed array std :: cout << j [ \"array\" ] << '\\n' ; } Output: 1 \"foo\" [ 1 , 2 ] 2 \"bar\" { \"array\" :[ 1 , 2 ], \"boolean\" : true , \"number\" : 1 , \"string\" : \"bar\" } [ 1 , 21 , null , null , 44 ] [ 1 , 21 , null , null , 44 , 55 ] Example The example below shows how values can be read using JSON Pointers. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value const json j = { { \"number\" , 1 }, { \"string\" , \"foo\" }, { \"array\" , { 1 , 2 }} }; // read-only access // output element with JSON pointer \"/number\" std :: cout << j [ \"/number\" _json_pointer ] << '\\n' ; // output element with JSON pointer \"/string\" std :: cout << j [ \"/string\" _json_pointer ] << '\\n' ; // output element with JSON pointer \"/array\" std :: cout << j [ \"/array\" _json_pointer ] << '\\n' ; // output element with JSON pointer \"/array/1\" std :: cout << j [ \"/array/1\" _json_pointer ] << '\\n' ; } Output: 1 \"foo\" [ 1 , 2 ] 2 Version history \u00b6 Added in version 1.0.0. Added in version 1.0.0. Overloads for T* key added in version 1.1.0. Added in version 2.0.0.","title":"basic_json::operator[]"},{"location":"api/basic_json/operator%5B%5D/#basic_jsonoperator","text":"// (1) reference operator []( size_type idx ); const_reference operator []( size_type idx ) const ; // (2) reference operator []( const typename object_t :: key_type & key ); const_reference operator []( const typename object_t :: key_type & key ) const ; template < typename T > reference operator []( T * key ); template < typename T > const_reference operator []( T * key ) const ; // (3) reference operator []( const json_pointer & ptr ); const_reference operator []( const json_pointer & ptr ) const ; Returns a reference to the element at specified location idx . Returns a reference to the element at with specified key key . Returns a reference to the element at with specified JSON pointer ptr .","title":"basic_json::operator[]"},{"location":"api/basic_json/operator%5B%5D/#template-parameters","text":"T string literal convertible to object_t::key_type","title":"Template parameters"},{"location":"api/basic_json/operator%5B%5D/#parameters","text":"idx (in) index of the element to access key (in) object key of the elements to remove ptr (in) JSON pointer to the desired element","title":"Parameters"},{"location":"api/basic_json/operator%5B%5D/#return-value","text":"reference to the element at index idx reference to the element at key key reference to the element pointed to by ptr","title":"Return value"},{"location":"api/basic_json/operator%5B%5D/#exceptions","text":"The function can throw the following exceptions: Throws type_error.305 if the JSON value is not an array or null; in that cases, using the [] operator with an index makes no sense. The function can throw the following exceptions: Throws type_error.305 if the JSON value is not an array or null; in that cases, using the [] operator with an index makes no sense. The function can throw the following exceptions: Throws parse_error.106 if an array index in the passed JSON pointer ptr begins with '0'. Throws parse_error.109 if an array index in the passed JSON pointer ptr is not a number. Throws out_of_range.402 if the array index '-' is used in the passed JSON pointer ptr for the const version. Throws out_of_range.404 if the JSON pointer ptr can not be resolved.","title":"Exceptions"},{"location":"api/basic_json/operator%5B%5D/#notes","text":"Danger If the element with key idx does not exist, the behavior is undefined. If the element with key key does not exist, the behavior is undefined and is guarded by an assertion ! The non-const version may add values: If idx is beyond the range of the array (i.e., idx >= size() ), then the array is silently filled up with null values to make idx a valid reference to the last stored element. In case the value was null before, it is converted to an array. If key is not found in the object, then it is silently added to the object and filled with a null value to make key a valid reference. In case the value was null before, it is converted to an object. null values are created in arrays and objects if necessary. In particular: If the JSON pointer points to an object key that does not exist, it is created an filled with a null value before a reference to it is returned. If the JSON pointer points to an array index that does not exist, it is created an filled with a null value before a reference to it is returned. All indices between the current maximum and the given index are also filled with null . The special value - is treated as a synonym for the index past the end.","title":"Notes"},{"location":"api/basic_json/operator%5B%5D/#exception-safety","text":"Strong exception safety: if an exception occurs, the original value stays intact.","title":"Exception safety"},{"location":"api/basic_json/operator%5B%5D/#complexity","text":"Constant if idx is in the range of the array. Otherwise linear in idx - size() . Logarithmic in the size of the container. Constant","title":"Complexity"},{"location":"api/basic_json/operator%5B%5D/#example","text":"Example The example below shows how array elements can be read and written using [] operator. Note the addition of null values. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON array json array = { 1 , 2 , 3 , 4 , 5 }; // output element at index 3 (fourth element) std :: cout << array [ 3 ] << '\\n' ; // change last element to 6 array [ array . size () - 1 ] = 6 ; // output changed array std :: cout << array << '\\n' ; // write beyond array limit array [ 10 ] = 11 ; // output changed array std :: cout << array << '\\n' ; } Output: 4 [ 1 , 2 , 3 , 4 , 6 ] [ 1 , 2 , 3 , 4 , 6 , null , null , null , null , null , 11 ] Example The example below shows how array elements can be read using the [] operator. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON array const json array = { \"first\" , \"2nd\" , \"third\" , \"fourth\" }; // output element at index 2 (third element) std :: cout << array . at ( 2 ) << '\\n' ; } Output: \"third\" Example The example below shows how object elements can be read and written using the [] operator. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON object json object = { { \"one\" , 1 }, { \"two\" , 2 }, { \"three\" , 2.9 } }; // output element with key \"two\" std :: cout << object [ \"two\" ] << \" \\n\\n \" ; // change element with key \"three\" object [ \"three\" ] = 3 ; // output changed array std :: cout << std :: setw ( 4 ) << object << \" \\n\\n \" ; // mention nonexisting key object [ \"four\" ]; // write to nonexisting key object [ \"five\" ][ \"really\" ][ \"nested\" ] = true ; // output changed object std :: cout << std :: setw ( 4 ) << object << '\\n' ; } Output: 2 { \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } { \"five\" : { \"really\" : { \"nested\" : true } }, \"four\" : null , \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } Example The example below shows how object elements can be read using the [] operator. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON object const json object = { { \"one\" , 1 }, { \"two\" , 2 }, { \"three\" , 2.9 } }; // output element with key \"two\" std :: cout << object [ \"two\" ] << '\\n' ; } Output: 2 Example The example below shows how values can be read and written using JSON Pointers. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = { { \"number\" , 1 }, { \"string\" , \"foo\" }, { \"array\" , { 1 , 2 }} }; // read-only access // output element with JSON pointer \"/number\" std :: cout << j [ \"/number\" _json_pointer ] << '\\n' ; // output element with JSON pointer \"/string\" std :: cout << j [ \"/string\" _json_pointer ] << '\\n' ; // output element with JSON pointer \"/array\" std :: cout << j [ \"/array\" _json_pointer ] << '\\n' ; // output element with JSON pointer \"/array/1\" std :: cout << j [ \"/array/1\" _json_pointer ] << '\\n' ; // writing access // change the string j [ \"/string\" _json_pointer ] = \"bar\" ; // output the changed string std :: cout << j [ \"string\" ] << '\\n' ; // \"change\" a nonexisting object entry j [ \"/boolean\" _json_pointer ] = true ; // output the changed object std :: cout << j << '\\n' ; // change an array element j [ \"/array/1\" _json_pointer ] = 21 ; // \"change\" an array element with nonexisting index j [ \"/array/4\" _json_pointer ] = 44 ; // output the changed array std :: cout << j [ \"array\" ] << '\\n' ; // \"change\" the array element past the end j [ \"/array/-\" _json_pointer ] = 55 ; // output the changed array std :: cout << j [ \"array\" ] << '\\n' ; } Output: 1 \"foo\" [ 1 , 2 ] 2 \"bar\" { \"array\" :[ 1 , 2 ], \"boolean\" : true , \"number\" : 1 , \"string\" : \"bar\" } [ 1 , 21 , null , null , 44 ] [ 1 , 21 , null , null , 44 , 55 ] Example The example below shows how values can be read using JSON Pointers. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value const json j = { { \"number\" , 1 }, { \"string\" , \"foo\" }, { \"array\" , { 1 , 2 }} }; // read-only access // output element with JSON pointer \"/number\" std :: cout << j [ \"/number\" _json_pointer ] << '\\n' ; // output element with JSON pointer \"/string\" std :: cout << j [ \"/string\" _json_pointer ] << '\\n' ; // output element with JSON pointer \"/array\" std :: cout << j [ \"/array\" _json_pointer ] << '\\n' ; // output element with JSON pointer \"/array/1\" std :: cout << j [ \"/array/1\" _json_pointer ] << '\\n' ; } Output: 1 \"foo\" [ 1 , 2 ] 2","title":"Example"},{"location":"api/basic_json/operator%5B%5D/#version-history","text":"Added in version 1.0.0. Added in version 1.0.0. Overloads for T* key added in version 1.1.0. Added in version 2.0.0.","title":"Version history"},{"location":"api/basic_json/operator_literal_json/","text":"basic_json::operator\"\"_json \u00b6 json operator \"\" _json ( const char * s , std :: size_t n ) This operator implements a user-defined string literal for JSON objects. It can be used by adding _json to a string literal and returns a json object if no parse error occurred. Parameters \u00b6 s (in) a string representation of a JSON object n (in) length of string s Return value \u00b6 json value parsed from s Exceptions \u00b6 The function can throw anything that parse(s, s+n) would throw. Complexity \u00b6 Linear. Version history \u00b6 Added in version 1.0.0.","title":"basic_json::operator\"\"_json"},{"location":"api/basic_json/operator_literal_json/#basic_jsonoperator_json","text":"json operator \"\" _json ( const char * s , std :: size_t n ) This operator implements a user-defined string literal for JSON objects. It can be used by adding _json to a string literal and returns a json object if no parse error occurred.","title":"basic_json::operator\"\"_json"},{"location":"api/basic_json/operator_literal_json/#parameters","text":"s (in) a string representation of a JSON object n (in) length of string s","title":"Parameters"},{"location":"api/basic_json/operator_literal_json/#return-value","text":"json value parsed from s","title":"Return value"},{"location":"api/basic_json/operator_literal_json/#exceptions","text":"The function can throw anything that parse(s, s+n) would throw.","title":"Exceptions"},{"location":"api/basic_json/operator_literal_json/#complexity","text":"Linear.","title":"Complexity"},{"location":"api/basic_json/operator_literal_json/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/operator_literal_json_pointer/","text":"basic_json::operator\"\"_json_pointer \u00b6 json_pointer operator \"\" _json_pointer ( const char * s , std :: size_t n ) This operator implements a user-defined string literal for JSON Pointers. It can be used by adding _json_pointer to a string literal and returns a json_pointer object if no parse error occurred. Parameters \u00b6 s (in) a string representation of a JSON Pointer n (in) length of string s Return value \u00b6 json_pointer value parsed from s Exceptions \u00b6 The function can throw anything that json_pointer::json_pointer would throw. Complexity \u00b6 Linear. Version history \u00b6 Added in version 2.0.0.","title":"basic_json::operator\"\"_json_pointer"},{"location":"api/basic_json/operator_literal_json_pointer/#basic_jsonoperator_json_pointer","text":"json_pointer operator \"\" _json_pointer ( const char * s , std :: size_t n ) This operator implements a user-defined string literal for JSON Pointers. It can be used by adding _json_pointer to a string literal and returns a json_pointer object if no parse error occurred.","title":"basic_json::operator\"\"_json_pointer"},{"location":"api/basic_json/operator_literal_json_pointer/#parameters","text":"s (in) a string representation of a JSON Pointer n (in) length of string s","title":"Parameters"},{"location":"api/basic_json/operator_literal_json_pointer/#return-value","text":"json_pointer value parsed from s","title":"Return value"},{"location":"api/basic_json/operator_literal_json_pointer/#exceptions","text":"The function can throw anything that json_pointer::json_pointer would throw.","title":"Exceptions"},{"location":"api/basic_json/operator_literal_json_pointer/#complexity","text":"Linear.","title":"Complexity"},{"location":"api/basic_json/operator_literal_json_pointer/#version-history","text":"Added in version 2.0.0.","title":"Version history"},{"location":"api/basic_json/operator_value_t/","text":"basic_json::operator value_t \u00b6 constexpr operator value_t () const noexcept ; Return the type of the JSON value as a value from the value_t enumeration. Return value \u00b6 the type of the JSON value Value type return value null value_t::null boolean value_t::boolean string value_t::string number (integer) value_t::number_integer number (unsigned integer) value_t::number_unsigned number (floating-point) value_t::number_float object value_t::object array value_t::array binary value_t::binary discarded value_t::discarded Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code exemplifies operator value_t() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = - 17 ; json j_number_unsigned = 42u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; // call operator value_t() json :: value_t t_null = j_null ; json :: value_t t_boolean = j_boolean ; json :: value_t t_number_integer = j_number_integer ; json :: value_t t_number_unsigned = j_number_unsigned ; json :: value_t t_number_float = j_number_float ; json :: value_t t_object = j_object ; json :: value_t t_array = j_array ; json :: value_t t_string = j_string ; // print types std :: cout << std :: boolalpha ; std :: cout << ( t_null == json :: value_t :: null ) << '\\n' ; std :: cout << ( t_boolean == json :: value_t :: boolean ) << '\\n' ; std :: cout << ( t_number_integer == json :: value_t :: number_integer ) << '\\n' ; std :: cout << ( t_number_unsigned == json :: value_t :: number_unsigned ) << '\\n' ; std :: cout << ( t_number_float == json :: value_t :: number_float ) << '\\n' ; std :: cout << ( t_object == json :: value_t :: object ) << '\\n' ; std :: cout << ( t_array == json :: value_t :: array ) << '\\n' ; std :: cout << ( t_string == json :: value_t :: string ) << '\\n' ; } Output: true true true true true true true true Version history \u00b6 Added in version 1.0.0. Added unsigned integer type in version 2.0.0. Added binary type in version 3.8.0.","title":"basic_json::operator value_t"},{"location":"api/basic_json/operator_value_t/#basic_jsonoperator-value_t","text":"constexpr operator value_t () const noexcept ; Return the type of the JSON value as a value from the value_t enumeration.","title":"basic_json::operator value_t"},{"location":"api/basic_json/operator_value_t/#return-value","text":"the type of the JSON value Value type return value null value_t::null boolean value_t::boolean string value_t::string number (integer) value_t::number_integer number (unsigned integer) value_t::number_unsigned number (floating-point) value_t::number_float object value_t::object array value_t::array binary value_t::binary discarded value_t::discarded","title":"Return value"},{"location":"api/basic_json/operator_value_t/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/operator_value_t/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/operator_value_t/#example","text":"Example The following code exemplifies operator value_t() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = - 17 ; json j_number_unsigned = 42u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; // call operator value_t() json :: value_t t_null = j_null ; json :: value_t t_boolean = j_boolean ; json :: value_t t_number_integer = j_number_integer ; json :: value_t t_number_unsigned = j_number_unsigned ; json :: value_t t_number_float = j_number_float ; json :: value_t t_object = j_object ; json :: value_t t_array = j_array ; json :: value_t t_string = j_string ; // print types std :: cout << std :: boolalpha ; std :: cout << ( t_null == json :: value_t :: null ) << '\\n' ; std :: cout << ( t_boolean == json :: value_t :: boolean ) << '\\n' ; std :: cout << ( t_number_integer == json :: value_t :: number_integer ) << '\\n' ; std :: cout << ( t_number_unsigned == json :: value_t :: number_unsigned ) << '\\n' ; std :: cout << ( t_number_float == json :: value_t :: number_float ) << '\\n' ; std :: cout << ( t_object == json :: value_t :: object ) << '\\n' ; std :: cout << ( t_array == json :: value_t :: array ) << '\\n' ; std :: cout << ( t_string == json :: value_t :: string ) << '\\n' ; } Output: true true true true true true true true","title":"Example"},{"location":"api/basic_json/operator_value_t/#version-history","text":"Added in version 1.0.0. Added unsigned integer type in version 2.0.0. Added binary type in version 3.8.0.","title":"Version history"},{"location":"api/basic_json/parse/","text":"basic_json::parse \u00b6 // (1) template < typename InputType > static basic_json parse ( InputType && i , const parser_callback_t cb = nullptr , const bool allow_exceptions = true , const bool ignore_comments = false ); // (2) template < typename IteratorType > static basic_json parse ( IteratorType first , IteratorType last , const parser_callback_t cb = nullptr , const bool allow_exceptions = true , const bool ignore_comments = false ); Deserialize from a compatible input. Deserialize from a pair of character iterators The value_type of the iterator must be a integral type with size of 1, 2 or 4 bytes, which will be interpreted respectively as UTF-8, UTF-16 and UTF-32. Template parameters \u00b6 InputType A compatible input, for instance: an std::istream object a FILE pointer a C-style array of characters a pointer to a null-terminated string of single byte characters an object obj for which begin(obj) and end(obj) produces a valid pair of iterators. IteratorType a compatible iterator type Parameters \u00b6 i (in) Input to parse from. cb (in) a parser callback function of type parser_callback_t which is used to control the deserialization by filtering unwanted values (optional) allow_exceptions (in) whether to throw exceptions in case of a parse error (optional, true by default) ignore_comments (in) whether comments should be ignored and treated like whitespace ( true ) or yield a parse error ( false ); (optional, false by default) first (in) iterator to start of character range last (in) iterator to end of character range Return value \u00b6 Deserialized JSON value; in case of a parse error and allow_exceptions set to false , the return value will be value_t::discarded . Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Linear in the length of the input. The parser is a predictive LL(1) parser. The complexity can be higher if the parser callback function cb or reading from (1) the input i or (2) the iterator range [ first , last ] has a super-linear complexity. Notes \u00b6 (1) A UTF-8 byte order mark is silently ignored. Examples \u00b6 Example The example below demonstrates the parse() function reading from an array. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // a JSON text char text [] = R \" ( { \"Image\": { \"Width\": 800, \"Height\": 600, \"Title\": \"View from 15th Floor\", \"Thumbnail\": { \"Url\": \"http://www.example.com/image/481989943\", \"Height\": 125, \"Width\": 100 }, \"Animated\" : false, \"IDs\": [116, 943, 234, 38793] } } ) \" ; // parse and serialize JSON json j_complete = json :: parse ( text ); std :: cout << std :: setw ( 4 ) << j_complete << \" \\n\\n \" ; } Output: { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Thumbnail\" : { \"Height\" : 125 , \"Url\" : \"http://www.example.com/image/481989943\" , \"Width\" : 100 }, \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } } Example The example below demonstrates the parse() function with and without callback function. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // a JSON text auto text = R \" ( { \"Image\": { \"Width\": 800, \"Height\": 600, \"Title\": \"View from 15th Floor\", \"Thumbnail\": { \"Url\": \"http://www.example.com/image/481989943\", \"Height\": 125, \"Width\": 100 }, \"Animated\" : false, \"IDs\": [116, 943, 234, 38793] } } ) \" ; // parse and serialize JSON json j_complete = json :: parse ( text ); std :: cout << std :: setw ( 4 ) << j_complete << \" \\n\\n \" ; // define parser callback json :: parser_callback_t cb = []( int depth , json :: parse_event_t event , json & parsed ) { // skip object elements with key \"Thumbnail\" if ( event == json :: parse_event_t :: key and parsed == json ( \"Thumbnail\" )) { return false ; } else { return true ; } }; // parse (with callback) and serialize JSON json j_filtered = json :: parse ( text , cb ); std :: cout << std :: setw ( 4 ) << j_filtered << '\\n' ; } Output: { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Thumbnail\" : { \"Height\" : 125 , \"Url\" : \"http://www.example.com/image/481989943\" , \"Width\" : 100 }, \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } } { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } } Example The example below demonstrates the parse() function with and without callback function. #include <iostream> #include <iomanip> #include <sstream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // a JSON text auto text = R \" ( { \"Image\": { \"Width\": 800, \"Height\": 600, \"Title\": \"View from 15th Floor\", \"Thumbnail\": { \"Url\": \"http://www.example.com/image/481989943\", \"Height\": 125, \"Width\": 100 }, \"Animated\" : false, \"IDs\": [116, 943, 234, 38793] } } ) \" ; // fill a stream with JSON text std :: stringstream ss ; ss << text ; // parse and serialize JSON json j_complete = json :: parse ( ss ); std :: cout << std :: setw ( 4 ) << j_complete << \" \\n\\n \" ; // define parser callback json :: parser_callback_t cb = []( int depth , json :: parse_event_t event , json & parsed ) { // skip object elements with key \"Thumbnail\" if ( event == json :: parse_event_t :: key and parsed == json ( \"Thumbnail\" )) { return false ; } else { return true ; } }; // fill a stream with JSON text ss . clear (); ss << text ; // parse (with callback) and serialize JSON json j_filtered = json :: parse ( ss , cb ); std :: cout << std :: setw ( 4 ) << j_filtered << '\\n' ; } Output: { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Thumbnail\" : { \"Height\" : 125 , \"Url\" : \"http://www.example.com/image/481989943\" , \"Width\" : 100 }, \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } } { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } } Example The example below demonstrates the parse() function reading from a contiguous container. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // a JSON text given as std::vector std :: vector < uint8_t > text = { '[' , '1' , ',' , '2' , ',' , '3' , ']' , '\\0' }; // parse and serialize JSON json j_complete = json :: parse ( text ); std :: cout << std :: setw ( 4 ) << j_complete << \" \\n\\n \" ; } Output: [ 1 , 2 , 3 ] Version history \u00b6 Added in version 1.0.0. Overload for contiguous containers (1) added in version 2.0.3. Ignoring comments via ignore_comments added in version 3.9.0.","title":"basic_json::parse"},{"location":"api/basic_json/parse/#basic_jsonparse","text":"// (1) template < typename InputType > static basic_json parse ( InputType && i , const parser_callback_t cb = nullptr , const bool allow_exceptions = true , const bool ignore_comments = false ); // (2) template < typename IteratorType > static basic_json parse ( IteratorType first , IteratorType last , const parser_callback_t cb = nullptr , const bool allow_exceptions = true , const bool ignore_comments = false ); Deserialize from a compatible input. Deserialize from a pair of character iterators The value_type of the iterator must be a integral type with size of 1, 2 or 4 bytes, which will be interpreted respectively as UTF-8, UTF-16 and UTF-32.","title":"basic_json::parse"},{"location":"api/basic_json/parse/#template-parameters","text":"InputType A compatible input, for instance: an std::istream object a FILE pointer a C-style array of characters a pointer to a null-terminated string of single byte characters an object obj for which begin(obj) and end(obj) produces a valid pair of iterators. IteratorType a compatible iterator type","title":"Template parameters"},{"location":"api/basic_json/parse/#parameters","text":"i (in) Input to parse from. cb (in) a parser callback function of type parser_callback_t which is used to control the deserialization by filtering unwanted values (optional) allow_exceptions (in) whether to throw exceptions in case of a parse error (optional, true by default) ignore_comments (in) whether comments should be ignored and treated like whitespace ( true ) or yield a parse error ( false ); (optional, false by default) first (in) iterator to start of character range last (in) iterator to end of character range","title":"Parameters"},{"location":"api/basic_json/parse/#return-value","text":"Deserialized JSON value; in case of a parse error and allow_exceptions set to false , the return value will be value_t::discarded .","title":"Return value"},{"location":"api/basic_json/parse/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/parse/#complexity","text":"Linear in the length of the input. The parser is a predictive LL(1) parser. The complexity can be higher if the parser callback function cb or reading from (1) the input i or (2) the iterator range [ first , last ] has a super-linear complexity.","title":"Complexity"},{"location":"api/basic_json/parse/#notes","text":"(1) A UTF-8 byte order mark is silently ignored.","title":"Notes"},{"location":"api/basic_json/parse/#examples","text":"Example The example below demonstrates the parse() function reading from an array. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // a JSON text char text [] = R \" ( { \"Image\": { \"Width\": 800, \"Height\": 600, \"Title\": \"View from 15th Floor\", \"Thumbnail\": { \"Url\": \"http://www.example.com/image/481989943\", \"Height\": 125, \"Width\": 100 }, \"Animated\" : false, \"IDs\": [116, 943, 234, 38793] } } ) \" ; // parse and serialize JSON json j_complete = json :: parse ( text ); std :: cout << std :: setw ( 4 ) << j_complete << \" \\n\\n \" ; } Output: { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Thumbnail\" : { \"Height\" : 125 , \"Url\" : \"http://www.example.com/image/481989943\" , \"Width\" : 100 }, \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } } Example The example below demonstrates the parse() function with and without callback function. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // a JSON text auto text = R \" ( { \"Image\": { \"Width\": 800, \"Height\": 600, \"Title\": \"View from 15th Floor\", \"Thumbnail\": { \"Url\": \"http://www.example.com/image/481989943\", \"Height\": 125, \"Width\": 100 }, \"Animated\" : false, \"IDs\": [116, 943, 234, 38793] } } ) \" ; // parse and serialize JSON json j_complete = json :: parse ( text ); std :: cout << std :: setw ( 4 ) << j_complete << \" \\n\\n \" ; // define parser callback json :: parser_callback_t cb = []( int depth , json :: parse_event_t event , json & parsed ) { // skip object elements with key \"Thumbnail\" if ( event == json :: parse_event_t :: key and parsed == json ( \"Thumbnail\" )) { return false ; } else { return true ; } }; // parse (with callback) and serialize JSON json j_filtered = json :: parse ( text , cb ); std :: cout << std :: setw ( 4 ) << j_filtered << '\\n' ; } Output: { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Thumbnail\" : { \"Height\" : 125 , \"Url\" : \"http://www.example.com/image/481989943\" , \"Width\" : 100 }, \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } } { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } } Example The example below demonstrates the parse() function with and without callback function. #include <iostream> #include <iomanip> #include <sstream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // a JSON text auto text = R \" ( { \"Image\": { \"Width\": 800, \"Height\": 600, \"Title\": \"View from 15th Floor\", \"Thumbnail\": { \"Url\": \"http://www.example.com/image/481989943\", \"Height\": 125, \"Width\": 100 }, \"Animated\" : false, \"IDs\": [116, 943, 234, 38793] } } ) \" ; // fill a stream with JSON text std :: stringstream ss ; ss << text ; // parse and serialize JSON json j_complete = json :: parse ( ss ); std :: cout << std :: setw ( 4 ) << j_complete << \" \\n\\n \" ; // define parser callback json :: parser_callback_t cb = []( int depth , json :: parse_event_t event , json & parsed ) { // skip object elements with key \"Thumbnail\" if ( event == json :: parse_event_t :: key and parsed == json ( \"Thumbnail\" )) { return false ; } else { return true ; } }; // fill a stream with JSON text ss . clear (); ss << text ; // parse (with callback) and serialize JSON json j_filtered = json :: parse ( ss , cb ); std :: cout << std :: setw ( 4 ) << j_filtered << '\\n' ; } Output: { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Thumbnail\" : { \"Height\" : 125 , \"Url\" : \"http://www.example.com/image/481989943\" , \"Width\" : 100 }, \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } } { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } } Example The example below demonstrates the parse() function reading from a contiguous container. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // a JSON text given as std::vector std :: vector < uint8_t > text = { '[' , '1' , ',' , '2' , ',' , '3' , ']' , '\\0' }; // parse and serialize JSON json j_complete = json :: parse ( text ); std :: cout << std :: setw ( 4 ) << j_complete << \" \\n\\n \" ; } Output: [ 1 , 2 , 3 ]","title":"Examples"},{"location":"api/basic_json/parse/#version-history","text":"Added in version 1.0.0. Overload for contiguous containers (1) added in version 2.0.3. Ignoring comments via ignore_comments added in version 3.9.0.","title":"Version history"},{"location":"api/basic_json/parse_event_t/","text":"basic_json::parse_event_t \u00b6 enum class parse_event_t : std :: uint8_t { object_start , object_end , array_start , array_end , key , value }; The parser callback distinguishes the following events: object_start : the parser read { and started to process a JSON object key : the parser read a key of a value in an object object_end : the parser read } and finished processing a JSON object array_start : the parser read [ and started to process a JSON array array_end : the parser read ] and finished processing a JSON array value : the parser finished reading a JSON value Example \u00b6 Version history \u00b6 Added in version 1.0.0.","title":"basic_json::parse_event_t"},{"location":"api/basic_json/parse_event_t/#basic_jsonparse_event_t","text":"enum class parse_event_t : std :: uint8_t { object_start , object_end , array_start , array_end , key , value }; The parser callback distinguishes the following events: object_start : the parser read { and started to process a JSON object key : the parser read a key of a value in an object object_end : the parser read } and finished processing a JSON object array_start : the parser read [ and started to process a JSON array array_end : the parser read ] and finished processing a JSON array value : the parser finished reading a JSON value","title":"basic_json::parse_event_t"},{"location":"api/basic_json/parse_event_t/#example","text":"","title":"Example"},{"location":"api/basic_json/parse_event_t/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/parser_callback_t/","text":"basic_json::parser_callback_t \u00b6 template < typename BasicJsonType > using parser_callback_t = std :: function < bool ( int depth , parse_event_t event , BasicJsonType & parsed ) > ; With a parser callback function, the result of parsing a JSON text can be influenced. When passed to parse , it is called on certain events (passed as parse_event_t via parameter event ) with a set recursion depth depth and context JSON value parsed . The return value of the callback function is a boolean indicating whether the element that emitted the callback shall be kept or not. We distinguish six scenarios (determined by the event type) in which the callback function can be called. The following table describes the values of the parameters depth , event , and parsed . parameter event description parameter depth parameter parsed parse_event_t::object_start the parser read { and started to process a JSON object depth of the parent of the JSON object a JSON value with type discarded parse_event_t::key the parser read a key of a value in an object depth of the currently parsed JSON object a JSON string containing the key parse_event_t::object_end the parser read } and finished processing a JSON object depth of the parent of the JSON object the parsed JSON object parse_event_t::array_start the parser read [ and started to process a JSON array depth of the parent of the JSON array a JSON value with type discarded parse_event_t::array_end the parser read ] and finished processing a JSON array depth of the parent of the JSON array the parsed JSON array parse_event_t::value the parser finished reading a JSON value depth of the value the parsed JSON value Discarding a value (i.e., returning false ) has different effects depending on the context in which function was called: Discarded values in structured types are skipped. That is, the parser will behave as if the discarded value was never read. In case a value outside a structured type is skipped, it is replaced with null . This case happens if the top-level element is skipped. Parameters \u00b6 depth (in) the depth of the recursion during parsing event (in) an event of type parse_event_t indicating the context in the callback function has been called parsed (in, out) the current intermediate parse result; note that writing to this value has no effect for parse_event_t::key events Return value \u00b6 Whether the JSON value which called the function during parsing should be kept ( true ) or not ( false ). In the latter case, it is either skipped completely or replaced by an empty discarded object. Example \u00b6 Example The example below demonstrates the parse() function with and without callback function. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // a JSON text auto text = R \" ( { \"Image\": { \"Width\": 800, \"Height\": 600, \"Title\": \"View from 15th Floor\", \"Thumbnail\": { \"Url\": \"http://www.example.com/image/481989943\", \"Height\": 125, \"Width\": 100 }, \"Animated\" : false, \"IDs\": [116, 943, 234, 38793] } } ) \" ; // parse and serialize JSON json j_complete = json :: parse ( text ); std :: cout << std :: setw ( 4 ) << j_complete << \" \\n\\n \" ; // define parser callback json :: parser_callback_t cb = []( int depth , json :: parse_event_t event , json & parsed ) { // skip object elements with key \"Thumbnail\" if ( event == json :: parse_event_t :: key and parsed == json ( \"Thumbnail\" )) { return false ; } else { return true ; } }; // parse (with callback) and serialize JSON json j_filtered = json :: parse ( text , cb ); std :: cout << std :: setw ( 4 ) << j_filtered << '\\n' ; } Output: { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Thumbnail\" : { \"Height\" : 125 , \"Url\" : \"http://www.example.com/image/481989943\" , \"Width\" : 100 }, \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } } { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } } Version history \u00b6 Added in version 1.0.0.","title":"basic_json::parser_callback_t"},{"location":"api/basic_json/parser_callback_t/#basic_jsonparser_callback_t","text":"template < typename BasicJsonType > using parser_callback_t = std :: function < bool ( int depth , parse_event_t event , BasicJsonType & parsed ) > ; With a parser callback function, the result of parsing a JSON text can be influenced. When passed to parse , it is called on certain events (passed as parse_event_t via parameter event ) with a set recursion depth depth and context JSON value parsed . The return value of the callback function is a boolean indicating whether the element that emitted the callback shall be kept or not. We distinguish six scenarios (determined by the event type) in which the callback function can be called. The following table describes the values of the parameters depth , event , and parsed . parameter event description parameter depth parameter parsed parse_event_t::object_start the parser read { and started to process a JSON object depth of the parent of the JSON object a JSON value with type discarded parse_event_t::key the parser read a key of a value in an object depth of the currently parsed JSON object a JSON string containing the key parse_event_t::object_end the parser read } and finished processing a JSON object depth of the parent of the JSON object the parsed JSON object parse_event_t::array_start the parser read [ and started to process a JSON array depth of the parent of the JSON array a JSON value with type discarded parse_event_t::array_end the parser read ] and finished processing a JSON array depth of the parent of the JSON array the parsed JSON array parse_event_t::value the parser finished reading a JSON value depth of the value the parsed JSON value Discarding a value (i.e., returning false ) has different effects depending on the context in which function was called: Discarded values in structured types are skipped. That is, the parser will behave as if the discarded value was never read. In case a value outside a structured type is skipped, it is replaced with null . This case happens if the top-level element is skipped.","title":"basic_json::parser_callback_t"},{"location":"api/basic_json/parser_callback_t/#parameters","text":"depth (in) the depth of the recursion during parsing event (in) an event of type parse_event_t indicating the context in the callback function has been called parsed (in, out) the current intermediate parse result; note that writing to this value has no effect for parse_event_t::key events","title":"Parameters"},{"location":"api/basic_json/parser_callback_t/#return-value","text":"Whether the JSON value which called the function during parsing should be kept ( true ) or not ( false ). In the latter case, it is either skipped completely or replaced by an empty discarded object.","title":"Return value"},{"location":"api/basic_json/parser_callback_t/#example","text":"Example The example below demonstrates the parse() function with and without callback function. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // a JSON text auto text = R \" ( { \"Image\": { \"Width\": 800, \"Height\": 600, \"Title\": \"View from 15th Floor\", \"Thumbnail\": { \"Url\": \"http://www.example.com/image/481989943\", \"Height\": 125, \"Width\": 100 }, \"Animated\" : false, \"IDs\": [116, 943, 234, 38793] } } ) \" ; // parse and serialize JSON json j_complete = json :: parse ( text ); std :: cout << std :: setw ( 4 ) << j_complete << \" \\n\\n \" ; // define parser callback json :: parser_callback_t cb = []( int depth , json :: parse_event_t event , json & parsed ) { // skip object elements with key \"Thumbnail\" if ( event == json :: parse_event_t :: key and parsed == json ( \"Thumbnail\" )) { return false ; } else { return true ; } }; // parse (with callback) and serialize JSON json j_filtered = json :: parse ( text , cb ); std :: cout << std :: setw ( 4 ) << j_filtered << '\\n' ; } Output: { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Thumbnail\" : { \"Height\" : 125 , \"Url\" : \"http://www.example.com/image/481989943\" , \"Width\" : 100 }, \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } } { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } }","title":"Example"},{"location":"api/basic_json/parser_callback_t/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/patch/","text":"basic_json::patch \u00b6 basic_json patch ( const basic_json & json_patch ) const ; JSON Patch defines a JSON document structure for expressing a sequence of operations to apply to a JSON) document. With this function, a JSON Patch is applied to the current JSON value by executing all operations from the patch. Parameters \u00b6 json_patch (in) JSON patch document Return value \u00b6 patched document Exceptions \u00b6 Throws parse_error.104 if the JSON patch does not consist of an array of objects. Throws parse_error.105 if the JSON patch is malformed (e.g., mandatory attributes are missing); example: \"operation add must have member path\" . Throws out_of_range.401 if an array index is out of range. Throws out_of_range.403 if a JSON pointer inside the patch could not be resolved successfully in the current JSON value; example: \"key baz not found\" . Throws out_of_range.405 if JSON pointer has no parent (\"add\", \"remove\", \"move\") Throws out_of_range.501 if \"test\" operation was unsuccessful. Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Linear in the size of the JSON value and the length of the JSON patch. As usually only a fraction of the JSON value is affected by the patch, the complexity can usually be neglected. Note \u00b6 The application of a patch is atomic: Either all operations succeed and the patched document is returned or an exception is thrown. In any case, the original value is not changed: the patch is applied to a copy of the value. Example \u00b6 Example The following code shows how a JSON patch is applied to a value. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // the original document json doc = R \" ( { \"baz\": \"qux\", \"foo\": \"bar\" } ) \" _json ; // the patch json patch = R \" ( [ { \"op\": \"replace\", \"path\": \"/baz\", \"value\": \"boo\" }, { \"op\": \"add\", \"path\": \"/hello\", \"value\": [\"world\"] }, { \"op\": \"remove\", \"path\": \"/foo\"} ] ) \" _json ; // apply the patch json patched_doc = doc . patch ( patch ); // output original and patched document std :: cout << std :: setw ( 4 ) << doc << \" \\n\\n \" << std :: setw ( 4 ) << patched_doc << std :: endl ; } Output: { \"baz\" : \"qux\" , \"foo\" : \"bar\" } { \"baz\" : \"boo\" , \"hello\" : [ \"world\" ] } Version history \u00b6 Added in version 2.0.0.","title":"basic_json::patch"},{"location":"api/basic_json/patch/#basic_jsonpatch","text":"basic_json patch ( const basic_json & json_patch ) const ; JSON Patch defines a JSON document structure for expressing a sequence of operations to apply to a JSON) document. With this function, a JSON Patch is applied to the current JSON value by executing all operations from the patch.","title":"basic_json::patch"},{"location":"api/basic_json/patch/#parameters","text":"json_patch (in) JSON patch document","title":"Parameters"},{"location":"api/basic_json/patch/#return-value","text":"patched document","title":"Return value"},{"location":"api/basic_json/patch/#exceptions","text":"Throws parse_error.104 if the JSON patch does not consist of an array of objects. Throws parse_error.105 if the JSON patch is malformed (e.g., mandatory attributes are missing); example: \"operation add must have member path\" . Throws out_of_range.401 if an array index is out of range. Throws out_of_range.403 if a JSON pointer inside the patch could not be resolved successfully in the current JSON value; example: \"key baz not found\" . Throws out_of_range.405 if JSON pointer has no parent (\"add\", \"remove\", \"move\") Throws out_of_range.501 if \"test\" operation was unsuccessful.","title":"Exceptions"},{"location":"api/basic_json/patch/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/patch/#complexity","text":"Linear in the size of the JSON value and the length of the JSON patch. As usually only a fraction of the JSON value is affected by the patch, the complexity can usually be neglected.","title":"Complexity"},{"location":"api/basic_json/patch/#note","text":"The application of a patch is atomic: Either all operations succeed and the patched document is returned or an exception is thrown. In any case, the original value is not changed: the patch is applied to a copy of the value.","title":"Note"},{"location":"api/basic_json/patch/#example","text":"Example The following code shows how a JSON patch is applied to a value. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // the original document json doc = R \" ( { \"baz\": \"qux\", \"foo\": \"bar\" } ) \" _json ; // the patch json patch = R \" ( [ { \"op\": \"replace\", \"path\": \"/baz\", \"value\": \"boo\" }, { \"op\": \"add\", \"path\": \"/hello\", \"value\": [\"world\"] }, { \"op\": \"remove\", \"path\": \"/foo\"} ] ) \" _json ; // apply the patch json patched_doc = doc . patch ( patch ); // output original and patched document std :: cout << std :: setw ( 4 ) << doc << \" \\n\\n \" << std :: setw ( 4 ) << patched_doc << std :: endl ; } Output: { \"baz\" : \"qux\" , \"foo\" : \"bar\" } { \"baz\" : \"boo\" , \"hello\" : [ \"world\" ] }","title":"Example"},{"location":"api/basic_json/patch/#version-history","text":"Added in version 2.0.0.","title":"Version history"},{"location":"api/basic_json/push_back/","text":"basic_json::push_back \u00b6 // (1) void push_back ( basic_json && val ); void push_back ( const basic_json & val ); // (2) void push_back ( const typename object_t :: value_type & val ); // (3) void push_back ( initializer_list_t init ); Appends the given element val to the end of the JSON array. If the function is called on a JSON null value, an empty array is created before appending val . Inserts the given element val to the JSON object. If the function is called on a JSON null value, an empty object is created before inserting val . This function allows to use push_back with an initializer list. In case the current value is an object, the initializer list init contains only two elements, and the first element of init is a string, init is converted into an object element and added using push_back(const typename object_t::value_type&) . Otherwise, init is converted to a JSON value and added using push_back(basic_json&&) . Parameters \u00b6 val (in) the value to add to the JSON array/object init (in) an initializer list Exceptions \u00b6 The function can throw the following exceptions: Throws type_error.308 when called on a type other than JSON array or null; example: \"cannot use push_back() with number\" The function can throw the following exceptions: Throws type_error.308 when called on a type other than JSON object or null; example: \"cannot use push_back() with number\" Complexity \u00b6 Amortized constant. Logarithmic in the size of the container, O(log( size() )). Linear in the size of the initializer list init . Notes \u00b6 (3) This function is required to resolve an ambiguous overload error, because pairs like {\"key\", \"value\"} can be both interpreted as object_t::value_type or std::initializer_list<basic_json> , see #235 for more information. Examples \u00b6 Example The example shows how push_back() and += can be used to add elements to a JSON array. Note how the null value was silently converted to a JSON array. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json array = { 1 , 2 , 3 , 4 , 5 }; json null ; // print values std :: cout << array << '\\n' ; std :: cout << null << '\\n' ; // add values array . push_back ( 6 ); array += 7 ; null += \"first\" ; null += \"second\" ; // print values std :: cout << array << '\\n' ; std :: cout << null << '\\n' ; } Output: [ 1 , 2 , 3 , 4 , 5 ] null [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] [ \"first\" , \"second\" ] Example The example shows how push_back() and += can be used to add elements to a JSON object. Note how the null value was silently converted to a JSON object. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json null ; // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; // add values object . push_back ( json :: object_t :: value_type ( \"three\" , 3 )); object += json :: object_t :: value_type ( \"four\" , 4 ); null += json :: object_t :: value_type ( \"A\" , \"a\" ); null += json :: object_t :: value_type ( \"B\" , \"b\" ); // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; } Output: { \"one\" : 1 , \"two\" : 2 } null { \"four\" : 4 , \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } { \"A\" : \"a\" , \"B\" : \"b\" } Example The example shows how initializer lists are treated as objects when possible. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json null ; // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; // add values: object . push_back ({ \"three\" , 3 }); // object is extended object += { \"four\" , 4 }; // object is extended null . push_back ({ \"five\" , 5 }); // null is converted to array // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; // would throw: //object.push_back({1, 2, 3}); } Output: { \"one\" : 1 , \"two\" : 2 } null { \"four\" : 4 , \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } [[ \"five\" , 5 ]] Version history \u00b6 Since version 1.0.0. Since version 1.0.0. Since version 2.0.0.","title":"basic_json::push_back"},{"location":"api/basic_json/push_back/#basic_jsonpush_back","text":"// (1) void push_back ( basic_json && val ); void push_back ( const basic_json & val ); // (2) void push_back ( const typename object_t :: value_type & val ); // (3) void push_back ( initializer_list_t init ); Appends the given element val to the end of the JSON array. If the function is called on a JSON null value, an empty array is created before appending val . Inserts the given element val to the JSON object. If the function is called on a JSON null value, an empty object is created before inserting val . This function allows to use push_back with an initializer list. In case the current value is an object, the initializer list init contains only two elements, and the first element of init is a string, init is converted into an object element and added using push_back(const typename object_t::value_type&) . Otherwise, init is converted to a JSON value and added using push_back(basic_json&&) .","title":"basic_json::push_back"},{"location":"api/basic_json/push_back/#parameters","text":"val (in) the value to add to the JSON array/object init (in) an initializer list","title":"Parameters"},{"location":"api/basic_json/push_back/#exceptions","text":"The function can throw the following exceptions: Throws type_error.308 when called on a type other than JSON array or null; example: \"cannot use push_back() with number\" The function can throw the following exceptions: Throws type_error.308 when called on a type other than JSON object or null; example: \"cannot use push_back() with number\"","title":"Exceptions"},{"location":"api/basic_json/push_back/#complexity","text":"Amortized constant. Logarithmic in the size of the container, O(log( size() )). Linear in the size of the initializer list init .","title":"Complexity"},{"location":"api/basic_json/push_back/#notes","text":"(3) This function is required to resolve an ambiguous overload error, because pairs like {\"key\", \"value\"} can be both interpreted as object_t::value_type or std::initializer_list<basic_json> , see #235 for more information.","title":"Notes"},{"location":"api/basic_json/push_back/#examples","text":"Example The example shows how push_back() and += can be used to add elements to a JSON array. Note how the null value was silently converted to a JSON array. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json array = { 1 , 2 , 3 , 4 , 5 }; json null ; // print values std :: cout << array << '\\n' ; std :: cout << null << '\\n' ; // add values array . push_back ( 6 ); array += 7 ; null += \"first\" ; null += \"second\" ; // print values std :: cout << array << '\\n' ; std :: cout << null << '\\n' ; } Output: [ 1 , 2 , 3 , 4 , 5 ] null [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] [ \"first\" , \"second\" ] Example The example shows how push_back() and += can be used to add elements to a JSON object. Note how the null value was silently converted to a JSON object. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json null ; // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; // add values object . push_back ( json :: object_t :: value_type ( \"three\" , 3 )); object += json :: object_t :: value_type ( \"four\" , 4 ); null += json :: object_t :: value_type ( \"A\" , \"a\" ); null += json :: object_t :: value_type ( \"B\" , \"b\" ); // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; } Output: { \"one\" : 1 , \"two\" : 2 } null { \"four\" : 4 , \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } { \"A\" : \"a\" , \"B\" : \"b\" } Example The example shows how initializer lists are treated as objects when possible. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json null ; // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; // add values: object . push_back ({ \"three\" , 3 }); // object is extended object += { \"four\" , 4 }; // object is extended null . push_back ({ \"five\" , 5 }); // null is converted to array // print values std :: cout << object << '\\n' ; std :: cout << null << '\\n' ; // would throw: //object.push_back({1, 2, 3}); } Output: { \"one\" : 1 , \"two\" : 2 } null { \"four\" : 4 , \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } [[ \"five\" , 5 ]]","title":"Examples"},{"location":"api/basic_json/push_back/#version-history","text":"Since version 1.0.0. Since version 1.0.0. Since version 2.0.0.","title":"Version history"},{"location":"api/basic_json/rbegin/","text":"basic_json::rbegin \u00b6 reverse_iterator rbegin () noexcept ; const_reverse_iterator rbegin () const noexcept ; Returns an iterator to the reverse-beginning; that is, the last element. Return value \u00b6 reverse iterator to the first element Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code shows an example for rbegin() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array value json array = { 1 , 2 , 3 , 4 , 5 }; // get an iterator to the reverse-beginning json :: reverse_iterator it = array . rbegin (); // serialize the element that the iterator points to std :: cout << * it << '\\n' ; } Output: 5 Version history \u00b6 Added in version 1.0.0.","title":"basic_json::rbegin"},{"location":"api/basic_json/rbegin/#basic_jsonrbegin","text":"reverse_iterator rbegin () noexcept ; const_reverse_iterator rbegin () const noexcept ; Returns an iterator to the reverse-beginning; that is, the last element.","title":"basic_json::rbegin"},{"location":"api/basic_json/rbegin/#return-value","text":"reverse iterator to the first element","title":"Return value"},{"location":"api/basic_json/rbegin/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/rbegin/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/rbegin/#example","text":"Example The following code shows an example for rbegin() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array value json array = { 1 , 2 , 3 , 4 , 5 }; // get an iterator to the reverse-beginning json :: reverse_iterator it = array . rbegin (); // serialize the element that the iterator points to std :: cout << * it << '\\n' ; } Output: 5","title":"Example"},{"location":"api/basic_json/rbegin/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/rend/","text":"basic_json::rend \u00b6 reverse_iterator rend () noexcept ; const_reverse_iterator rend () const noexcept ; Returns an iterator to the reverse-end; that is, one before the first element. This element acts as a placeholder, attempting to access it results in undefined behavior. Return value \u00b6 reverse iterator to the element following the last element Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code shows an example for eend() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array value json array = { 1 , 2 , 3 , 4 , 5 }; // get an iterator to the reverse-end json :: reverse_iterator it = array . rend (); // increment the iterator to point to the first element -- it ; // serialize the element that the iterator points to std :: cout << * it << '\\n' ; } Output: 1 Version history \u00b6 Added in version 1.0.0.","title":"basic_json::rend"},{"location":"api/basic_json/rend/#basic_jsonrend","text":"reverse_iterator rend () noexcept ; const_reverse_iterator rend () const noexcept ; Returns an iterator to the reverse-end; that is, one before the first element. This element acts as a placeholder, attempting to access it results in undefined behavior.","title":"basic_json::rend"},{"location":"api/basic_json/rend/#return-value","text":"reverse iterator to the element following the last element","title":"Return value"},{"location":"api/basic_json/rend/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/rend/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/rend/#example","text":"Example The following code shows an example for eend() . #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create an array value json array = { 1 , 2 , 3 , 4 , 5 }; // get an iterator to the reverse-end json :: reverse_iterator it = array . rend (); // increment the iterator to point to the first element -- it ; // serialize the element that the iterator points to std :: cout << * it << '\\n' ; } Output: 1","title":"Example"},{"location":"api/basic_json/rend/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/sax_parse/","text":"basic_json::sax_parse \u00b6 // (1) template < typename InputType , typename SAX > static bool sax_parse ( InputType && i , SAX * sax , input_format_t format = input_format_t :: json , const bool strict = true , const bool ignore_comments = false ); // (2) template < class IteratorType , class SAX > static bool sax_parse ( IteratorType first , IteratorType last , SAX * sax , input_format_t format = input_format_t :: json , const bool strict = true , const bool ignore_comments = false ); Read from input and generate SAX events Read from a compatible input. Read from a pair of character iterators The value_type of the iterator must be a integral type with size of 1, 2 or 4 bytes, which will be interpreted respectively as UTF-8, UTF-16 and UTF-32. The SAX event lister must follow the interface of json_sax . Template parameters \u00b6 InputType A compatible input, for instance: an std::istream object a FILE pointer a C-style array of characters a pointer to a null-terminated string of single byte characters an object obj for which begin(obj) and end(obj) produces a valid pair of iterators. IteratorType Description SAX Description Parameters \u00b6 i (in) Input to parse from. sax (in) SAX event listener format (in) the format to parse (JSON, CBOR, MessagePack, or UBJSON) (optional, input_format_t::json by default) strict (in) whether the input has to be consumed completely (optional, true by default) ignore_comments (in) whether comments should be ignored and treated like whitespace ( true ) or yield a parse error ( false ); (optional, false by default) first (in) iterator to start of character range last (in) iterator to end of character range Return value \u00b6 return value of the last processed SAX event Exception safety \u00b6 Complexity \u00b6 Linear in the length of the input. The parser is a predictive LL(1) parser. The complexity can be higher if the SAX consumer sax has a super-linear complexity. Notes \u00b6 A UTF-8 byte order mark is silently ignored. Examples \u00b6 Example The example below demonstrates the sax_parse() function reading from string and processing the events with a user-defined SAX event consumer. #include <iostream> #include <iomanip> #include <sstream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; // a simple event consumer that collects string representations of the passed // values; not inheriting from json::json_sax_t is not required, but can // help not to forget a required function class sax_event_consumer : public json :: json_sax_t { public : std :: vector < std :: string > events ; bool null () override { events . push_back ( \"value: null\" ); return true ; } bool boolean ( bool val ) override { events . push_back ( \"value: \" + std :: string ( val ? \"true\" : \"false\" )); return true ; } bool number_integer ( number_integer_t val ) override { events . push_back ( \"value: \" + std :: to_string ( val )); return true ; } bool number_unsigned ( number_unsigned_t val ) override { events . push_back ( \"value: \" + std :: to_string ( val )); return true ; } bool number_float ( number_float_t val , const string_t & s ) override { events . push_back ( \"value: \" + s ); return true ; } bool string ( string_t & val ) override { events . push_back ( \"value: \" + val ); return true ; } bool start_object ( std :: size_t elements ) override { events . push_back ( \"start: object\" ); return true ; } bool end_object () override { events . push_back ( \"end: object\" ); return true ; } bool start_array ( std :: size_t elements ) override { events . push_back ( \"start: array\" ); return true ; } bool end_array () override { events . push_back ( \"end: array\" ); return true ; } bool key ( string_t & val ) override { events . push_back ( \"key: \" + val ); return true ; } bool binary ( json :: binary_t & val ) override { events . push_back ( \"binary\" ); return true ; } bool parse_error ( std :: size_t position , const std :: string & last_token , const json :: exception & ex ) override { events . push_back ( \"error: \" + std :: string ( ex . what ())); return false ; } }; int main () { // a JSON text auto text = R \" ( { \"Image\": { \"Width\": 800, \"Height\": 600, \"Title\": \"View from 15th Floor\", \"Thumbnail\": { \"Url\": \"http://www.example.com/image/481989943\", \"Height\": 125, \"Width\": 100 }, \"Animated\" : false, \"IDs\": [116, 943, 234, 38793], \"Distance\": 12.723374634 } } ) \" ; // create a SAX event consumer object sax_event_consumer sec ; // parse and serialize JSON bool result = json :: sax_parse ( text , & sec ); // output the recorded events for ( auto & event : sec . events ) { std :: cout << \"(\" << event << \") \" ; } // output the result of sax_parse std :: cout << \" \\n result: \" << std :: boolalpha << result << std :: endl ; } Output: (start: object) (key: Image) (start: object) (key: Width) (value: 800 ) (key: Height) (value: 600 ) (key: Title) (value: View from 15 th Floor) (key: Thumbnail) (start: object) (key: Url) (value: http://www.example.com/image/ 481989943 ) (key: Height) (value: 125 ) (key: Width) (value: 100 ) (end: object) (key: Animated) (value: false ) (key: IDs) (start: array) (value: 116 ) (value: 943 ) (value: 234 ) (value: 38793 ) (end: array) (key: Distance) (value: 12.723374634 ) (end: object) (end: object) result: true Version history \u00b6 Added in version 3.2.0. Ignoring comments via ignore_comments added in version 3.9.0.","title":"basic_json::sax_parse"},{"location":"api/basic_json/sax_parse/#basic_jsonsax_parse","text":"// (1) template < typename InputType , typename SAX > static bool sax_parse ( InputType && i , SAX * sax , input_format_t format = input_format_t :: json , const bool strict = true , const bool ignore_comments = false ); // (2) template < class IteratorType , class SAX > static bool sax_parse ( IteratorType first , IteratorType last , SAX * sax , input_format_t format = input_format_t :: json , const bool strict = true , const bool ignore_comments = false ); Read from input and generate SAX events Read from a compatible input. Read from a pair of character iterators The value_type of the iterator must be a integral type with size of 1, 2 or 4 bytes, which will be interpreted respectively as UTF-8, UTF-16 and UTF-32. The SAX event lister must follow the interface of json_sax .","title":"basic_json::sax_parse"},{"location":"api/basic_json/sax_parse/#template-parameters","text":"InputType A compatible input, for instance: an std::istream object a FILE pointer a C-style array of characters a pointer to a null-terminated string of single byte characters an object obj for which begin(obj) and end(obj) produces a valid pair of iterators. IteratorType Description SAX Description","title":"Template parameters"},{"location":"api/basic_json/sax_parse/#parameters","text":"i (in) Input to parse from. sax (in) SAX event listener format (in) the format to parse (JSON, CBOR, MessagePack, or UBJSON) (optional, input_format_t::json by default) strict (in) whether the input has to be consumed completely (optional, true by default) ignore_comments (in) whether comments should be ignored and treated like whitespace ( true ) or yield a parse error ( false ); (optional, false by default) first (in) iterator to start of character range last (in) iterator to end of character range","title":"Parameters"},{"location":"api/basic_json/sax_parse/#return-value","text":"return value of the last processed SAX event","title":"Return value"},{"location":"api/basic_json/sax_parse/#exception-safety","text":"","title":"Exception safety"},{"location":"api/basic_json/sax_parse/#complexity","text":"Linear in the length of the input. The parser is a predictive LL(1) parser. The complexity can be higher if the SAX consumer sax has a super-linear complexity.","title":"Complexity"},{"location":"api/basic_json/sax_parse/#notes","text":"A UTF-8 byte order mark is silently ignored.","title":"Notes"},{"location":"api/basic_json/sax_parse/#examples","text":"Example The example below demonstrates the sax_parse() function reading from string and processing the events with a user-defined SAX event consumer. #include <iostream> #include <iomanip> #include <sstream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; // a simple event consumer that collects string representations of the passed // values; not inheriting from json::json_sax_t is not required, but can // help not to forget a required function class sax_event_consumer : public json :: json_sax_t { public : std :: vector < std :: string > events ; bool null () override { events . push_back ( \"value: null\" ); return true ; } bool boolean ( bool val ) override { events . push_back ( \"value: \" + std :: string ( val ? \"true\" : \"false\" )); return true ; } bool number_integer ( number_integer_t val ) override { events . push_back ( \"value: \" + std :: to_string ( val )); return true ; } bool number_unsigned ( number_unsigned_t val ) override { events . push_back ( \"value: \" + std :: to_string ( val )); return true ; } bool number_float ( number_float_t val , const string_t & s ) override { events . push_back ( \"value: \" + s ); return true ; } bool string ( string_t & val ) override { events . push_back ( \"value: \" + val ); return true ; } bool start_object ( std :: size_t elements ) override { events . push_back ( \"start: object\" ); return true ; } bool end_object () override { events . push_back ( \"end: object\" ); return true ; } bool start_array ( std :: size_t elements ) override { events . push_back ( \"start: array\" ); return true ; } bool end_array () override { events . push_back ( \"end: array\" ); return true ; } bool key ( string_t & val ) override { events . push_back ( \"key: \" + val ); return true ; } bool binary ( json :: binary_t & val ) override { events . push_back ( \"binary\" ); return true ; } bool parse_error ( std :: size_t position , const std :: string & last_token , const json :: exception & ex ) override { events . push_back ( \"error: \" + std :: string ( ex . what ())); return false ; } }; int main () { // a JSON text auto text = R \" ( { \"Image\": { \"Width\": 800, \"Height\": 600, \"Title\": \"View from 15th Floor\", \"Thumbnail\": { \"Url\": \"http://www.example.com/image/481989943\", \"Height\": 125, \"Width\": 100 }, \"Animated\" : false, \"IDs\": [116, 943, 234, 38793], \"Distance\": 12.723374634 } } ) \" ; // create a SAX event consumer object sax_event_consumer sec ; // parse and serialize JSON bool result = json :: sax_parse ( text , & sec ); // output the recorded events for ( auto & event : sec . events ) { std :: cout << \"(\" << event << \") \" ; } // output the result of sax_parse std :: cout << \" \\n result: \" << std :: boolalpha << result << std :: endl ; } Output: (start: object) (key: Image) (start: object) (key: Width) (value: 800 ) (key: Height) (value: 600 ) (key: Title) (value: View from 15 th Floor) (key: Thumbnail) (start: object) (key: Url) (value: http://www.example.com/image/ 481989943 ) (key: Height) (value: 125 ) (key: Width) (value: 100 ) (end: object) (key: Animated) (value: false ) (key: IDs) (start: array) (value: 116 ) (value: 943 ) (value: 234 ) (value: 38793 ) (end: array) (key: Distance) (value: 12.723374634 ) (end: object) (end: object) result: true","title":"Examples"},{"location":"api/basic_json/sax_parse/#version-history","text":"Added in version 3.2.0. Ignoring comments via ignore_comments added in version 3.9.0.","title":"Version history"},{"location":"api/basic_json/size/","text":"basic_json::size \u00b6 size_type size () const noexcept ; Returns the number of elements in a JSON value. Return value \u00b6 The return value depends on the different types and is defined as follows: Value type return value null 0 boolean 1 string 1 number 1 binary 1 object result of function object_t::size() array result of function array_t::size() Exception safety \u00b6 No-throw guarantee: this function never throws exceptions. Complexity \u00b6 Constant, as long as array_t and object_t satisfy the Container concept; that is, their size() functions have constant complexity. Notes \u00b6 This function does not return the length of a string stored as JSON value -- it returns the number of elements in the JSON value which is 1 in the case of a string. Example \u00b6 Example The following code calls size() on the different value types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_object_empty ( json :: value_t :: object ); json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_array_empty ( json :: value_t :: array ); json j_string = \"Hello, world\" ; // call size() std :: cout << j_null . size () << '\\n' ; std :: cout << j_boolean . size () << '\\n' ; std :: cout << j_number_integer . size () << '\\n' ; std :: cout << j_number_float . size () << '\\n' ; std :: cout << j_object . size () << '\\n' ; std :: cout << j_object_empty . size () << '\\n' ; std :: cout << j_array . size () << '\\n' ; std :: cout << j_array_empty . size () << '\\n' ; std :: cout << j_string . size () << '\\n' ; } Output: 0 1 1 1 2 0 5 0 1 Version history \u00b6 Added in version 1.0.0. Extended to return 1 for binary types in version 3.8.0.","title":"basic_json::size"},{"location":"api/basic_json/size/#basic_jsonsize","text":"size_type size () const noexcept ; Returns the number of elements in a JSON value.","title":"basic_json::size"},{"location":"api/basic_json/size/#return-value","text":"The return value depends on the different types and is defined as follows: Value type return value null 0 boolean 1 string 1 number 1 binary 1 object result of function object_t::size() array result of function array_t::size()","title":"Return value"},{"location":"api/basic_json/size/#exception-safety","text":"No-throw guarantee: this function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/size/#complexity","text":"Constant, as long as array_t and object_t satisfy the Container concept; that is, their size() functions have constant complexity.","title":"Complexity"},{"location":"api/basic_json/size/#notes","text":"This function does not return the length of a string stored as JSON value -- it returns the number of elements in the JSON value which is 1 in the case of a string.","title":"Notes"},{"location":"api/basic_json/size/#example","text":"Example The following code calls size() on the different value types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = 17 ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_object_empty ( json :: value_t :: object ); json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_array_empty ( json :: value_t :: array ); json j_string = \"Hello, world\" ; // call size() std :: cout << j_null . size () << '\\n' ; std :: cout << j_boolean . size () << '\\n' ; std :: cout << j_number_integer . size () << '\\n' ; std :: cout << j_number_float . size () << '\\n' ; std :: cout << j_object . size () << '\\n' ; std :: cout << j_object_empty . size () << '\\n' ; std :: cout << j_array . size () << '\\n' ; std :: cout << j_array_empty . size () << '\\n' ; std :: cout << j_string . size () << '\\n' ; } Output: 0 1 1 1 2 0 5 0 1","title":"Example"},{"location":"api/basic_json/size/#version-history","text":"Added in version 1.0.0. Extended to return 1 for binary types in version 3.8.0.","title":"Version history"},{"location":"api/basic_json/string_t/","text":"basic_json::string_t \u00b6 using string_t = StringType ; The type used to store JSON strings. RFC 7159 describes JSON strings as follows: A string is a sequence of zero or more Unicode characters. To store objects in C++, a type is defined by the template parameter described below. Unicode values are split by the JSON class into byte-sized characters during deserialization. Template parameters \u00b6 StringType the container to store strings (e.g., std::string ). Note this container is used for keys/names in objects, see object_t . Notes \u00b6 Default type \u00b6 With the default values for StringType ( std::string ), the default value for string_t is std :: string . Encoding \u00b6 Strings are stored in UTF-8 encoding. Therefore, functions like std::string::size() or std::string::length() return the number of bytes in the string rather than the number of characters or glyphs. String comparison \u00b6 RFC 7159 states: Software implementations are typically required to test names of object members for equality. Implementations that transform the textual representation into sequences of Unicode code units and then perform the comparison numerically, code unit by code unit, are interoperable in the sense that implementations will agree in all cases on equality or inequality of two strings. For example, implementations that compare strings with escaped characters unconverted may incorrectly find that \"a\\\\b\" and \"a\\u005Cb\" are not equal. This implementation is interoperable as it does compare strings code unit by code unit. Storage \u00b6 String values are stored as pointers in a basic_json type. That is, for any access to string values, a pointer of type string_t* must be dereferenced. Version history \u00b6 Added in version 1.0.0.","title":"basic_json::string_t"},{"location":"api/basic_json/string_t/#basic_jsonstring_t","text":"using string_t = StringType ; The type used to store JSON strings. RFC 7159 describes JSON strings as follows: A string is a sequence of zero or more Unicode characters. To store objects in C++, a type is defined by the template parameter described below. Unicode values are split by the JSON class into byte-sized characters during deserialization.","title":"basic_json::string_t"},{"location":"api/basic_json/string_t/#template-parameters","text":"StringType the container to store strings (e.g., std::string ). Note this container is used for keys/names in objects, see object_t .","title":"Template parameters"},{"location":"api/basic_json/string_t/#notes","text":"","title":"Notes"},{"location":"api/basic_json/string_t/#default-type","text":"With the default values for StringType ( std::string ), the default value for string_t is std :: string .","title":"Default type"},{"location":"api/basic_json/string_t/#encoding","text":"Strings are stored in UTF-8 encoding. Therefore, functions like std::string::size() or std::string::length() return the number of bytes in the string rather than the number of characters or glyphs.","title":"Encoding"},{"location":"api/basic_json/string_t/#string-comparison","text":"RFC 7159 states: Software implementations are typically required to test names of object members for equality. Implementations that transform the textual representation into sequences of Unicode code units and then perform the comparison numerically, code unit by code unit, are interoperable in the sense that implementations will agree in all cases on equality or inequality of two strings. For example, implementations that compare strings with escaped characters unconverted may incorrectly find that \"a\\\\b\" and \"a\\u005Cb\" are not equal. This implementation is interoperable as it does compare strings code unit by code unit.","title":"String comparison"},{"location":"api/basic_json/string_t/#storage","text":"String values are stored as pointers in a basic_json type. That is, for any access to string values, a pointer of type string_t* must be dereferenced.","title":"Storage"},{"location":"api/basic_json/string_t/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"api/basic_json/to_bson/","text":"basic_json::to_bson \u00b6 // (1) static std :: vector < std :: uint8_t > to_bson ( const basic_json & j ); // (2) static void to_bson ( const basic_json & j , detail :: output_adapter < std :: uint8_t > o ); static void to_bson ( const basic_json & j , detail :: output_adapter < char > o ); BSON (Binary JSON) is a binary format in which zero or more ordered key/value pairs are stored as a single entity (a so-called document). Returns a byte vector containing the BSON serialization. Writes the BSON serialization to an output adapter. Parameters \u00b6 j (in) JSON value to serialize o (in) output adapter to write serialization to Return value \u00b6 BSON serialization as byte vector / Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Linear in the size of the JSON value j . Example \u00b6 Example The example shows the serialization of a JSON value to a byte vector in BSON format. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to BSON std :: vector < uint8_t > v = json :: to_bson ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0 x 1 b 0 x 00 0 x 00 0 x 00 0 x 08 0 x 63 0 x 6 f 0 x 6 d 0 x 70 0 x 61 0 x 63 0 x 74 0 x 00 0 x 01 0 x 10 0 x 73 0 x 63 0 x 68 0 x 65 0 x 6 d 0 x 61 0 x 00 0 x 00 0 x 00 0 x 00 0 x 00 0 x 00 Version history \u00b6 Added in version 3.4.0.","title":"basic_json::to_bson"},{"location":"api/basic_json/to_bson/#basic_jsonto_bson","text":"// (1) static std :: vector < std :: uint8_t > to_bson ( const basic_json & j ); // (2) static void to_bson ( const basic_json & j , detail :: output_adapter < std :: uint8_t > o ); static void to_bson ( const basic_json & j , detail :: output_adapter < char > o ); BSON (Binary JSON) is a binary format in which zero or more ordered key/value pairs are stored as a single entity (a so-called document). Returns a byte vector containing the BSON serialization. Writes the BSON serialization to an output adapter.","title":"basic_json::to_bson"},{"location":"api/basic_json/to_bson/#parameters","text":"j (in) JSON value to serialize o (in) output adapter to write serialization to","title":"Parameters"},{"location":"api/basic_json/to_bson/#return-value","text":"BSON serialization as byte vector /","title":"Return value"},{"location":"api/basic_json/to_bson/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/to_bson/#complexity","text":"Linear in the size of the JSON value j .","title":"Complexity"},{"location":"api/basic_json/to_bson/#example","text":"Example The example shows the serialization of a JSON value to a byte vector in BSON format. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to BSON std :: vector < uint8_t > v = json :: to_bson ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0 x 1 b 0 x 00 0 x 00 0 x 00 0 x 08 0 x 63 0 x 6 f 0 x 6 d 0 x 70 0 x 61 0 x 63 0 x 74 0 x 00 0 x 01 0 x 10 0 x 73 0 x 63 0 x 68 0 x 65 0 x 6 d 0 x 61 0 x 00 0 x 00 0 x 00 0 x 00 0 x 00 0 x 00","title":"Example"},{"location":"api/basic_json/to_bson/#version-history","text":"Added in version 3.4.0.","title":"Version history"},{"location":"api/basic_json/to_cbor/","text":"basic_json::to_cbor \u00b6 // (1) static std :: vector < std :: uint8_t > to_cbor ( const basic_json & j ); // (2) static void to_cbor ( const basic_json & j , detail :: output_adapter < std :: uint8_t > o ); static void to_cbor ( const basic_json & j , detail :: output_adapter < char > o ); Serializes a given JSON value j to a byte vector using the CBOR (Concise Binary Object Representation) serialization format. CBOR is a binary serialization format which aims to be more compact than JSON itself, yet more efficient to parse. Returns a byte vector containing the CBOR serialization. Writes the CBOR serialization to an output adapter. Parameters \u00b6 j (in) JSON value to serialize o (in) output adapter to write serialization to Return value \u00b6 CBOR serialization as byte vector / Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Linear in the size of the JSON value j . Example \u00b6 Example The example shows the serialization of a JSON value to a byte vector in CBOR format. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to CBOR std :: vector < uint8_t > v = json :: to_cbor ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0 xa 2 0 x 67 0 x 63 0 x 6 f 0 x 6 d 0 x 70 0 x 61 0 x 63 0 x 74 0 xf 5 0 x 66 0 x 73 0 x 63 0 x 68 0 x 65 0 x 6 d 0 x 61 0 x 00 Version history \u00b6 Added in version 2.0.9. Compact representation of floating-point numbers added in version 3.8.0.","title":"basic_json::to_cbor"},{"location":"api/basic_json/to_cbor/#basic_jsonto_cbor","text":"// (1) static std :: vector < std :: uint8_t > to_cbor ( const basic_json & j ); // (2) static void to_cbor ( const basic_json & j , detail :: output_adapter < std :: uint8_t > o ); static void to_cbor ( const basic_json & j , detail :: output_adapter < char > o ); Serializes a given JSON value j to a byte vector using the CBOR (Concise Binary Object Representation) serialization format. CBOR is a binary serialization format which aims to be more compact than JSON itself, yet more efficient to parse. Returns a byte vector containing the CBOR serialization. Writes the CBOR serialization to an output adapter.","title":"basic_json::to_cbor"},{"location":"api/basic_json/to_cbor/#parameters","text":"j (in) JSON value to serialize o (in) output adapter to write serialization to","title":"Parameters"},{"location":"api/basic_json/to_cbor/#return-value","text":"CBOR serialization as byte vector /","title":"Return value"},{"location":"api/basic_json/to_cbor/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/to_cbor/#complexity","text":"Linear in the size of the JSON value j .","title":"Complexity"},{"location":"api/basic_json/to_cbor/#example","text":"Example The example shows the serialization of a JSON value to a byte vector in CBOR format. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to CBOR std :: vector < uint8_t > v = json :: to_cbor ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0 xa 2 0 x 67 0 x 63 0 x 6 f 0 x 6 d 0 x 70 0 x 61 0 x 63 0 x 74 0 xf 5 0 x 66 0 x 73 0 x 63 0 x 68 0 x 65 0 x 6 d 0 x 61 0 x 00","title":"Example"},{"location":"api/basic_json/to_cbor/#version-history","text":"Added in version 2.0.9. Compact representation of floating-point numbers added in version 3.8.0.","title":"Version history"},{"location":"api/basic_json/to_msgpack/","text":"basic_json::to_msgpack \u00b6 // (1) static std :: vector < std :: uint8_t > to_msgpack ( const basic_json & j ); // (2) static void to_msgpack ( const basic_json & j , detail :: output_adapter < std :: uint8_t > o ); static void to_msgpack ( const basic_json & j , detail :: output_adapter < char > o ); Serializes a given JSON value j to a byte vector using the MessagePack serialization format. MessagePack is a binary serialization format which aims to be more compact than JSON itself, yet more efficient to parse. Returns a byte vector containing the MessagePack serialization. Writes the MessagePack serialization to an output adapter. Parameters \u00b6 j (in) JSON value to serialize o (in) output adapter to write serialization to Return value \u00b6 MessagePack serialization as byte vector / Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Linear in the size of the JSON value j . Example \u00b6 Example The example shows the serialization of a JSON value to a byte vector in MessagePack format. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to MessagePack std :: vector < uint8_t > v = json :: to_msgpack ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0 x 82 0 xa 7 0 x 63 0 x 6 f 0 x 6 d 0 x 70 0 x 61 0 x 63 0 x 74 0 xc 3 0 xa 6 0 x 73 0 x 63 0 x 68 0 x 65 0 x 6 d 0 x 61 0 x 00 Version history \u00b6 Added in version 2.0.9.","title":"basic_json::to_msgpack"},{"location":"api/basic_json/to_msgpack/#basic_jsonto_msgpack","text":"// (1) static std :: vector < std :: uint8_t > to_msgpack ( const basic_json & j ); // (2) static void to_msgpack ( const basic_json & j , detail :: output_adapter < std :: uint8_t > o ); static void to_msgpack ( const basic_json & j , detail :: output_adapter < char > o ); Serializes a given JSON value j to a byte vector using the MessagePack serialization format. MessagePack is a binary serialization format which aims to be more compact than JSON itself, yet more efficient to parse. Returns a byte vector containing the MessagePack serialization. Writes the MessagePack serialization to an output adapter.","title":"basic_json::to_msgpack"},{"location":"api/basic_json/to_msgpack/#parameters","text":"j (in) JSON value to serialize o (in) output adapter to write serialization to","title":"Parameters"},{"location":"api/basic_json/to_msgpack/#return-value","text":"MessagePack serialization as byte vector /","title":"Return value"},{"location":"api/basic_json/to_msgpack/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/to_msgpack/#complexity","text":"Linear in the size of the JSON value j .","title":"Complexity"},{"location":"api/basic_json/to_msgpack/#example","text":"Example The example shows the serialization of a JSON value to a byte vector in MessagePack format. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to MessagePack std :: vector < uint8_t > v = json :: to_msgpack ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0 x 82 0 xa 7 0 x 63 0 x 6 f 0 x 6 d 0 x 70 0 x 61 0 x 63 0 x 74 0 xc 3 0 xa 6 0 x 73 0 x 63 0 x 68 0 x 65 0 x 6 d 0 x 61 0 x 00","title":"Example"},{"location":"api/basic_json/to_msgpack/#version-history","text":"Added in version 2.0.9.","title":"Version history"},{"location":"api/basic_json/to_ubjson/","text":"basic_json::to_ubjson \u00b6 // (1) static std :: vector < std :: uint8_t > to_ubjson ( const basic_json & j , const bool use_size = false , const bool use_type = false ); // (2) static void to_ubjson ( const basic_json & j , detail :: output_adapter < std :: uint8_t > o , const bool use_size = false , const bool use_type = false ); static void to_ubjson ( const basic_json & j , detail :: output_adapter < char > o , const bool use_size = false , const bool use_type = false ); Serializes a given JSON value j to a byte vector using the UBJSON (Universal Binary JSON) serialization format. UBJSON aims to be more compact than JSON itself, yet more efficient to parse. Returns a byte vector containing the UBJSON serialization. Writes the UBJSON serialization to an output adapter. Parameters \u00b6 j (in) JSON value to serialize o (in) output adapter to write serialization to use_size (in) whether to add size annotations to container types; optional, false by default. use_type (in) whether to add type annotations to container types (must be combined with use_size = true ); optional, false by default. Return value \u00b6 UBJSON serialization as byte vector / Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes in the JSON value. Complexity \u00b6 Linear in the size of the JSON value j . Example \u00b6 Example The example shows the serialization of a JSON value to a byte vector in UBJSON format. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; // function to print UBJSON's diagnostic format void print_byte ( uint8_t byte ) { if ( 32 < byte and byte < 128 ) { std :: cout << ( char ) byte ; } else { std :: cout << ( int ) byte ; } } int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": false} ) \" _json ; // serialize it to UBJSON std :: vector < uint8_t > v = json :: to_ubjson ( j ); // print the vector content for ( auto & byte : v ) { print_byte ( byte ); } std :: cout << std :: endl ; // create an array of numbers json array = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 }; // serialize it to UBJSON using default representation std :: vector < uint8_t > v_array = json :: to_ubjson ( array ); // serialize it to UBJSON using size optimization std :: vector < uint8_t > v_array_size = json :: to_ubjson ( array , true ); // serialize it to UBJSON using type optimization std :: vector < uint8_t > v_array_size_and_type = json :: to_ubjson ( array , true , true ); // print the vector contents for ( auto & byte : v_array ) { print_byte ( byte ); } std :: cout << std :: endl ; for ( auto & byte : v_array_size ) { print_byte ( byte ); } std :: cout << std :: endl ; for ( auto & byte : v_array_size_and_type ) { print_byte ( byte ); } std :: cout << std :: endl ; } Output: { i7compactTi6schemaF } [ i 1 i 2 i 3 i 4 i 5 i 6 i 7 i 8 ] [ #i 8 i 1 i 2 i 3 i 4 i 5 i 6 i 7 i 8 [ $i#i 812345678 Version history \u00b6 Added in version 3.1.0.","title":"basic_json::to_ubjson"},{"location":"api/basic_json/to_ubjson/#basic_jsonto_ubjson","text":"// (1) static std :: vector < std :: uint8_t > to_ubjson ( const basic_json & j , const bool use_size = false , const bool use_type = false ); // (2) static void to_ubjson ( const basic_json & j , detail :: output_adapter < std :: uint8_t > o , const bool use_size = false , const bool use_type = false ); static void to_ubjson ( const basic_json & j , detail :: output_adapter < char > o , const bool use_size = false , const bool use_type = false ); Serializes a given JSON value j to a byte vector using the UBJSON (Universal Binary JSON) serialization format. UBJSON aims to be more compact than JSON itself, yet more efficient to parse. Returns a byte vector containing the UBJSON serialization. Writes the UBJSON serialization to an output adapter.","title":"basic_json::to_ubjson"},{"location":"api/basic_json/to_ubjson/#parameters","text":"j (in) JSON value to serialize o (in) output adapter to write serialization to use_size (in) whether to add size annotations to container types; optional, false by default. use_type (in) whether to add type annotations to container types (must be combined with use_size = true ); optional, false by default.","title":"Parameters"},{"location":"api/basic_json/to_ubjson/#return-value","text":"UBJSON serialization as byte vector /","title":"Return value"},{"location":"api/basic_json/to_ubjson/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes in the JSON value.","title":"Exception safety"},{"location":"api/basic_json/to_ubjson/#complexity","text":"Linear in the size of the JSON value j .","title":"Complexity"},{"location":"api/basic_json/to_ubjson/#example","text":"Example The example shows the serialization of a JSON value to a byte vector in UBJSON format. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; // function to print UBJSON's diagnostic format void print_byte ( uint8_t byte ) { if ( 32 < byte and byte < 128 ) { std :: cout << ( char ) byte ; } else { std :: cout << ( int ) byte ; } } int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": false} ) \" _json ; // serialize it to UBJSON std :: vector < uint8_t > v = json :: to_ubjson ( j ); // print the vector content for ( auto & byte : v ) { print_byte ( byte ); } std :: cout << std :: endl ; // create an array of numbers json array = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 }; // serialize it to UBJSON using default representation std :: vector < uint8_t > v_array = json :: to_ubjson ( array ); // serialize it to UBJSON using size optimization std :: vector < uint8_t > v_array_size = json :: to_ubjson ( array , true ); // serialize it to UBJSON using type optimization std :: vector < uint8_t > v_array_size_and_type = json :: to_ubjson ( array , true , true ); // print the vector contents for ( auto & byte : v_array ) { print_byte ( byte ); } std :: cout << std :: endl ; for ( auto & byte : v_array_size ) { print_byte ( byte ); } std :: cout << std :: endl ; for ( auto & byte : v_array_size_and_type ) { print_byte ( byte ); } std :: cout << std :: endl ; } Output: { i7compactTi6schemaF } [ i 1 i 2 i 3 i 4 i 5 i 6 i 7 i 8 ] [ #i 8 i 1 i 2 i 3 i 4 i 5 i 6 i 7 i 8 [ $i#i 812345678","title":"Example"},{"location":"api/basic_json/to_ubjson/#version-history","text":"Added in version 3.1.0.","title":"Version history"},{"location":"api/basic_json/type/","text":"basic_json::type \u00b6 constexpr value_t type () const noexcept ; Return the type of the JSON value as a value from the value_t enumeration. Return value \u00b6 the type of the JSON value Value type return value null value_t::null boolean value_t::boolean string value_t::string number (integer) value_t::number_integer number (unsigned integer) value_t::number_unsigned number (floating-point) value_t::number_float object value_t::object array value_t::array binary value_t::binary discarded value_t::discarded Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code exemplifies type() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = - 17 ; json j_number_unsigned = 42u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; // call type() std :: cout << std :: boolalpha ; std :: cout << ( j_null . type () == json :: value_t :: null ) << '\\n' ; std :: cout << ( j_boolean . type () == json :: value_t :: boolean ) << '\\n' ; std :: cout << ( j_number_integer . type () == json :: value_t :: number_integer ) << '\\n' ; std :: cout << ( j_number_unsigned . type () == json :: value_t :: number_unsigned ) << '\\n' ; std :: cout << ( j_number_float . type () == json :: value_t :: number_float ) << '\\n' ; std :: cout << ( j_object . type () == json :: value_t :: object ) << '\\n' ; std :: cout << ( j_array . type () == json :: value_t :: array ) << '\\n' ; std :: cout << ( j_string . type () == json :: value_t :: string ) << '\\n' ; } Output: true true true true true true true true Version history \u00b6 Added in version 1.0.0. Added unsigned integer type in version 2.0.0. Added binary type in version 3.8.0.","title":"basic_json::type"},{"location":"api/basic_json/type/#basic_jsontype","text":"constexpr value_t type () const noexcept ; Return the type of the JSON value as a value from the value_t enumeration.","title":"basic_json::type"},{"location":"api/basic_json/type/#return-value","text":"the type of the JSON value Value type return value null value_t::null boolean value_t::boolean string value_t::string number (integer) value_t::number_integer number (unsigned integer) value_t::number_unsigned number (floating-point) value_t::number_float object value_t::object array value_t::array binary value_t::binary discarded value_t::discarded","title":"Return value"},{"location":"api/basic_json/type/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/type/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/type/#example","text":"Example The following code exemplifies type() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = - 17 ; json j_number_unsigned = 42u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; // call type() std :: cout << std :: boolalpha ; std :: cout << ( j_null . type () == json :: value_t :: null ) << '\\n' ; std :: cout << ( j_boolean . type () == json :: value_t :: boolean ) << '\\n' ; std :: cout << ( j_number_integer . type () == json :: value_t :: number_integer ) << '\\n' ; std :: cout << ( j_number_unsigned . type () == json :: value_t :: number_unsigned ) << '\\n' ; std :: cout << ( j_number_float . type () == json :: value_t :: number_float ) << '\\n' ; std :: cout << ( j_object . type () == json :: value_t :: object ) << '\\n' ; std :: cout << ( j_array . type () == json :: value_t :: array ) << '\\n' ; std :: cout << ( j_string . type () == json :: value_t :: string ) << '\\n' ; } Output: true true true true true true true true","title":"Example"},{"location":"api/basic_json/type/#version-history","text":"Added in version 1.0.0. Added unsigned integer type in version 2.0.0. Added binary type in version 3.8.0.","title":"Version history"},{"location":"api/basic_json/type_name/","text":"basic_json::type_name \u00b6 const char * type_name () const noexcept ; Returns the type name as string to be used in error messages -- usually to indicate that a function was called on a wrong JSON type. Return value \u00b6 a string representation of a the type ( value_t ): Value type return value null \"null\" boolean \"boolean\" string \"string\" number (integer, unsigned integer, floating-point) \"number\" object \"object array \"array binary \"binary discarded \"discarded Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Constant. Example \u00b6 Example The following code exemplifies type_name() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = - 17 ; json j_number_unsigned = 42u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; // call type_name() std :: cout << j_null << \" is a \" << j_null . type_name () << '\\n' ; std :: cout << j_boolean << \" is a \" << j_boolean . type_name () << '\\n' ; std :: cout << j_number_integer << \" is a \" << j_number_integer . type_name () << '\\n' ; std :: cout << j_number_unsigned << \" is a \" << j_number_unsigned . type_name () << '\\n' ; std :: cout << j_number_float << \" is a \" << j_number_float . type_name () << '\\n' ; std :: cout << j_object << \" is an \" << j_object . type_name () << '\\n' ; std :: cout << j_array << \" is an \" << j_array . type_name () << '\\n' ; std :: cout << j_string << \" is a \" << j_string . type_name () << '\\n' ; } Output: null is a null true is a boolean -17 is a number 42 is a number 23.42 is a number { \"one\" : 1 , \"two\" : 2 } is an object [ 1 , 2 , 4 , 8 , 16 ] is an array \"Hello, world\" is a string Version history \u00b6 Added in version 1.0.0. Part of the public API version since 2.1.0. Changed return value to const char* and added noexcept in version 3.0.0. Added support for binary type in version 3.8.0.","title":"basic_json::type_name"},{"location":"api/basic_json/type_name/#basic_jsontype_name","text":"const char * type_name () const noexcept ; Returns the type name as string to be used in error messages -- usually to indicate that a function was called on a wrong JSON type.","title":"basic_json::type_name"},{"location":"api/basic_json/type_name/#return-value","text":"a string representation of a the type ( value_t ): Value type return value null \"null\" boolean \"boolean\" string \"string\" number (integer, unsigned integer, floating-point) \"number\" object \"object array \"array binary \"binary discarded \"discarded","title":"Return value"},{"location":"api/basic_json/type_name/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/type_name/#complexity","text":"Constant.","title":"Complexity"},{"location":"api/basic_json/type_name/#example","text":"Example The following code exemplifies type_name() for all JSON types. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON values json j_null ; json j_boolean = true ; json j_number_integer = - 17 ; json j_number_unsigned = 42u ; json j_number_float = 23.42 ; json j_object = {{ \"one\" , 1 }, { \"two\" , 2 }}; json j_array = { 1 , 2 , 4 , 8 , 16 }; json j_string = \"Hello, world\" ; // call type_name() std :: cout << j_null << \" is a \" << j_null . type_name () << '\\n' ; std :: cout << j_boolean << \" is a \" << j_boolean . type_name () << '\\n' ; std :: cout << j_number_integer << \" is a \" << j_number_integer . type_name () << '\\n' ; std :: cout << j_number_unsigned << \" is a \" << j_number_unsigned . type_name () << '\\n' ; std :: cout << j_number_float << \" is a \" << j_number_float . type_name () << '\\n' ; std :: cout << j_object << \" is an \" << j_object . type_name () << '\\n' ; std :: cout << j_array << \" is an \" << j_array . type_name () << '\\n' ; std :: cout << j_string << \" is a \" << j_string . type_name () << '\\n' ; } Output: null is a null true is a boolean -17 is a number 42 is a number 23.42 is a number { \"one\" : 1 , \"two\" : 2 } is an object [ 1 , 2 , 4 , 8 , 16 ] is an array \"Hello, world\" is a string","title":"Example"},{"location":"api/basic_json/type_name/#version-history","text":"Added in version 1.0.0. Part of the public API version since 2.1.0. Changed return value to const char* and added noexcept in version 3.0.0. Added support for binary type in version 3.8.0.","title":"Version history"},{"location":"api/basic_json/unflatten/","text":"basic_json::unflatten \u00b6 basic_json unflatten () const ; The function restores the arbitrary nesting of a JSON value that has been flattened before using the flatten() function. The JSON value must meet certain constraints: The value must be an object. The keys must be JSON pointers (see RFC 6901 ) The mapped values must be primitive JSON types. Return value \u00b6 the original JSON from a flattened version Exceptions \u00b6 The function can throw the following exceptions: Throws type_error.314 if value is not an object Throws type_error.315 if object values are not primitive Exception safety \u00b6 Strong exception safety: if an exception occurs, the original value stays intact. Complexity \u00b6 Linear in the size the JSON value. Notes \u00b6 Empty objects and arrays are flattened by flatten() to null values and can not unflattened to their original type. Apart from this example, for a JSON value j , the following is always true: j == j . flatten (). unflatten () . Example \u00b6 Example The following code shows how a flattened JSON object is unflattened into the original nested JSON object. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON value json j_flattened = { { \"/answer/everything\" , 42 }, { \"/happy\" , true }, { \"/list/0\" , 1 }, { \"/list/1\" , 0 }, { \"/list/2\" , 2 }, { \"/name\" , \"Niels\" }, { \"/nothing\" , nullptr }, { \"/object/currency\" , \"USD\" }, { \"/object/value\" , 42.99 }, { \"/pi\" , 3.141 } }; // call unflatten() std :: cout << std :: setw ( 4 ) << j_flattened . unflatten () << '\\n' ; } Output: { \"answer\" : { \"everything\" : 42 }, \"happy\" : true , \"list\" : [ 1 , 0 , 2 ], \"name\" : \"Niels\" , \"nothing\" : null , \"object\" : { \"currency\" : \"USD\" , \"value\" : 42.99 }, \"pi\" : 3.141 } Version history \u00b6 Added in version 2.0.0.","title":"basic_json::unflatten"},{"location":"api/basic_json/unflatten/#basic_jsonunflatten","text":"basic_json unflatten () const ; The function restores the arbitrary nesting of a JSON value that has been flattened before using the flatten() function. The JSON value must meet certain constraints: The value must be an object. The keys must be JSON pointers (see RFC 6901 ) The mapped values must be primitive JSON types.","title":"basic_json::unflatten"},{"location":"api/basic_json/unflatten/#return-value","text":"the original JSON from a flattened version","title":"Return value"},{"location":"api/basic_json/unflatten/#exceptions","text":"The function can throw the following exceptions: Throws type_error.314 if value is not an object Throws type_error.315 if object values are not primitive","title":"Exceptions"},{"location":"api/basic_json/unflatten/#exception-safety","text":"Strong exception safety: if an exception occurs, the original value stays intact.","title":"Exception safety"},{"location":"api/basic_json/unflatten/#complexity","text":"Linear in the size the JSON value.","title":"Complexity"},{"location":"api/basic_json/unflatten/#notes","text":"Empty objects and arrays are flattened by flatten() to null values and can not unflattened to their original type. Apart from this example, for a JSON value j , the following is always true: j == j . flatten (). unflatten () .","title":"Notes"},{"location":"api/basic_json/unflatten/#example","text":"Example The following code shows how a flattened JSON object is unflattened into the original nested JSON object. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create JSON value json j_flattened = { { \"/answer/everything\" , 42 }, { \"/happy\" , true }, { \"/list/0\" , 1 }, { \"/list/1\" , 0 }, { \"/list/2\" , 2 }, { \"/name\" , \"Niels\" }, { \"/nothing\" , nullptr }, { \"/object/currency\" , \"USD\" }, { \"/object/value\" , 42.99 }, { \"/pi\" , 3.141 } }; // call unflatten() std :: cout << std :: setw ( 4 ) << j_flattened . unflatten () << '\\n' ; } Output: { \"answer\" : { \"everything\" : 42 }, \"happy\" : true , \"list\" : [ 1 , 0 , 2 ], \"name\" : \"Niels\" , \"nothing\" : null , \"object\" : { \"currency\" : \"USD\" , \"value\" : 42.99 }, \"pi\" : 3.141 }","title":"Example"},{"location":"api/basic_json/unflatten/#version-history","text":"Added in version 2.0.0.","title":"Version history"},{"location":"api/basic_json/update/","text":"basic_json::update \u00b6 // (1) void update ( const_reference j ); // (2) void update ( const_iterator first , const_iterator last ); Inserts all values from JSON object j and overwrites existing keys. Inserts all values from from range [first, last) and overwrites existing keys. The function is motivated by Python's dict.update function. Parameters \u00b6 j (in) JSON object to read values from first (in) begin of the range of elements to insert last (in) end of the range of elements to insert Exceptions \u00b6 The function can throw thw following exceptions: Throws type_error.312 if called on JSON values other than objects; example: \"cannot use update() with string\" The function can throw thw following exceptions: Throws type_error.312 if called on JSON values other than objects; example: \"cannot use update() with string\" Throws invalid_iterator.202 if called on an iterator which does not belong to the current JSON value; example: \"iterator does not fit current value\" Throws invalid_iterator.210 if first and last do not belong to the same JSON value; example: \"iterators do not fit\" Complexity \u00b6 O(N*log(size() + N)), where N is the number of elements to insert. O(N*log(size() + N)), where N is the number of elements to insert. Example \u00b6 Example The example shows how update() is used. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create two JSON objects json o1 = R \" ( {\"color\": \"red\", \"price\": 17.99} ) \" _json ; json o2 = R \" ( {\"color\": \"blue\", \"speed\": 100} ) \" _json ; // add all keys from o2 to o1 (updating \"color\") o1 . update ( o2 ); // output updated object o1 std :: cout << std :: setw ( 2 ) << o1 << '\\n' ; } Output: { \"color\" : \"blue\" , \"price\" : 17.99 , \"speed\" : 100 } Example The example shows how update() is used. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create two JSON objects json o1 = R \" ( {\"color\": \"red\", \"price\": 17.99} ) \" _json ; json o2 = R \" ( {\"color\": \"blue\", \"speed\": 100} ) \" _json ; // add all keys from o2 to o1 (updating \"color\") o1 . update ( o2 . begin (), o2 . end ()); // output updated object o1 std :: cout << std :: setw ( 2 ) << o1 << '\\n' ; } Output: { \"color\" : \"blue\" , \"price\" : 17.99 , \"speed\" : 100 } Version history \u00b6 Added in version 3.0.0.","title":"basic_json::update"},{"location":"api/basic_json/update/#basic_jsonupdate","text":"// (1) void update ( const_reference j ); // (2) void update ( const_iterator first , const_iterator last ); Inserts all values from JSON object j and overwrites existing keys. Inserts all values from from range [first, last) and overwrites existing keys. The function is motivated by Python's dict.update function.","title":"basic_json::update"},{"location":"api/basic_json/update/#parameters","text":"j (in) JSON object to read values from first (in) begin of the range of elements to insert last (in) end of the range of elements to insert","title":"Parameters"},{"location":"api/basic_json/update/#exceptions","text":"The function can throw thw following exceptions: Throws type_error.312 if called on JSON values other than objects; example: \"cannot use update() with string\" The function can throw thw following exceptions: Throws type_error.312 if called on JSON values other than objects; example: \"cannot use update() with string\" Throws invalid_iterator.202 if called on an iterator which does not belong to the current JSON value; example: \"iterator does not fit current value\" Throws invalid_iterator.210 if first and last do not belong to the same JSON value; example: \"iterators do not fit\"","title":"Exceptions"},{"location":"api/basic_json/update/#complexity","text":"O(N*log(size() + N)), where N is the number of elements to insert. O(N*log(size() + N)), where N is the number of elements to insert.","title":"Complexity"},{"location":"api/basic_json/update/#example","text":"Example The example shows how update() is used. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create two JSON objects json o1 = R \" ( {\"color\": \"red\", \"price\": 17.99} ) \" _json ; json o2 = R \" ( {\"color\": \"blue\", \"speed\": 100} ) \" _json ; // add all keys from o2 to o1 (updating \"color\") o1 . update ( o2 ); // output updated object o1 std :: cout << std :: setw ( 2 ) << o1 << '\\n' ; } Output: { \"color\" : \"blue\" , \"price\" : 17.99 , \"speed\" : 100 } Example The example shows how update() is used. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create two JSON objects json o1 = R \" ( {\"color\": \"red\", \"price\": 17.99} ) \" _json ; json o2 = R \" ( {\"color\": \"blue\", \"speed\": 100} ) \" _json ; // add all keys from o2 to o1 (updating \"color\") o1 . update ( o2 . begin (), o2 . end ()); // output updated object o1 std :: cout << std :: setw ( 2 ) << o1 << '\\n' ; } Output: { \"color\" : \"blue\" , \"price\" : 17.99 , \"speed\" : 100 }","title":"Example"},{"location":"api/basic_json/update/#version-history","text":"Added in version 3.0.0.","title":"Version history"},{"location":"api/basic_json/value/","text":"basic_json::value \u00b6 // (1) template < class ValueType > ValueType value ( const typename object_t :: key_type & key , const ValueType & default_value ) const ; // (2) template < class ValueType > ValueType value ( const json_pointer & ptr , const ValueType & default_value ) const ; Returns either a copy of an object's element at the specified key key or a given default value if no element with key key exists. The function is basically equivalent to executing try { return at ( key ); } catch ( out_of_range ) { return default_value ; } Returns either a copy of an object's element at the specified JSON pointer ptr or a given default value if no value at ptr exists. The function is basically equivalent to executing try { return at ( ptr ); } catch ( out_of_range ) { return default_value ; } Unlike operator[] , this function does not implicitly add an element to the position defined by key / ptr key. This function is furthermore also applicable to const objects. Template parameters \u00b6 ValueType type compatible to JSON values, for instance int for JSON integer numbers, bool for JSON booleans, or std :: vector types for JSON arrays. Note the type of the expected value at key / ptr and the default value default_value must be compatible. Parameters \u00b6 key (in) key of the element to access default_value (in) the value to return if key/ptr found no value ptr (in) a JSON pointer to the element to access Return value \u00b6 copy of the element at key key or default_value if key is not found copy of the element at JSON Pointer ptr or default_value if no value for ptr is found Exception safety \u00b6 Strong guarantee: if an exception is thrown, there are no changes to any JSON value. Exceptions \u00b6 The function can throw thw following exceptions: Throws type_error.302 if default_value does not match the type of the value at key Throws type_error.306 if the JSON value is not an object; in that case, using value() with a key makes no sense. The function can throw thw following exceptions: Throws type_error.302 if default_value does not match the type of the value at ptr Throws type_error.306 if the JSON value is not an object; in that case, using value() with a key makes no sense. Complexity \u00b6 Logarithmic in the size of the container. Logarithmic in the size of the container. Example \u00b6 Example The example below shows how object elements can be queried with a default value. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON object with different entry types json j = { { \"integer\" , 1 }, { \"floating\" , 42.23 }, { \"string\" , \"hello world\" }, { \"boolean\" , true }, { \"object\" , {{ \"key1\" , 1 }, { \"key2\" , 2 }}}, { \"array\" , { 1 , 2 , 3 }} }; // access existing values int v_integer = j . value ( \"integer\" , 0 ); double v_floating = j . value ( \"floating\" , 47.11 ); // access nonexisting values and rely on default value std :: string v_string = j . value ( \"nonexisting\" , \"oops\" ); bool v_boolean = j . value ( \"nonexisting\" , false ); // output values std :: cout << std :: boolalpha << v_integer << \" \" << v_floating << \" \" << v_string << \" \" << v_boolean << \" \\n \" ; } Output: 1 42.23 oops false Example The example below shows how object elements can be queried with a default value. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON object with different entry types json j = { { \"integer\" , 1 }, { \"floating\" , 42.23 }, { \"string\" , \"hello world\" }, { \"boolean\" , true }, { \"object\" , {{ \"key1\" , 1 }, { \"key2\" , 2 }}}, { \"array\" , { 1 , 2 , 3 }} }; // access existing values int v_integer = j . value ( \"/integer\" _json_pointer , 0 ); double v_floating = j . value ( \"/floating\" _json_pointer , 47.11 ); // access nonexisting values and rely on default value std :: string v_string = j . value ( \"/nonexisting\" _json_pointer , \"oops\" ); bool v_boolean = j . value ( \"/nonexisting\" _json_pointer , false ); // output values std :: cout << std :: boolalpha << v_integer << \" \" << v_floating << \" \" << v_string << \" \" << v_boolean << \" \\n \" ; } Output: 1 42.23 oops false Version history \u00b6 Added in version 1.0.0. Added in version 2.0.2.","title":"basic_json::value"},{"location":"api/basic_json/value/#basic_jsonvalue","text":"// (1) template < class ValueType > ValueType value ( const typename object_t :: key_type & key , const ValueType & default_value ) const ; // (2) template < class ValueType > ValueType value ( const json_pointer & ptr , const ValueType & default_value ) const ; Returns either a copy of an object's element at the specified key key or a given default value if no element with key key exists. The function is basically equivalent to executing try { return at ( key ); } catch ( out_of_range ) { return default_value ; } Returns either a copy of an object's element at the specified JSON pointer ptr or a given default value if no value at ptr exists. The function is basically equivalent to executing try { return at ( ptr ); } catch ( out_of_range ) { return default_value ; } Unlike operator[] , this function does not implicitly add an element to the position defined by key / ptr key. This function is furthermore also applicable to const objects.","title":"basic_json::value"},{"location":"api/basic_json/value/#template-parameters","text":"ValueType type compatible to JSON values, for instance int for JSON integer numbers, bool for JSON booleans, or std :: vector types for JSON arrays. Note the type of the expected value at key / ptr and the default value default_value must be compatible.","title":"Template parameters"},{"location":"api/basic_json/value/#parameters","text":"key (in) key of the element to access default_value (in) the value to return if key/ptr found no value ptr (in) a JSON pointer to the element to access","title":"Parameters"},{"location":"api/basic_json/value/#return-value","text":"copy of the element at key key or default_value if key is not found copy of the element at JSON Pointer ptr or default_value if no value for ptr is found","title":"Return value"},{"location":"api/basic_json/value/#exception-safety","text":"Strong guarantee: if an exception is thrown, there are no changes to any JSON value.","title":"Exception safety"},{"location":"api/basic_json/value/#exceptions","text":"The function can throw thw following exceptions: Throws type_error.302 if default_value does not match the type of the value at key Throws type_error.306 if the JSON value is not an object; in that case, using value() with a key makes no sense. The function can throw thw following exceptions: Throws type_error.302 if default_value does not match the type of the value at ptr Throws type_error.306 if the JSON value is not an object; in that case, using value() with a key makes no sense.","title":"Exceptions"},{"location":"api/basic_json/value/#complexity","text":"Logarithmic in the size of the container. Logarithmic in the size of the container.","title":"Complexity"},{"location":"api/basic_json/value/#example","text":"Example The example below shows how object elements can be queried with a default value. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON object with different entry types json j = { { \"integer\" , 1 }, { \"floating\" , 42.23 }, { \"string\" , \"hello world\" }, { \"boolean\" , true }, { \"object\" , {{ \"key1\" , 1 }, { \"key2\" , 2 }}}, { \"array\" , { 1 , 2 , 3 }} }; // access existing values int v_integer = j . value ( \"integer\" , 0 ); double v_floating = j . value ( \"floating\" , 47.11 ); // access nonexisting values and rely on default value std :: string v_string = j . value ( \"nonexisting\" , \"oops\" ); bool v_boolean = j . value ( \"nonexisting\" , false ); // output values std :: cout << std :: boolalpha << v_integer << \" \" << v_floating << \" \" << v_string << \" \" << v_boolean << \" \\n \" ; } Output: 1 42.23 oops false Example The example below shows how object elements can be queried with a default value. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON object with different entry types json j = { { \"integer\" , 1 }, { \"floating\" , 42.23 }, { \"string\" , \"hello world\" }, { \"boolean\" , true }, { \"object\" , {{ \"key1\" , 1 }, { \"key2\" , 2 }}}, { \"array\" , { 1 , 2 , 3 }} }; // access existing values int v_integer = j . value ( \"/integer\" _json_pointer , 0 ); double v_floating = j . value ( \"/floating\" _json_pointer , 47.11 ); // access nonexisting values and rely on default value std :: string v_string = j . value ( \"/nonexisting\" _json_pointer , \"oops\" ); bool v_boolean = j . value ( \"/nonexisting\" _json_pointer , false ); // output values std :: cout << std :: boolalpha << v_integer << \" \" << v_floating << \" \" << v_string << \" \" << v_boolean << \" \\n \" ; } Output: 1 42.23 oops false","title":"Example"},{"location":"api/basic_json/value/#version-history","text":"Added in version 1.0.0. Added in version 2.0.2.","title":"Version history"},{"location":"api/basic_json/value_t/","text":"basic_json::value_t \u00b6 enum class value_t : std :: uint8_t { null , object , array , string , boolean , number_integer , number_unsigned , number_float , binary , discarded }; This enumeration collects the different JSON types. It is internally used to distinguish the stored values, and the functions is_null , is_object , is_array , is_string , is_boolean , is_number (with is_number_integer , is_number_unsigned , and is_number_float ), is_discarded , is_binary , is_primitive , and is_structured rely on it. Note \u00b6 There are three enumeration entries (number_integer, number_unsigned, and number_float), because the library distinguishes these three types for numbers: number_unsigned_t is used for unsigned integers, number_integer_t is used for signed integers, and number_float_t is used for floating-point numbers or to approximate integers which do not fit in the limits of their respective type. Version history \u00b6 Added in version 1.0.0. Added unsigned integer type in version 2.0.0. Added binary type in version 3.8.0.","title":"basic_json::value_t"},{"location":"api/basic_json/value_t/#basic_jsonvalue_t","text":"enum class value_t : std :: uint8_t { null , object , array , string , boolean , number_integer , number_unsigned , number_float , binary , discarded }; This enumeration collects the different JSON types. It is internally used to distinguish the stored values, and the functions is_null , is_object , is_array , is_string , is_boolean , is_number (with is_number_integer , is_number_unsigned , and is_number_float ), is_discarded , is_binary , is_primitive , and is_structured rely on it.","title":"basic_json::value_t"},{"location":"api/basic_json/value_t/#note","text":"There are three enumeration entries (number_integer, number_unsigned, and number_float), because the library distinguishes these three types for numbers: number_unsigned_t is used for unsigned integers, number_integer_t is used for signed integers, and number_float_t is used for floating-point numbers or to approximate integers which do not fit in the limits of their respective type.","title":"Note"},{"location":"api/basic_json/value_t/#version-history","text":"Added in version 1.0.0. Added unsigned integer type in version 2.0.0. Added binary type in version 3.8.0.","title":"Version history"},{"location":"api/basic_json/~basic_json/","text":"basic_json::~basic_json \u00b6 ~ basic_json () noexcept Destroys the JSON value and frees all allocated memory. Exception safety \u00b6 No-throw guarantee: this member function never throws exceptions. Complexity \u00b6 Linear. Version history \u00b6 Added in version 1.0.0.","title":"basic_json::~basic_json"},{"location":"api/basic_json/~basic_json/#basic_jsonbasic_json","text":"~ basic_json () noexcept Destroys the JSON value and frees all allocated memory.","title":"basic_json::~basic_json"},{"location":"api/basic_json/~basic_json/#exception-safety","text":"No-throw guarantee: this member function never throws exceptions.","title":"Exception safety"},{"location":"api/basic_json/~basic_json/#complexity","text":"Linear.","title":"Complexity"},{"location":"api/basic_json/~basic_json/#version-history","text":"Added in version 1.0.0.","title":"Version history"},{"location":"features/arbitrary_types/","text":"Arbitrary Types Conversions \u00b6 Every type can be serialized in JSON, not just STL containers and scalar types. Usually, you would do something along those lines: namespace ns { // a simple struct to model a person struct person { std :: string name ; std :: string address ; int age ; }; } ns :: person p = { \"Ned Flanders\" , \"744 Evergreen Terrace\" , 60 }; // convert to JSON: copy each value into the JSON object json j ; j [ \"name\" ] = p . name ; j [ \"address\" ] = p . address ; j [ \"age\" ] = p . age ; // ... // convert from JSON: copy each value from the JSON object ns :: person p { j [ \"name\" ]. get < std :: string > (), j [ \"address\" ]. get < std :: string > (), j [ \"age\" ]. get < int > () }; It works, but that's quite a lot of boilerplate... Fortunately, there's a better way: // create a person ns :: person p { \"Ned Flanders\" , \"744 Evergreen Terrace\" , 60 }; // conversion: person -> json json j = p ; std :: cout << j << std :: endl ; // {\"address\":\"744 Evergreen Terrace\",\"age\":60,\"name\":\"Ned Flanders\"} // conversion: json -> person auto p2 = j . get < ns :: person > (); // that's it assert ( p == p2 ); Basic usage \u00b6 To make this work with one of your types, you only need to provide two functions: using nlohmann :: json ; namespace ns { void to_json ( json & j , const person & p ) { j = json { { \"name\" , p . name }, { \"address\" , p . address }, { \"age\" , p . age } }; } void from_json ( const json & j , person & p ) { j . at ( \"name\" ). get_to ( p . name ); j . at ( \"address\" ). get_to ( p . address ); j . at ( \"age\" ). get_to ( p . age ); } } // namespace ns That's all! When calling the json constructor with your type, your custom to_json method will be automatically called. Likewise, when calling get<your_type>() or get_to(your_type&) , the from_json method will be called. Some important things: Those methods MUST be in your type's namespace (which can be the global namespace), or the library will not be able to locate them (in this example, they are in namespace ns , where person is defined). Those methods MUST be available (e.g., proper headers must be included) everywhere you use these conversions. Look at issue 1108 for errors that may occur otherwise. When using get<your_type>() , your_type MUST be DefaultConstructible . (There is a way to bypass this requirement described later.) In function from_json , use function at() to access the object values rather than operator[] . In case a key does not exist, at throws an exception that you can handle, whereas operator[] exhibits undefined behavior. You do not need to add serializers or deserializers for STL types like std::vector : the library already implements these. Simplify your life with macros \u00b6 If you just want to serialize/deserialize some structs, the to_json / from_json functions can be a lot of boilerplate. There are two macros to make your life easier as long as you (1) want to use a JSON object as serialization and (2) want to use the member variable names as object keys in that object: NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(name, member1, member2, ...) is to be defined inside of the namespace of the class/struct to create code for. NLOHMANN_DEFINE_TYPE_INTRUSIVE(name, member1, member2, ...) is to be defined inside of the class/struct to create code for. This macro can also access private members. In both macros, the first parameter is the name of the class/struct, and all remaining parameters name the members. Note At most 64 member variables can be passed to NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE or NLOHMANN_DEFINE_TYPE_INTRUSIVE . Example The to_json / from_json functions for the person struct above can be created with: namespace ns { NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE ( person , name , address , age ) } Here is an example with private members, where NLOHMANN_DEFINE_TYPE_INTRUSIVE is needed: namespace ns { class address { private : std :: string street ; int housenumber ; int postcode ; public : NLOHMANN_DEFINE_TYPE_INTRUSIVE ( address , street , housenumber , postcode ) }; } How do I convert third-party types? \u00b6 This requires a bit more advanced technique. But first, let's see how this conversion mechanism works: The library uses JSON Serializers to convert types to json. The default serializer for nlohmann::json is nlohmann::adl_serializer (ADL means Argument-Dependent Lookup ). It is implemented like this (simplified): template < typename T > struct adl_serializer { static void to_json ( json & j , const T & value ) { // calls the \"to_json\" method in T's namespace } static void from_json ( const json & j , T & value ) { // same thing, but with the \"from_json\" method } }; This serializer works fine when you have control over the type's namespace. However, what about boost::optional or std::filesystem::path (C++17)? Hijacking the boost namespace is pretty bad, and it's illegal to add something other than template specializations to std ... To solve this, you need to add a specialization of adl_serializer to the nlohmann namespace, here's an example: // partial specialization (full specialization works too) namespace nlohmann { template < typename T > struct adl_serializer < boost :: optional < T >> { static void to_json ( json & j , const boost :: optional < T >& opt ) { if ( opt == boost :: none ) { j = nullptr ; } else { j = * opt ; // this will call adl_serializer<T>::to_json which will // find the free function to_json in T's namespace! } } static void from_json ( const json & j , boost :: optional < T >& opt ) { if ( j . is_null ()) { opt = boost :: none ; } else { opt = j . get < T > (); // same as above, but with // adl_serializer<T>::from_json } } }; } How can I use get() for non-default constructible/non-copyable types? \u00b6 There is a way, if your type is MoveConstructible . You will need to specialize the adl_serializer as well, but with a special from_json overload: struct move_only_type { move_only_type () = delete ; move_only_type ( int ii ) : i ( ii ) {} move_only_type ( const move_only_type & ) = delete ; move_only_type ( move_only_type && ) = default ; int i ; }; namespace nlohmann { template <> struct adl_serializer < move_only_type > { // note: the return type is no longer 'void', and the method only takes // one argument static move_only_type from_json ( const json & j ) { return { j . get < int > ()}; } // Here's the catch! You must provide a to_json method! Otherwise you // will not be able to convert move_only_type to json, since you fully // specialized adl_serializer on that type static void to_json ( json & j , move_only_type t ) { j = t . i ; } }; } Can I write my own serializer? (Advanced use) \u00b6 Yes. You might want to take a look at unit-udt.cpp in the test suite, to see a few examples. If you write your own serializer, you'll need to do a few things: use a different basic_json alias than nlohmann::json (the last template parameter of basic_json is the JSONSerializer ) use your basic_json alias (or a template parameter) in all your to_json / from_json methods use nlohmann::to_json and nlohmann::from_json when you need ADL Here is an example, without simplifications, that only accepts types with a size <= 32, and uses ADL. // You should use void as a second template argument // if you don't need compile-time checks on T template < typename T , typename SFINAE = typename std :: enable_if < sizeof ( T ) <= 32 >:: type > struct less_than_32_serializer { template < typename BasicJsonType > static void to_json ( BasicJsonType & j , T value ) { // we want to use ADL, and call the correct to_json overload using nlohmann :: to_json ; // this method is called by adl_serializer, // this is where the magic happens to_json ( j , value ); } template < typename BasicJsonType > static void from_json ( const BasicJsonType & j , T & value ) { // same thing here using nlohmann :: from_json ; from_json ( j , value ); } }; Be very careful when reimplementing your serializer, you can stack overflow if you don't pay attention: template < typename T , void > struct bad_serializer { template < typename BasicJsonType > static void to_json ( BasicJsonType & j , const T & value ) { // this calls BasicJsonType::json_serializer<T>::to_json(j, value); // if BasicJsonType::json_serializer == bad_serializer ... oops! j = value ; } template < typename BasicJsonType > static void to_json ( const BasicJsonType & j , T & value ) { // this calls BasicJsonType::json_serializer<T>::from_json(j, value); // if BasicJsonType::json_serializer == bad_serializer ... oops! value = j . template get < T > (); // oops! } };","title":"Arbitrary Types Conversions"},{"location":"features/arbitrary_types/#arbitrary-types-conversions","text":"Every type can be serialized in JSON, not just STL containers and scalar types. Usually, you would do something along those lines: namespace ns { // a simple struct to model a person struct person { std :: string name ; std :: string address ; int age ; }; } ns :: person p = { \"Ned Flanders\" , \"744 Evergreen Terrace\" , 60 }; // convert to JSON: copy each value into the JSON object json j ; j [ \"name\" ] = p . name ; j [ \"address\" ] = p . address ; j [ \"age\" ] = p . age ; // ... // convert from JSON: copy each value from the JSON object ns :: person p { j [ \"name\" ]. get < std :: string > (), j [ \"address\" ]. get < std :: string > (), j [ \"age\" ]. get < int > () }; It works, but that's quite a lot of boilerplate... Fortunately, there's a better way: // create a person ns :: person p { \"Ned Flanders\" , \"744 Evergreen Terrace\" , 60 }; // conversion: person -> json json j = p ; std :: cout << j << std :: endl ; // {\"address\":\"744 Evergreen Terrace\",\"age\":60,\"name\":\"Ned Flanders\"} // conversion: json -> person auto p2 = j . get < ns :: person > (); // that's it assert ( p == p2 );","title":"Arbitrary Types Conversions"},{"location":"features/arbitrary_types/#basic-usage","text":"To make this work with one of your types, you only need to provide two functions: using nlohmann :: json ; namespace ns { void to_json ( json & j , const person & p ) { j = json { { \"name\" , p . name }, { \"address\" , p . address }, { \"age\" , p . age } }; } void from_json ( const json & j , person & p ) { j . at ( \"name\" ). get_to ( p . name ); j . at ( \"address\" ). get_to ( p . address ); j . at ( \"age\" ). get_to ( p . age ); } } // namespace ns That's all! When calling the json constructor with your type, your custom to_json method will be automatically called. Likewise, when calling get<your_type>() or get_to(your_type&) , the from_json method will be called. Some important things: Those methods MUST be in your type's namespace (which can be the global namespace), or the library will not be able to locate them (in this example, they are in namespace ns , where person is defined). Those methods MUST be available (e.g., proper headers must be included) everywhere you use these conversions. Look at issue 1108 for errors that may occur otherwise. When using get<your_type>() , your_type MUST be DefaultConstructible . (There is a way to bypass this requirement described later.) In function from_json , use function at() to access the object values rather than operator[] . In case a key does not exist, at throws an exception that you can handle, whereas operator[] exhibits undefined behavior. You do not need to add serializers or deserializers for STL types like std::vector : the library already implements these.","title":"Basic usage"},{"location":"features/arbitrary_types/#simplify-your-life-with-macros","text":"If you just want to serialize/deserialize some structs, the to_json / from_json functions can be a lot of boilerplate. There are two macros to make your life easier as long as you (1) want to use a JSON object as serialization and (2) want to use the member variable names as object keys in that object: NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(name, member1, member2, ...) is to be defined inside of the namespace of the class/struct to create code for. NLOHMANN_DEFINE_TYPE_INTRUSIVE(name, member1, member2, ...) is to be defined inside of the class/struct to create code for. This macro can also access private members. In both macros, the first parameter is the name of the class/struct, and all remaining parameters name the members. Note At most 64 member variables can be passed to NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE or NLOHMANN_DEFINE_TYPE_INTRUSIVE . Example The to_json / from_json functions for the person struct above can be created with: namespace ns { NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE ( person , name , address , age ) } Here is an example with private members, where NLOHMANN_DEFINE_TYPE_INTRUSIVE is needed: namespace ns { class address { private : std :: string street ; int housenumber ; int postcode ; public : NLOHMANN_DEFINE_TYPE_INTRUSIVE ( address , street , housenumber , postcode ) }; }","title":"Simplify your life with macros"},{"location":"features/arbitrary_types/#how-do-i-convert-third-party-types","text":"This requires a bit more advanced technique. But first, let's see how this conversion mechanism works: The library uses JSON Serializers to convert types to json. The default serializer for nlohmann::json is nlohmann::adl_serializer (ADL means Argument-Dependent Lookup ). It is implemented like this (simplified): template < typename T > struct adl_serializer { static void to_json ( json & j , const T & value ) { // calls the \"to_json\" method in T's namespace } static void from_json ( const json & j , T & value ) { // same thing, but with the \"from_json\" method } }; This serializer works fine when you have control over the type's namespace. However, what about boost::optional or std::filesystem::path (C++17)? Hijacking the boost namespace is pretty bad, and it's illegal to add something other than template specializations to std ... To solve this, you need to add a specialization of adl_serializer to the nlohmann namespace, here's an example: // partial specialization (full specialization works too) namespace nlohmann { template < typename T > struct adl_serializer < boost :: optional < T >> { static void to_json ( json & j , const boost :: optional < T >& opt ) { if ( opt == boost :: none ) { j = nullptr ; } else { j = * opt ; // this will call adl_serializer<T>::to_json which will // find the free function to_json in T's namespace! } } static void from_json ( const json & j , boost :: optional < T >& opt ) { if ( j . is_null ()) { opt = boost :: none ; } else { opt = j . get < T > (); // same as above, but with // adl_serializer<T>::from_json } } }; }","title":"How do I convert third-party types?"},{"location":"features/arbitrary_types/#how-can-i-use-get-for-non-default-constructiblenon-copyable-types","text":"There is a way, if your type is MoveConstructible . You will need to specialize the adl_serializer as well, but with a special from_json overload: struct move_only_type { move_only_type () = delete ; move_only_type ( int ii ) : i ( ii ) {} move_only_type ( const move_only_type & ) = delete ; move_only_type ( move_only_type && ) = default ; int i ; }; namespace nlohmann { template <> struct adl_serializer < move_only_type > { // note: the return type is no longer 'void', and the method only takes // one argument static move_only_type from_json ( const json & j ) { return { j . get < int > ()}; } // Here's the catch! You must provide a to_json method! Otherwise you // will not be able to convert move_only_type to json, since you fully // specialized adl_serializer on that type static void to_json ( json & j , move_only_type t ) { j = t . i ; } }; }","title":"How can I use get() for non-default constructible/non-copyable types?"},{"location":"features/arbitrary_types/#can-i-write-my-own-serializer-advanced-use","text":"Yes. You might want to take a look at unit-udt.cpp in the test suite, to see a few examples. If you write your own serializer, you'll need to do a few things: use a different basic_json alias than nlohmann::json (the last template parameter of basic_json is the JSONSerializer ) use your basic_json alias (or a template parameter) in all your to_json / from_json methods use nlohmann::to_json and nlohmann::from_json when you need ADL Here is an example, without simplifications, that only accepts types with a size <= 32, and uses ADL. // You should use void as a second template argument // if you don't need compile-time checks on T template < typename T , typename SFINAE = typename std :: enable_if < sizeof ( T ) <= 32 >:: type > struct less_than_32_serializer { template < typename BasicJsonType > static void to_json ( BasicJsonType & j , T value ) { // we want to use ADL, and call the correct to_json overload using nlohmann :: to_json ; // this method is called by adl_serializer, // this is where the magic happens to_json ( j , value ); } template < typename BasicJsonType > static void from_json ( const BasicJsonType & j , T & value ) { // same thing here using nlohmann :: from_json ; from_json ( j , value ); } }; Be very careful when reimplementing your serializer, you can stack overflow if you don't pay attention: template < typename T , void > struct bad_serializer { template < typename BasicJsonType > static void to_json ( BasicJsonType & j , const T & value ) { // this calls BasicJsonType::json_serializer<T>::to_json(j, value); // if BasicJsonType::json_serializer == bad_serializer ... oops! j = value ; } template < typename BasicJsonType > static void to_json ( const BasicJsonType & j , T & value ) { // this calls BasicJsonType::json_serializer<T>::from_json(j, value); // if BasicJsonType::json_serializer == bad_serializer ... oops! value = j . template get < T > (); // oops! } };","title":"Can I write my own serializer? (Advanced use)"},{"location":"features/binary_values/","text":"Binary Values \u00b6 The library implements several binary formats that encode JSON in an efficient way. Most of these formats support binary values; that is, values that have semantics define outside the library and only define a sequence of bytes to be stored. JSON itself does not have a binary value. As such, binary values are an extension that this library implements to store values received by a binary format. Binary values are never created by the JSON parser, and are only part of a serialized JSON text if they have been created manually or via a binary format. API for binary values \u00b6 By default, binary values are stored as std::vector<std::uint8_t> . This type can be changed by providing a template parameter to the basic_json type. To store binary subtypes, the storage type is extended and exposed as json::binary_t : auto binary = json :: binary_t ({ 0xCA , 0xFE , 0xBA , 0xBE }); auto binary_with_subtype = json :: binary_t ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); There are several convenience functions to check and set the subtype: binary . has_subtype (); // returns false binary_with_subtype . has_subtype (); // returns true binary_with_subtype . clear_subtype (); binary_with_subtype . has_subtype (); // returns true binary_with_subtype . set_subtype ( 42 ); binary . set_subtype ( 23 ); binary . subtype (); // returns 23 As json::binary_t is subclassing std::vector<std::uint8_t> , all member functions are available: binary . size (); // returns 4 binary [ 1 ]; // returns 0xFE JSON values can be constructed from json::binary_t : json j = binary ; Binary values are primitive values just like numbers or strings: j . is_binary (); // returns true j . is_primitive (); // returns true Given a binary JSON value, the binary_t can be accessed by reference as via get_binary() : j . get_binary (). has_subtype (); // returns true j . get_binary (). size (); // returns 4 For convencience, binary JSON values can be constructed via json::binary : auto j2 = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 23 ); auto j3 = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }); j2 == j ; // returns true j3 . get_binary (). has_subtype (); // returns false Serialization \u00b6 Binary values are serialized differently according to the formats. JSON \u00b6 JSON does not have a binary type, and this library does not introduce a new type as this would break conformance. Instead, binary values are serialized as an object with two keys: bytes holds an array of integers, and subtype is an integer or null . Example Code: // create a binary value of subtype 42 json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // serialize to standard output std :: cout << j . dump ( 2 ) << std :: endl ; Output: { \"binary\" : { \"bytes\" : [ 202 , 254 , 186 , 190 ], \"subtype\" : 42 } } No roundtrip for binary values The JSON parser will not parse the objects generated by binary values back to binary values. This is by design to remain standards compliant. Serializing binary values to JSON is only implemented for debugging purposes. BSON \u00b6 BSON supports binary values and subtypes. If a subtype is given, it is used and added as unsigned 8-bit integer. If no subtype is given, the generic binary subtype 0x00 is used. Example Code: // create a binary value of subtype 42 json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // convert to BSON auto v = json :: to_bson ( j ); v is a std::vector<std::uint8t> with the following 22 elements: 0x16 0x00 0x00 0x00 // number of bytes in the document 0x05 // binary value 0x62 0x69 0x6E 0x61 0x72 0x79 0x00 // key \"binary\" + null byte 0x04 0x00 0x00 0x00 // number of bytes 0x2a // subtype 0xCA 0xFE 0xBA 0xBE // content 0x00 // end of the document Note that the serialization preserves the subtype, and deserializing v would yield the following value: { \"binary\" : { \"bytes\" : [ 202 , 254 , 186 , 190 ], \"subtype\" : 42 } } CBOR \u00b6 CBOR supports binary values, but no subtypes. Subtypes will be serialized as tags. Any binary value will be serialized as byte strings. The library will choose the smallest representation using the length of the byte array. Example Code: // create a binary value of subtype 42 json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // convert to CBOR auto v = json :: to_cbor ( j ); v is a std::vector<std::uint8t> with the following 15 elements: 0xA1 // map(1) 0x66 // text(6) 0x62 0x69 0x6E 0x61 0x72 0x79 // \"binary\" 0xD8 0x2A // tag(42) 0x44 // bytes(4) 0xCA 0xFE 0xBA 0xBE // content Note that the subtype is serialized as tag. However, parsing tagged values yield a parse error unless json::cbor_tag_handler_t::ignore is passed to json::from_cbor . { \"binary\" : { \"bytes\" : [ 202 , 254 , 186 , 190 ], \"subtype\" : null } } MessagePack \u00b6 MessagePack supports binary values and subtypes. If a subtype is given, the ext family is used. The library will choose the smallest representation among fixext1, fixext2, fixext4, fixext8, ext8, ext16, and ext32. The subtype is then added as singed 8-bit integer. If no subtype is given, the bin family (bin8, bin16, bin32) is used. Example Code: // create a binary value of subtype 42 json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // convert to MessagePack auto v = json :: to_msgpack ( j ); v is a std::vector<std::uint8t> with the following 14 elements: 0x81 // fixmap1 0xA6 // fixstr6 0x62 0x69 0x6E 0x61 0x72 0x79 // \"binary\" 0xD6 // fixext4 0x2A // subtype 0xCA 0xFE 0xBA 0xBE // content Note that the serialization preserves the subtype, and deserializing v would yield the following value: { \"binary\" : { \"bytes\" : [ 202 , 254 , 186 , 190 ], \"subtype\" : 42 } } UBJSON \u00b6 UBJSON neither supports binary values nor subtypes, and proposes to serialize binary values as array of uint8 values. This translation is implemented by the library. Example Code: // create a binary value of subtype 42 (will be ignored in UBJSON) json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // convert to UBJSON auto v = json :: to_msgpack ( j ); v is a std::vector<std::uint8t> with the following 20 elements: 0x7B // '{' 0x69 0x06 // i 6 (length of the key) 0x62 0x69 0x6E 0x61 0x72 0x79 // \"binary\" 0x5B // '[' 0x55 0xCA 0x55 0xFE 0x55 0xBA 0x55 0xBE // content (each byte prefixed with 'U') 0x5D // ']' 0x7D // '}' The following code uses the type and size optimization for UBJSON: // convert to UBJSON using the size and type optimization auto v = json :: to_ubjson ( j , true , true ); The resulting vector has 23 elements; the optimization is not effective for examples with few values: 0x7B // '{' 0x24 // '$' type of the object elements 0x5B // '[' array 0x23 0x69 0x01 // '#' i 1 number of object elements 0x69 0x06 // i 6 (length of the key) 0x62 0x69 0x6E 0x61 0x72 0x79 // \"binary\" 0x24 0x55 // '$' 'U' type of the array elements: unsinged integers 0x23 0x69 0x04 // '#' i 4 number of array elements 0xCA 0xFE 0xBA 0xBE // content Note that subtype (42) is not serialized and that UBJSON has no binary type , and deserializing v would yield the following value: { \"binary\" : [ 202 , 254 , 186 , 190 ] }","title":"Binary Values"},{"location":"features/binary_values/#binary-values","text":"The library implements several binary formats that encode JSON in an efficient way. Most of these formats support binary values; that is, values that have semantics define outside the library and only define a sequence of bytes to be stored. JSON itself does not have a binary value. As such, binary values are an extension that this library implements to store values received by a binary format. Binary values are never created by the JSON parser, and are only part of a serialized JSON text if they have been created manually or via a binary format.","title":"Binary Values"},{"location":"features/binary_values/#api-for-binary-values","text":"By default, binary values are stored as std::vector<std::uint8_t> . This type can be changed by providing a template parameter to the basic_json type. To store binary subtypes, the storage type is extended and exposed as json::binary_t : auto binary = json :: binary_t ({ 0xCA , 0xFE , 0xBA , 0xBE }); auto binary_with_subtype = json :: binary_t ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); There are several convenience functions to check and set the subtype: binary . has_subtype (); // returns false binary_with_subtype . has_subtype (); // returns true binary_with_subtype . clear_subtype (); binary_with_subtype . has_subtype (); // returns true binary_with_subtype . set_subtype ( 42 ); binary . set_subtype ( 23 ); binary . subtype (); // returns 23 As json::binary_t is subclassing std::vector<std::uint8_t> , all member functions are available: binary . size (); // returns 4 binary [ 1 ]; // returns 0xFE JSON values can be constructed from json::binary_t : json j = binary ; Binary values are primitive values just like numbers or strings: j . is_binary (); // returns true j . is_primitive (); // returns true Given a binary JSON value, the binary_t can be accessed by reference as via get_binary() : j . get_binary (). has_subtype (); // returns true j . get_binary (). size (); // returns 4 For convencience, binary JSON values can be constructed via json::binary : auto j2 = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 23 ); auto j3 = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }); j2 == j ; // returns true j3 . get_binary (). has_subtype (); // returns false","title":"API for binary values"},{"location":"features/binary_values/#serialization","text":"Binary values are serialized differently according to the formats.","title":"Serialization"},{"location":"features/binary_values/#json","text":"JSON does not have a binary type, and this library does not introduce a new type as this would break conformance. Instead, binary values are serialized as an object with two keys: bytes holds an array of integers, and subtype is an integer or null . Example Code: // create a binary value of subtype 42 json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // serialize to standard output std :: cout << j . dump ( 2 ) << std :: endl ; Output: { \"binary\" : { \"bytes\" : [ 202 , 254 , 186 , 190 ], \"subtype\" : 42 } } No roundtrip for binary values The JSON parser will not parse the objects generated by binary values back to binary values. This is by design to remain standards compliant. Serializing binary values to JSON is only implemented for debugging purposes.","title":"JSON"},{"location":"features/binary_values/#bson","text":"BSON supports binary values and subtypes. If a subtype is given, it is used and added as unsigned 8-bit integer. If no subtype is given, the generic binary subtype 0x00 is used. Example Code: // create a binary value of subtype 42 json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // convert to BSON auto v = json :: to_bson ( j ); v is a std::vector<std::uint8t> with the following 22 elements: 0x16 0x00 0x00 0x00 // number of bytes in the document 0x05 // binary value 0x62 0x69 0x6E 0x61 0x72 0x79 0x00 // key \"binary\" + null byte 0x04 0x00 0x00 0x00 // number of bytes 0x2a // subtype 0xCA 0xFE 0xBA 0xBE // content 0x00 // end of the document Note that the serialization preserves the subtype, and deserializing v would yield the following value: { \"binary\" : { \"bytes\" : [ 202 , 254 , 186 , 190 ], \"subtype\" : 42 } }","title":"BSON"},{"location":"features/binary_values/#cbor","text":"CBOR supports binary values, but no subtypes. Subtypes will be serialized as tags. Any binary value will be serialized as byte strings. The library will choose the smallest representation using the length of the byte array. Example Code: // create a binary value of subtype 42 json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // convert to CBOR auto v = json :: to_cbor ( j ); v is a std::vector<std::uint8t> with the following 15 elements: 0xA1 // map(1) 0x66 // text(6) 0x62 0x69 0x6E 0x61 0x72 0x79 // \"binary\" 0xD8 0x2A // tag(42) 0x44 // bytes(4) 0xCA 0xFE 0xBA 0xBE // content Note that the subtype is serialized as tag. However, parsing tagged values yield a parse error unless json::cbor_tag_handler_t::ignore is passed to json::from_cbor . { \"binary\" : { \"bytes\" : [ 202 , 254 , 186 , 190 ], \"subtype\" : null } }","title":"CBOR"},{"location":"features/binary_values/#messagepack","text":"MessagePack supports binary values and subtypes. If a subtype is given, the ext family is used. The library will choose the smallest representation among fixext1, fixext2, fixext4, fixext8, ext8, ext16, and ext32. The subtype is then added as singed 8-bit integer. If no subtype is given, the bin family (bin8, bin16, bin32) is used. Example Code: // create a binary value of subtype 42 json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // convert to MessagePack auto v = json :: to_msgpack ( j ); v is a std::vector<std::uint8t> with the following 14 elements: 0x81 // fixmap1 0xA6 // fixstr6 0x62 0x69 0x6E 0x61 0x72 0x79 // \"binary\" 0xD6 // fixext4 0x2A // subtype 0xCA 0xFE 0xBA 0xBE // content Note that the serialization preserves the subtype, and deserializing v would yield the following value: { \"binary\" : { \"bytes\" : [ 202 , 254 , 186 , 190 ], \"subtype\" : 42 } }","title":"MessagePack"},{"location":"features/binary_values/#ubjson","text":"UBJSON neither supports binary values nor subtypes, and proposes to serialize binary values as array of uint8 values. This translation is implemented by the library. Example Code: // create a binary value of subtype 42 (will be ignored in UBJSON) json j ; j [ \"binary\" ] = json :: binary ({ 0xCA , 0xFE , 0xBA , 0xBE }, 42 ); // convert to UBJSON auto v = json :: to_msgpack ( j ); v is a std::vector<std::uint8t> with the following 20 elements: 0x7B // '{' 0x69 0x06 // i 6 (length of the key) 0x62 0x69 0x6E 0x61 0x72 0x79 // \"binary\" 0x5B // '[' 0x55 0xCA 0x55 0xFE 0x55 0xBA 0x55 0xBE // content (each byte prefixed with 'U') 0x5D // ']' 0x7D // '}' The following code uses the type and size optimization for UBJSON: // convert to UBJSON using the size and type optimization auto v = json :: to_ubjson ( j , true , true ); The resulting vector has 23 elements; the optimization is not effective for examples with few values: 0x7B // '{' 0x24 // '$' type of the object elements 0x5B // '[' array 0x23 0x69 0x01 // '#' i 1 number of object elements 0x69 0x06 // i 6 (length of the key) 0x62 0x69 0x6E 0x61 0x72 0x79 // \"binary\" 0x24 0x55 // '$' 'U' type of the array elements: unsinged integers 0x23 0x69 0x04 // '#' i 4 number of array elements 0xCA 0xFE 0xBA 0xBE // content Note that subtype (42) is not serialized and that UBJSON has no binary type , and deserializing v would yield the following value: { \"binary\" : [ 202 , 254 , 186 , 190 ] }","title":"UBJSON"},{"location":"features/comments/","text":"Comments \u00b6 This library does not support comments by default . It does so for three reasons: Comments are not part of the JSON specification . You may argue that // or /* */ are allowed in JavaScript, but JSON is not JavaScript. This was not an oversight: Douglas Crockford wrote on this in May 2012: I removed comments from JSON because I saw people were using them to hold parsing directives, a practice which would have destroyed interoperability. I know that the lack of comments makes some people sad, but it shouldn't. Suppose you are using JSON to keep configuration files, which you would like to annotate. Go ahead and insert all the comments you like. Then pipe it through JSMin before handing it to your JSON parser. It is dangerous for interoperability if some libraries would add comment support while others don't. Please check The Harmful Consequences of the Robustness Principle on this. However, you can pass set parameter ignore_comments to true in the parse function to ignore // or /* */ comments. Comments will then be treated as whitespace. Example Consider the following JSON with comments. { // update in 2006: removed Pluto \"planets\" : [ \"Mercury\" , \"Venus\" , \"Earth\" , \"Mars\" , \"Jupiter\" , \"Uranus\" , \"Neptune\" /* , \"Pluto\" */ ] } When calling parse without additional argument, a parse error exception is thrown. If skip_comments is set to true , the comments are skipped during parsing: #include <iostream> #include \"json.hpp\" using json = nlohmann :: json ; int main () { std :: string s = R \" ( { // update in 2006: removed Pluto \"planets\": [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Uranus\", \"Neptune\" /*, \"Pluto\" */] } ) \" ; try { json j = json :: parse ( s ); } catch ( json :: exception & e ) { std :: cout << e . what () << std :: endl ; } json j = json :: parse ( s , /* callback */ nullptr , /* allow exceptions */ true , /* skip_comments */ true ); std :: cout << j . dump ( 2 ) << '\\n' ; } Output: [json.exception.parse_error.101] parse error at line 3, column 9: syntax error while parsing object key - invalid literal; last read: '<U+000A> {<U+000A> /'; expected string literal { \"planets\" : [ \"Mercury\" , \"Venus\" , \"Earth\" , \"Mars\" , \"Jupiter\" , \"Uranus\" , \"Neptune\" ] }","title":"Comments"},{"location":"features/comments/#comments","text":"This library does not support comments by default . It does so for three reasons: Comments are not part of the JSON specification . You may argue that // or /* */ are allowed in JavaScript, but JSON is not JavaScript. This was not an oversight: Douglas Crockford wrote on this in May 2012: I removed comments from JSON because I saw people were using them to hold parsing directives, a practice which would have destroyed interoperability. I know that the lack of comments makes some people sad, but it shouldn't. Suppose you are using JSON to keep configuration files, which you would like to annotate. Go ahead and insert all the comments you like. Then pipe it through JSMin before handing it to your JSON parser. It is dangerous for interoperability if some libraries would add comment support while others don't. Please check The Harmful Consequences of the Robustness Principle on this. However, you can pass set parameter ignore_comments to true in the parse function to ignore // or /* */ comments. Comments will then be treated as whitespace. Example Consider the following JSON with comments. { // update in 2006: removed Pluto \"planets\" : [ \"Mercury\" , \"Venus\" , \"Earth\" , \"Mars\" , \"Jupiter\" , \"Uranus\" , \"Neptune\" /* , \"Pluto\" */ ] } When calling parse without additional argument, a parse error exception is thrown. If skip_comments is set to true , the comments are skipped during parsing: #include <iostream> #include \"json.hpp\" using json = nlohmann :: json ; int main () { std :: string s = R \" ( { // update in 2006: removed Pluto \"planets\": [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Uranus\", \"Neptune\" /*, \"Pluto\" */] } ) \" ; try { json j = json :: parse ( s ); } catch ( json :: exception & e ) { std :: cout << e . what () << std :: endl ; } json j = json :: parse ( s , /* callback */ nullptr , /* allow exceptions */ true , /* skip_comments */ true ); std :: cout << j . dump ( 2 ) << '\\n' ; } Output: [json.exception.parse_error.101] parse error at line 3, column 9: syntax error while parsing object key - invalid literal; last read: '<U+000A> {<U+000A> /'; expected string literal { \"planets\" : [ \"Mercury\" , \"Venus\" , \"Earth\" , \"Mars\" , \"Jupiter\" , \"Uranus\" , \"Neptune\" ] }","title":"Comments"},{"location":"features/enum_conversion/","text":"Specializing enum conversion \u00b6 By default, enum values are serialized to JSON as integers. In some cases this could result in undesired behavior. If an enum is modified or re-ordered after data has been serialized to JSON, the later de-serialized JSON data may be undefined or a different enum value than was originally intended. It is possible to more precisely specify how a given enum is mapped to and from JSON as shown below: // example enum type declaration enum TaskState { TS_STOPPED , TS_RUNNING , TS_COMPLETED , TS_INVALID =- 1 , }; // map TaskState values to JSON as strings NLOHMANN_JSON_SERIALIZE_ENUM ( TaskState , { { TS_INVALID , nullptr }, { TS_STOPPED , \"stopped\" }, { TS_RUNNING , \"running\" }, { TS_COMPLETED , \"completed\" }, }) The NLOHMANN_JSON_SERIALIZE_ENUM() macro declares a set of to_json() / from_json() functions for type TaskState while avoiding repetition and boilerplate serialization code. Usage \u00b6 // enum to JSON as string json j = TS_STOPPED ; assert ( j == \"stopped\" ); // json string to enum json j3 = \"running\" ; assert ( j3 . get < TaskState > () == TS_RUNNING ); // undefined json value to enum (where the first map entry above is the default) json jPi = 3.14 ; assert ( jPi . get < TaskState > () == TS_INVALID ); Notes \u00b6 Just as in Arbitrary Type Conversions above, NLOHMANN_JSON_SERIALIZE_ENUM() MUST be declared in your enum type's namespace (which can be the global namespace), or the library will not be able to locate it and it will default to integer serialization. It MUST be available (e.g., proper headers must be included) everywhere you use the conversions. Other Important points: When using get<ENUM_TYPE>() , undefined JSON values will default to the first pair specified in your map. Select this default pair carefully. If an enum or JSON value is specified more than once in your map, the first matching occurrence from the top of the map will be returned when converting to or from JSON.","title":"Specializing enum conversion"},{"location":"features/enum_conversion/#specializing-enum-conversion","text":"By default, enum values are serialized to JSON as integers. In some cases this could result in undesired behavior. If an enum is modified or re-ordered after data has been serialized to JSON, the later de-serialized JSON data may be undefined or a different enum value than was originally intended. It is possible to more precisely specify how a given enum is mapped to and from JSON as shown below: // example enum type declaration enum TaskState { TS_STOPPED , TS_RUNNING , TS_COMPLETED , TS_INVALID =- 1 , }; // map TaskState values to JSON as strings NLOHMANN_JSON_SERIALIZE_ENUM ( TaskState , { { TS_INVALID , nullptr }, { TS_STOPPED , \"stopped\" }, { TS_RUNNING , \"running\" }, { TS_COMPLETED , \"completed\" }, }) The NLOHMANN_JSON_SERIALIZE_ENUM() macro declares a set of to_json() / from_json() functions for type TaskState while avoiding repetition and boilerplate serialization code.","title":"Specializing enum conversion"},{"location":"features/enum_conversion/#usage","text":"// enum to JSON as string json j = TS_STOPPED ; assert ( j == \"stopped\" ); // json string to enum json j3 = \"running\" ; assert ( j3 . get < TaskState > () == TS_RUNNING ); // undefined json value to enum (where the first map entry above is the default) json jPi = 3.14 ; assert ( jPi . get < TaskState > () == TS_INVALID );","title":"Usage"},{"location":"features/enum_conversion/#notes","text":"Just as in Arbitrary Type Conversions above, NLOHMANN_JSON_SERIALIZE_ENUM() MUST be declared in your enum type's namespace (which can be the global namespace), or the library will not be able to locate it and it will default to integer serialization. It MUST be available (e.g., proper headers must be included) everywhere you use the conversions. Other Important points: When using get<ENUM_TYPE>() , undefined JSON values will default to the first pair specified in your map. Select this default pair carefully. If an enum or JSON value is specified more than once in your map, the first matching occurrence from the top of the map will be returned when converting to or from JSON.","title":"Notes"},{"location":"features/iterators/","text":"Iterators \u00b6 Overview \u00b6 A basic_json value is a container and allows access via iterators. Depending on the value type, basic_json stores zero or more values. As for other containers, begin() returns an iterator to the first value and end() returns an iterator to the value following the last value. The latter iterator is a placeholder and cannot be dereferenced. In case of null values, empty arrays, or empty objects, begin() will return end() . Iteration order for objects \u00b6 When iterating over objects, values are ordered with respect to the object_comparator_t type which defaults to std::less . See the types documentation for more information. Example // create JSON object {\"one\": 1, \"two\": 2, \"three\": 3} json j ; j [ \"one\" ] = 1 ; j [ \"two\" ] = 2 ; j [ \"three\" ] = 3 ; for ( auto it = j . begin (); it != j . end (); ++ it ) { std :: cout << * it << std :: endl ; } Output: 1 3 2 The reason for the order is the lexicographic ordering of the object keys \"one\", \"three\", \"two\". Access object key during iteration \u00b6 The JSON iterators have two member functions, key() and value() to access the object key and stored value, respectively. When calling key() on a non-object iterator, an invalid_iterator.207 exception is thrown. Example // create JSON object {\"one\": 1, \"two\": 2, \"three\": 3} json j ; j [ \"one\" ] = 1 ; j [ \"two\" ] = 2 ; j [ \"three\" ] = 3 ; for ( auto it = j . begin (); it != j . end (); ++ it ) { std :: cout << it . key () << \" : \" << it . value () << std :: endl ; } Output: one : 1 three : 3 two : 2 Range-based for loops \u00b6 C++11 allows to use range-based for loops to iterate over a container. for ( auto it : j_object ) { // \"it\" is of type json::reference and has no key() member std :: cout << \"value: \" << it << '\\n' ; } For this reason, the items() function allows to access iterator::key() and iterator::value() during range-based for loops. In these loops, a reference to the JSON values is returned, so there is no access to the underlying iterator. for ( auto & el : j_object . items ()) { std :: cout << \"key: \" << el . key () << \", value:\" << el . value () << '\\n' ; } The items() function also allows to use structured bindings (C++17): for ( auto & [ key , val ] : j_object . items ()) { std :: cout << \"key: \" << key << \", value:\" << val << '\\n' ; } Note When iterating over an array, key() will return the index of the element as string. For primitive types (e.g., numbers), key() returns an empty string. Warning Using items() on temporary objects is dangerous. Make sure the object's lifetime exeeds the iteration. See https://github.com/nlohmann/json/issues/2040 for more information. Reverse iteration order \u00b6 rbegin() and rend() return iterators in the reverse sequence. Example json j = { 1 , 2 , 3 , 4 }; for ( auto it = j . begin (); it != j . end (); ++ it ) { std :: cout << * it << std :: endl ; } Output: 4 3 2 1 Iterating strings and binary values \u00b6 Note that \"value\" means a JSON value in this setting, not values stored in the underlying containers. That is, *begin() returns the complete string or binary array and is also safe the underlying string or binary array is empty. Example json j = \"Hello, world\" ; for ( auto it = j . begin (); it != j . end (); ++ it ) { std :: cout << * it << std :: endl ; } Output: \"Hello, world\" Iterator invalidation \u00b6 Operations invalidated iterators clear all","title":"Iterators"},{"location":"features/iterators/#iterators","text":"","title":"Iterators"},{"location":"features/iterators/#overview","text":"A basic_json value is a container and allows access via iterators. Depending on the value type, basic_json stores zero or more values. As for other containers, begin() returns an iterator to the first value and end() returns an iterator to the value following the last value. The latter iterator is a placeholder and cannot be dereferenced. In case of null values, empty arrays, or empty objects, begin() will return end() .","title":"Overview"},{"location":"features/iterators/#iteration-order-for-objects","text":"When iterating over objects, values are ordered with respect to the object_comparator_t type which defaults to std::less . See the types documentation for more information. Example // create JSON object {\"one\": 1, \"two\": 2, \"three\": 3} json j ; j [ \"one\" ] = 1 ; j [ \"two\" ] = 2 ; j [ \"three\" ] = 3 ; for ( auto it = j . begin (); it != j . end (); ++ it ) { std :: cout << * it << std :: endl ; } Output: 1 3 2 The reason for the order is the lexicographic ordering of the object keys \"one\", \"three\", \"two\".","title":"Iteration order for objects"},{"location":"features/iterators/#access-object-key-during-iteration","text":"The JSON iterators have two member functions, key() and value() to access the object key and stored value, respectively. When calling key() on a non-object iterator, an invalid_iterator.207 exception is thrown. Example // create JSON object {\"one\": 1, \"two\": 2, \"three\": 3} json j ; j [ \"one\" ] = 1 ; j [ \"two\" ] = 2 ; j [ \"three\" ] = 3 ; for ( auto it = j . begin (); it != j . end (); ++ it ) { std :: cout << it . key () << \" : \" << it . value () << std :: endl ; } Output: one : 1 three : 3 two : 2","title":"Access object key during iteration"},{"location":"features/iterators/#range-based-for-loops","text":"C++11 allows to use range-based for loops to iterate over a container. for ( auto it : j_object ) { // \"it\" is of type json::reference and has no key() member std :: cout << \"value: \" << it << '\\n' ; } For this reason, the items() function allows to access iterator::key() and iterator::value() during range-based for loops. In these loops, a reference to the JSON values is returned, so there is no access to the underlying iterator. for ( auto & el : j_object . items ()) { std :: cout << \"key: \" << el . key () << \", value:\" << el . value () << '\\n' ; } The items() function also allows to use structured bindings (C++17): for ( auto & [ key , val ] : j_object . items ()) { std :: cout << \"key: \" << key << \", value:\" << val << '\\n' ; } Note When iterating over an array, key() will return the index of the element as string. For primitive types (e.g., numbers), key() returns an empty string. Warning Using items() on temporary objects is dangerous. Make sure the object's lifetime exeeds the iteration. See https://github.com/nlohmann/json/issues/2040 for more information.","title":"Range-based for loops"},{"location":"features/iterators/#reverse-iteration-order","text":"rbegin() and rend() return iterators in the reverse sequence. Example json j = { 1 , 2 , 3 , 4 }; for ( auto it = j . begin (); it != j . end (); ++ it ) { std :: cout << * it << std :: endl ; } Output: 4 3 2 1","title":"Reverse iteration order"},{"location":"features/iterators/#iterating-strings-and-binary-values","text":"Note that \"value\" means a JSON value in this setting, not values stored in the underlying containers. That is, *begin() returns the complete string or binary array and is also safe the underlying string or binary array is empty. Example json j = \"Hello, world\" ; for ( auto it = j . begin (); it != j . end (); ++ it ) { std :: cout << * it << std :: endl ; } Output: \"Hello, world\"","title":"Iterating strings and binary values"},{"location":"features/iterators/#iterator-invalidation","text":"Operations invalidated iterators clear all","title":"Iterator invalidation"},{"location":"features/json_patch/","text":"JSON Patch and Diff \u00b6 Patches \u00b6 JSON Patch ( RFC 6902 ) defines a JSON document structure for expressing a sequence of operations to apply to a JSON) document. With the patch function, a JSON Patch is applied to the current JSON value by executing all operations from the patch. Example The following code shows how a JSON patch is applied to a value. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // the original document json doc = R \" ( { \"baz\": \"qux\", \"foo\": \"bar\" } ) \" _json ; // the patch json patch = R \" ( [ { \"op\": \"replace\", \"path\": \"/baz\", \"value\": \"boo\" }, { \"op\": \"add\", \"path\": \"/hello\", \"value\": [\"world\"] }, { \"op\": \"remove\", \"path\": \"/foo\"} ] ) \" _json ; // apply the patch json patched_doc = doc . patch ( patch ); // output original and patched document std :: cout << std :: setw ( 4 ) << doc << \" \\n\\n \" << std :: setw ( 4 ) << patched_doc << std :: endl ; } Output: { \"baz\" : \"qux\" , \"foo\" : \"bar\" } { \"baz\" : \"boo\" , \"hello\" : [ \"world\" ] } Diff \u00b6 The library can also calculate a JSON patch (i.e., a diff ) given two JSON values. Invariant For two JSON values source and target , the following code yields always true: source.patch(diff(source, target)) == target; Example The following code shows how a JSON patch is created as a diff for two JSON values. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // the source document json source = R \" ( { \"baz\": \"qux\", \"foo\": \"bar\" } ) \" _json ; // the target document json target = R \" ( { \"baz\": \"boo\", \"hello\": [ \"world\" ] } ) \" _json ; // create the patch json patch = json :: diff ( source , target ); // roundtrip json patched_source = source . patch ( patch ); // output patch and roundtrip result std :: cout << std :: setw ( 4 ) << patch << \" \\n\\n \" << std :: setw ( 4 ) << patched_source << std :: endl ; } Output: [ { \"op\" : \"replace\" , \"path\" : \"/baz\" , \"value\" : \"boo\" }, { \"op\" : \"remove\" , \"path\" : \"/foo\" }, { \"op\" : \"add\" , \"path\" : \"/hello\" , \"value\" : [ \"world\" ] } ] { \"baz\" : \"boo\" , \"hello\" : [ \"world\" ] }","title":"JSON Patch and Diff"},{"location":"features/json_patch/#json-patch-and-diff","text":"","title":"JSON Patch and Diff"},{"location":"features/json_patch/#patches","text":"JSON Patch ( RFC 6902 ) defines a JSON document structure for expressing a sequence of operations to apply to a JSON) document. With the patch function, a JSON Patch is applied to the current JSON value by executing all operations from the patch. Example The following code shows how a JSON patch is applied to a value. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // the original document json doc = R \" ( { \"baz\": \"qux\", \"foo\": \"bar\" } ) \" _json ; // the patch json patch = R \" ( [ { \"op\": \"replace\", \"path\": \"/baz\", \"value\": \"boo\" }, { \"op\": \"add\", \"path\": \"/hello\", \"value\": [\"world\"] }, { \"op\": \"remove\", \"path\": \"/foo\"} ] ) \" _json ; // apply the patch json patched_doc = doc . patch ( patch ); // output original and patched document std :: cout << std :: setw ( 4 ) << doc << \" \\n\\n \" << std :: setw ( 4 ) << patched_doc << std :: endl ; } Output: { \"baz\" : \"qux\" , \"foo\" : \"bar\" } { \"baz\" : \"boo\" , \"hello\" : [ \"world\" ] }","title":"Patches"},{"location":"features/json_patch/#diff","text":"The library can also calculate a JSON patch (i.e., a diff ) given two JSON values. Invariant For two JSON values source and target , the following code yields always true: source.patch(diff(source, target)) == target; Example The following code shows how a JSON patch is created as a diff for two JSON values. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // the source document json source = R \" ( { \"baz\": \"qux\", \"foo\": \"bar\" } ) \" _json ; // the target document json target = R \" ( { \"baz\": \"boo\", \"hello\": [ \"world\" ] } ) \" _json ; // create the patch json patch = json :: diff ( source , target ); // roundtrip json patched_source = source . patch ( patch ); // output patch and roundtrip result std :: cout << std :: setw ( 4 ) << patch << \" \\n\\n \" << std :: setw ( 4 ) << patched_source << std :: endl ; } Output: [ { \"op\" : \"replace\" , \"path\" : \"/baz\" , \"value\" : \"boo\" }, { \"op\" : \"remove\" , \"path\" : \"/foo\" }, { \"op\" : \"add\" , \"path\" : \"/hello\" , \"value\" : [ \"world\" ] } ] { \"baz\" : \"boo\" , \"hello\" : [ \"world\" ] }","title":"Diff"},{"location":"features/json_pointer/","text":"JSON Pointer \u00b6 The library supports JSON Pointer ( RFC 6901 ) as alternative means to address structured values. // a JSON value json j_original = R \" ( { \"baz\": [\"one\", \"two\", \"three\"], \"foo\": \"bar\" } ) \" _json ; // access members with a JSON pointer (RFC 6901) j_original [ \"/baz/1\" _json_pointer ]; // \"two\"","title":"JSON Pointer"},{"location":"features/json_pointer/#json-pointer","text":"The library supports JSON Pointer ( RFC 6901 ) as alternative means to address structured values. // a JSON value json j_original = R \" ( { \"baz\": [\"one\", \"two\", \"three\"], \"foo\": \"bar\" } ) \" _json ; // access members with a JSON pointer (RFC 6901) j_original [ \"/baz/1\" _json_pointer ]; // \"two\"","title":"JSON Pointer"},{"location":"features/macros/","text":"Supported Macros \u00b6 Some aspects of the library can be configured by defining preprocessor macros before including the json.hpp header. JSON_ASSERT(x) \u00b6 The default value is assert ( x ) . JSON_CATCH_USER(exception) \u00b6 This macro overrides catch calls inside the library. The argument is the type of the exception to catch. As of version 3.8.0, the library only catches std::out_of_range exceptions internally to rethrow them as json::out_of_range exceptions. The macro is always followed by a scope. See Switch off exceptions for an example. JSON_NOEXCEPTION \u00b6 Exceptions can be switched off by defining the symbol JSON_NOEXCEPTION . When defining JSON_NOEXCEPTION , try is replaced by if ( true ) , catch is replaced by if ( false ) , and throw is replaced by std :: abort () . The same effect is achieved by setting the compiler flag -fno-exceptions . JSON_SKIP_UNSUPPORTED_COMPILER_CHECK \u00b6 When defined, the library will not create a compile error when a known unsupported compiler is detected. This allows to use the library with compilers that do not fully support C++11 and may only work if unsupported features are not used. JSON_THROW_USER(exception) \u00b6 This macro overrides throw calls inside the library. The argument is the exception to be thrown. Note that JSON_THROW_USER should leave the current scope (e.g., by throwing or aborting), as continuing after it may yield undefined behavior. See Switch off exceptions for an example. JSON_TRY_USER \u00b6 This macro overrides try calls inside the library. It has no arguments and is always followed by a scope. See Switch off exceptions for an example. JSON_USE_IMPLICIT_CONVERSIONS \u00b6 When defined to 0 , implicit conversions are switched off. By default, implicit conversions are switched on. Example This is an example for an implicit conversion: json j = \"Hello, world!\" ; std :: string s = j ; When JSON_USE_IMPLICIT_CONVERSIONS is defined to 0 , the code above does no longer compile. Instead, it must be written like this: json j = \"Hello, world!\" ; auto s = j . get < std :: string > (); NLOHMANN_DEFINE_TYPE_INTRUSIVE(type, member...) \u00b6 This macro can be used to simplify the serialization/deserialization of types if (1) want to use a JSON object as serialization and (2) want to use the member variable names as object keys in that object. The macro is to be defined inside of the class/struct to create code for. Unlike NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE , it can access private members. The first parameter is the name of the class/struct, and all remaining parameters name the members. See Simplify your life with macros for an example. NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(type, member...) \u00b6 This macro can be used to simplify the serialization/deserialization of types if (1) want to use a JSON object as serialization and (2) want to use the member variable names as object keys in that object. The macro is to be defined inside of the namespace of the class/struct to create code for. Private members cannot be accessed. Use NLOHMANN_DEFINE_TYPE_INTRUSIVE in these scenarios. The first parameter is the name of the class/struct, and all remaining parameters name the members. See Simplify your life with macros for an example. NLOHMANN_JSON_SERIALIZE_ENUM(type, ...) \u00b6 This macro simplifies the serialization/deserialization of enum types. See Specializing enum conversion for more information.","title":"Supported Macros"},{"location":"features/macros/#supported-macros","text":"Some aspects of the library can be configured by defining preprocessor macros before including the json.hpp header.","title":"Supported Macros"},{"location":"features/macros/#json_assertx","text":"The default value is assert ( x ) .","title":"JSON_ASSERT(x)"},{"location":"features/macros/#json_catch_userexception","text":"This macro overrides catch calls inside the library. The argument is the type of the exception to catch. As of version 3.8.0, the library only catches std::out_of_range exceptions internally to rethrow them as json::out_of_range exceptions. The macro is always followed by a scope. See Switch off exceptions for an example.","title":"JSON_CATCH_USER(exception)"},{"location":"features/macros/#json_noexception","text":"Exceptions can be switched off by defining the symbol JSON_NOEXCEPTION . When defining JSON_NOEXCEPTION , try is replaced by if ( true ) , catch is replaced by if ( false ) , and throw is replaced by std :: abort () . The same effect is achieved by setting the compiler flag -fno-exceptions .","title":"JSON_NOEXCEPTION"},{"location":"features/macros/#json_skip_unsupported_compiler_check","text":"When defined, the library will not create a compile error when a known unsupported compiler is detected. This allows to use the library with compilers that do not fully support C++11 and may only work if unsupported features are not used.","title":"JSON_SKIP_UNSUPPORTED_COMPILER_CHECK"},{"location":"features/macros/#json_throw_userexception","text":"This macro overrides throw calls inside the library. The argument is the exception to be thrown. Note that JSON_THROW_USER should leave the current scope (e.g., by throwing or aborting), as continuing after it may yield undefined behavior. See Switch off exceptions for an example.","title":"JSON_THROW_USER(exception)"},{"location":"features/macros/#json_try_user","text":"This macro overrides try calls inside the library. It has no arguments and is always followed by a scope. See Switch off exceptions for an example.","title":"JSON_TRY_USER"},{"location":"features/macros/#json_use_implicit_conversions","text":"When defined to 0 , implicit conversions are switched off. By default, implicit conversions are switched on. Example This is an example for an implicit conversion: json j = \"Hello, world!\" ; std :: string s = j ; When JSON_USE_IMPLICIT_CONVERSIONS is defined to 0 , the code above does no longer compile. Instead, it must be written like this: json j = \"Hello, world!\" ; auto s = j . get < std :: string > ();","title":"JSON_USE_IMPLICIT_CONVERSIONS"},{"location":"features/macros/#nlohmann_define_type_intrusivetype-member","text":"This macro can be used to simplify the serialization/deserialization of types if (1) want to use a JSON object as serialization and (2) want to use the member variable names as object keys in that object. The macro is to be defined inside of the class/struct to create code for. Unlike NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE , it can access private members. The first parameter is the name of the class/struct, and all remaining parameters name the members. See Simplify your life with macros for an example.","title":"NLOHMANN_DEFINE_TYPE_INTRUSIVE(type, member...)"},{"location":"features/macros/#nlohmann_define_type_non_intrusivetype-member","text":"This macro can be used to simplify the serialization/deserialization of types if (1) want to use a JSON object as serialization and (2) want to use the member variable names as object keys in that object. The macro is to be defined inside of the namespace of the class/struct to create code for. Private members cannot be accessed. Use NLOHMANN_DEFINE_TYPE_INTRUSIVE in these scenarios. The first parameter is the name of the class/struct, and all remaining parameters name the members. See Simplify your life with macros for an example.","title":"NLOHMANN_DEFINE_TYPE_NON_INTRUSIVE(type, member...)"},{"location":"features/macros/#nlohmann_json_serialize_enumtype","text":"This macro simplifies the serialization/deserialization of enum types. See Specializing enum conversion for more information.","title":"NLOHMANN_JSON_SERIALIZE_ENUM(type, ...)"},{"location":"features/merge_patch/","text":"JSON Merge Patch \u00b6 The library supports JSON Merge Patch ( RFC 7386 ) as a patch format. The merge patch format is primarily intended for use with the HTTP PATCH method as a means of describing a set of modifications to a target resource's content. This function applies a merge patch to the current JSON value. Instead of using JSON Pointer to specify values to be manipulated, it describes the changes using a syntax that closely mimics the document being modified. Example The following code shows how a JSON Merge Patch is applied to a JSON document. #include <iostream> #include <nlohmann/json.hpp> #include <iomanip> // for std::setw using json = nlohmann :: json ; int main () { // the original document json document = R \" ( { \"title\": \"Goodbye!\", \"author\": { \"givenName\": \"John\", \"familyName\": \"Doe\" }, \"tags\": [ \"example\", \"sample\" ], \"content\": \"This will be unchanged\" } ) \" _json ; // the patch json patch = R \" ( { \"title\": \"Hello!\", \"phoneNumber\": \"+01-123-456-7890\", \"author\": { \"familyName\": null }, \"tags\": [ \"example\" ] } ) \" _json ; // apply the patch document . merge_patch ( patch ); // output original and patched document std :: cout << std :: setw ( 4 ) << document << std :: endl ; } Output: { \"author\" : { \"givenName\" : \"John\" }, \"content\" : \"This will be unchanged\" , \"phoneNumber\" : \"+01-123-456-7890\" , \"tags\" : [ \"example\" ], \"title\" : \"Hello!\" }","title":"JSON Merge Patch"},{"location":"features/merge_patch/#json-merge-patch","text":"The library supports JSON Merge Patch ( RFC 7386 ) as a patch format. The merge patch format is primarily intended for use with the HTTP PATCH method as a means of describing a set of modifications to a target resource's content. This function applies a merge patch to the current JSON value. Instead of using JSON Pointer to specify values to be manipulated, it describes the changes using a syntax that closely mimics the document being modified. Example The following code shows how a JSON Merge Patch is applied to a JSON document. #include <iostream> #include <nlohmann/json.hpp> #include <iomanip> // for std::setw using json = nlohmann :: json ; int main () { // the original document json document = R \" ( { \"title\": \"Goodbye!\", \"author\": { \"givenName\": \"John\", \"familyName\": \"Doe\" }, \"tags\": [ \"example\", \"sample\" ], \"content\": \"This will be unchanged\" } ) \" _json ; // the patch json patch = R \" ( { \"title\": \"Hello!\", \"phoneNumber\": \"+01-123-456-7890\", \"author\": { \"familyName\": null }, \"tags\": [ \"example\" ] } ) \" _json ; // apply the patch document . merge_patch ( patch ); // output original and patched document std :: cout << std :: setw ( 4 ) << document << std :: endl ; } Output: { \"author\" : { \"givenName\" : \"John\" }, \"content\" : \"This will be unchanged\" , \"phoneNumber\" : \"+01-123-456-7890\" , \"tags\" : [ \"example\" ], \"title\" : \"Hello!\" }","title":"JSON Merge Patch"},{"location":"features/object_order/","text":"Object Order \u00b6 The JSON standard defines objects as \"an unordered collection of zero or more name/value pairs\". As such, an implementation does not need to preserve any specific order of object keys. The default type nlohmann::json uses a std::map to store JSON objects, and thus stores object keys sorted alphabetically . Example #include <iostream> #include \"json.hpp\" using json = nlohmann :: json ; int main () { json j ; j [ \"one\" ] = 1 ; j [ \"two\" ] = 2 ; j [ \"three\" ] = 3 ; std :: cout << j . dump ( 2 ) << '\\n' ; } Output: { \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } If you do want to preserve the insertion order , you can try the type nlohmann::ordered_json . Example #include <iostream> #include <nlohmann/json.hpp> using ordered_json = nlohmann :: ordered_json ; int main () { ordered_json j ; j [ \"one\" ] = 1 ; j [ \"two\" ] = 2 ; j [ \"three\" ] = 3 ; std :: cout << j . dump ( 2 ) << '\\n' ; } Output: { \"one\" : 1 , \"two\" : 2 , \"three\" : 3 } Alternatively, you can use a more sophisticated ordered map like tsl::ordered_map ( integration ) or nlohmann::fifo_map ( integration ).","title":"Object Order"},{"location":"features/object_order/#object-order","text":"The JSON standard defines objects as \"an unordered collection of zero or more name/value pairs\". As such, an implementation does not need to preserve any specific order of object keys. The default type nlohmann::json uses a std::map to store JSON objects, and thus stores object keys sorted alphabetically . Example #include <iostream> #include \"json.hpp\" using json = nlohmann :: json ; int main () { json j ; j [ \"one\" ] = 1 ; j [ \"two\" ] = 2 ; j [ \"three\" ] = 3 ; std :: cout << j . dump ( 2 ) << '\\n' ; } Output: { \"one\" : 1 , \"three\" : 3 , \"two\" : 2 } If you do want to preserve the insertion order , you can try the type nlohmann::ordered_json . Example #include <iostream> #include <nlohmann/json.hpp> using ordered_json = nlohmann :: ordered_json ; int main () { ordered_json j ; j [ \"one\" ] = 1 ; j [ \"two\" ] = 2 ; j [ \"three\" ] = 3 ; std :: cout << j . dump ( 2 ) << '\\n' ; } Output: { \"one\" : 1 , \"two\" : 2 , \"three\" : 3 } Alternatively, you can use a more sophisticated ordered map like tsl::ordered_map ( integration ) or nlohmann::fifo_map ( integration ).","title":"Object Order"},{"location":"features/types/","text":"Types \u00b6 This page gives an overview how JSON values are stored and how this can be configured. Overview \u00b6 By default, JSON values are stored as follows: JSON type C++ type object std::map<std::string, basic_json> array std::vector<basic_json> null std::nullptr_t string std::string boolean bool number std::int64_t , std::uint64_t , and double Note there are three different types for numbers - when parsing JSON text, the best fitting type is chosen. Storage \u00b6 Template arguments \u00b6 The data types to store a JSON value are derived from the template arguments passed to class basic_json : template < template < typename U , typename V , typename ... Args > class ObjectType = std :: map , template < typename U , typename ... Args > class ArrayType = std :: vector , class StringType = std :: string , class BooleanType = bool , class NumberIntegerType = std :: int64_t , class NumberUnsignedType = std :: uint64_t , class NumberFloatType = double , template < typename U > class AllocatorType = std :: allocator , template < typename T , typename SFINAE = void > class JSONSerializer = adl_serializer , class BinaryType = std :: vector < std :: uint8_t > > class basic_json ; Type json is an alias for basic_json<> and uses the default types. From the template arguments, the following types are derived: using object_comparator_t = std :: less <> ; using object_t = ObjectType < StringType , basic_json , object_comparator_t , AllocatorType < std :: pair < const StringType , basic_json >>> ; using array_t = ArrayType < basic_json , AllocatorType < basic_json >> ; using string_t = StringType ; using boolean_t = BooleanType ; using number_integer_t = NumberIntegerType ; using number_unsigned_t = NumberUnsignedType ; using number_float_t = NumberFloatType ; using binary_t = nlohmann :: byte_container_with_subtype < BinaryType > ; Objects \u00b6 RFC 7159 describes JSON objects as follows: An object is an unordered collection of zero or more name/value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array. Default type \u00b6 With the default values for ObjectType ( std::map ), StringType ( std::string ), and AllocatorType ( std::allocator ), the default value for object_t is: std :: map < std :: string , // key_type basic_json , // value_type std :: less <> , // key_compare std :: allocator < std :: pair < const std :: string , basic_json >> // allocator_type > Behavior \u00b6 The choice of object_t influences the behavior of the JSON class. With the default type, objects have the following behavior: When all names are unique, objects will be interoperable in the sense that all software implementations receiving that object will agree on the name-value mappings. When the names within an object are not unique, it is unspecified which one of the values for a given key will be chosen. For instance, { \"key\" : 2 , \"key\" : 1 } could be equal to either { \"key\" : 1 } or { \"key\" : 2 } . Internally, name/value pairs are stored in lexicographical order of the names. Objects will also be serialized (see dump ) in this order. For instance, both { \"b\" : 1 , \"a\" : 2 } and { \"a\" : 2 , \"b\" : 1 } will be stored and serialized as { \"a\" : 2 , \"b\" : 1 } . When comparing objects, the order of the name/value pairs is irrelevant. This makes objects interoperable in the sense that they will not be affected by these differences. For instance, { \"b\" : 1 , \"a\" : 2 } and { \"a\" : 2 , \"b\" : 1 } will be treated as equal. Key order \u00b6 The order name/value pairs are added to the object is not preserved by the library. Therefore, iterating an object may return name/value pairs in a different order than they were originally stored. In fact, keys will be traversed in alphabetical order as std::map with std::less is used by default. Please note this behavior conforms to RFC 7159 , because any order implements the specified \"unordered\" nature of JSON objects. Limits \u00b6 RFC 7159 specifies: An implementation may set limits on the maximum depth of nesting. In this class, the object's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the max_size function of a JSON object. Storage \u00b6 Objects are stored as pointers in a basic_json type. That is, for any access to object values, a pointer of type object_t* must be dereferenced. Arrays \u00b6 RFC 7159 describes JSON arrays as follows: An array is an ordered sequence of zero or more values. Default type \u00b6 With the default values for ArrayType ( std::vector ) and AllocatorType ( std::allocator ), the default value for array_t is: std :: vector < basic_json , // value_type std :: allocator < basic_json > // allocator_type > Limits \u00b6 RFC 7159 specifies: An implementation may set limits on the maximum depth of nesting. In this class, the array's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the max_size function of a JSON array. Storage \u00b6 Arrays are stored as pointers in a basic_json type. That is, for any access to array values, a pointer of type array_t* must be dereferenced. Strings \u00b6 RFC 7159 describes JSON strings as follows: A string is a sequence of zero or more Unicode characters. Unicode values are split by the JSON class into byte-sized characters during deserialization. Default type \u00b6 With the default values for StringType ( std::string ), the default value for string_t is std :: string . Encoding \u00b6 Strings are stored in UTF-8 encoding. Therefore, functions like std::string::size() or std::string::length() return the number of bytes in the string rather than the number of characters or glyphs. String comparison \u00b6 RFC 7159 states: Software implementations are typically required to test names of object members for equality. Implementations that transform the textual representation into sequences of Unicode code units and then perform the comparison numerically, code unit by code unit, are interoperable in the sense that implementations will agree in all cases on equality or inequality of two strings. For example, implementations that compare strings with escaped characters unconverted may incorrectly find that \"a\\\\b\" and \"a\\u005Cb\" are not equal. This implementation is interoperable as it does compare strings code unit by code unit. Storage \u00b6 String values are stored as pointers in a basic_json type. That is, for any access to string values, a pointer of type string_t* must be dereferenced. Booleans \u00b6 RFC 7159 implicitly describes a boolean as a type which differentiates the two literals true and false . Default type \u00b6 With the default values for BooleanType ( bool ), the default value for boolean_t is bool . Storage \u00b6 Boolean values are stored directly inside a basic_json type. Numbers \u00b6 RFC 7159 describes numbers as follows: The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted. This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer or a floating-point number. Therefore, three different types, number_integer_t , number_unsigned_t , and number_float_t are used. Default types \u00b6 With the default values for NumberIntegerType ( std::int64_t ), the default value for number_integer_t is std::int64_t . With the default values for NumberUnsignedType ( std::uint64_t ), the default value for number_unsigned_t is std::uint64_t . With the default values for NumberFloatType ( double ), the default value for number_float_t is double . Default behavior \u00b6 The restrictions about leading zeros is not enforced in C++. Instead, leading zeros in integer literals lead to an interpretation as octal number. Internally, the value will be stored as decimal number. For instance, the C++ integer literal 010 will be serialized to 8 . During deserialization, leading zeros yield an error. Not-a-number (NaN) values will be serialized to null . Limits \u00b6 RFC 7159 specifies: An implementation may set limits on the range and precision of numbers. When the default type is used, the maximal integer number that can be stored is 9223372036854775807 ( INT64_MAX ) and the minimal integer number that can be stored is - 9223372036854775808 ( INT64_MIN ). Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will be automatically be stored as number_unsigned_t or number_float_t . When the default type is used, the maximal unsigned integer number that can be stored is 18446744073709551615 ( UINT64_MAX ) and the minimal integer number that can be stored is 0 . Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will be automatically be stored as number_integer_t or number_float_t . RFC 7159 further states: Note that when such software is used, numbers that are integers and are in the range [-2^{53}+1, 2^{53}-1] [-2^{53}+1, 2^{53}-1] are interoperable in the sense that implementations will agree exactly on their numeric values. As this range is a subrange of the exactly supported range [ INT64_MIN , INT64_MAX ], this class's integer type is interoperable. RFC 7159 states: This specification allows implementations to set limits on the range and precision of numbers accepted. Since software that implements IEEE 754-2008 binary64 (double precision) numbers is generally available and widely used, good interoperability can be achieved by implementations that expect no more precision or range than these provide, in the sense that implementations will approximate JSON numbers within the expected precision. This implementation does exactly follow this approach, as it uses double precision floating-point numbers. Note values smaller than - 1.79769313486232e+308 and values greater than 1.79769313486232e+308 will be stored as NaN internally and be serialized to null . Storage \u00b6 Integer number values, unsigned integer number values, and floating-point number values are stored directly inside a basic_json type.","title":"Types"},{"location":"features/types/#types","text":"This page gives an overview how JSON values are stored and how this can be configured.","title":"Types"},{"location":"features/types/#overview","text":"By default, JSON values are stored as follows: JSON type C++ type object std::map<std::string, basic_json> array std::vector<basic_json> null std::nullptr_t string std::string boolean bool number std::int64_t , std::uint64_t , and double Note there are three different types for numbers - when parsing JSON text, the best fitting type is chosen.","title":"Overview"},{"location":"features/types/#storage","text":"","title":"Storage"},{"location":"features/types/#template-arguments","text":"The data types to store a JSON value are derived from the template arguments passed to class basic_json : template < template < typename U , typename V , typename ... Args > class ObjectType = std :: map , template < typename U , typename ... Args > class ArrayType = std :: vector , class StringType = std :: string , class BooleanType = bool , class NumberIntegerType = std :: int64_t , class NumberUnsignedType = std :: uint64_t , class NumberFloatType = double , template < typename U > class AllocatorType = std :: allocator , template < typename T , typename SFINAE = void > class JSONSerializer = adl_serializer , class BinaryType = std :: vector < std :: uint8_t > > class basic_json ; Type json is an alias for basic_json<> and uses the default types. From the template arguments, the following types are derived: using object_comparator_t = std :: less <> ; using object_t = ObjectType < StringType , basic_json , object_comparator_t , AllocatorType < std :: pair < const StringType , basic_json >>> ; using array_t = ArrayType < basic_json , AllocatorType < basic_json >> ; using string_t = StringType ; using boolean_t = BooleanType ; using number_integer_t = NumberIntegerType ; using number_unsigned_t = NumberUnsignedType ; using number_float_t = NumberFloatType ; using binary_t = nlohmann :: byte_container_with_subtype < BinaryType > ;","title":"Template arguments"},{"location":"features/types/#objects","text":"RFC 7159 describes JSON objects as follows: An object is an unordered collection of zero or more name/value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array.","title":"Objects"},{"location":"features/types/#default-type","text":"With the default values for ObjectType ( std::map ), StringType ( std::string ), and AllocatorType ( std::allocator ), the default value for object_t is: std :: map < std :: string , // key_type basic_json , // value_type std :: less <> , // key_compare std :: allocator < std :: pair < const std :: string , basic_json >> // allocator_type >","title":"Default type"},{"location":"features/types/#behavior","text":"The choice of object_t influences the behavior of the JSON class. With the default type, objects have the following behavior: When all names are unique, objects will be interoperable in the sense that all software implementations receiving that object will agree on the name-value mappings. When the names within an object are not unique, it is unspecified which one of the values for a given key will be chosen. For instance, { \"key\" : 2 , \"key\" : 1 } could be equal to either { \"key\" : 1 } or { \"key\" : 2 } . Internally, name/value pairs are stored in lexicographical order of the names. Objects will also be serialized (see dump ) in this order. For instance, both { \"b\" : 1 , \"a\" : 2 } and { \"a\" : 2 , \"b\" : 1 } will be stored and serialized as { \"a\" : 2 , \"b\" : 1 } . When comparing objects, the order of the name/value pairs is irrelevant. This makes objects interoperable in the sense that they will not be affected by these differences. For instance, { \"b\" : 1 , \"a\" : 2 } and { \"a\" : 2 , \"b\" : 1 } will be treated as equal.","title":"Behavior"},{"location":"features/types/#key-order","text":"The order name/value pairs are added to the object is not preserved by the library. Therefore, iterating an object may return name/value pairs in a different order than they were originally stored. In fact, keys will be traversed in alphabetical order as std::map with std::less is used by default. Please note this behavior conforms to RFC 7159 , because any order implements the specified \"unordered\" nature of JSON objects.","title":"Key order"},{"location":"features/types/#limits","text":"RFC 7159 specifies: An implementation may set limits on the maximum depth of nesting. In this class, the object's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the max_size function of a JSON object.","title":"Limits"},{"location":"features/types/#storage_1","text":"Objects are stored as pointers in a basic_json type. That is, for any access to object values, a pointer of type object_t* must be dereferenced.","title":"Storage"},{"location":"features/types/#arrays","text":"RFC 7159 describes JSON arrays as follows: An array is an ordered sequence of zero or more values.","title":"Arrays"},{"location":"features/types/#default-type_1","text":"With the default values for ArrayType ( std::vector ) and AllocatorType ( std::allocator ), the default value for array_t is: std :: vector < basic_json , // value_type std :: allocator < basic_json > // allocator_type >","title":"Default type"},{"location":"features/types/#limits_1","text":"RFC 7159 specifies: An implementation may set limits on the maximum depth of nesting. In this class, the array's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the max_size function of a JSON array.","title":"Limits"},{"location":"features/types/#storage_2","text":"Arrays are stored as pointers in a basic_json type. That is, for any access to array values, a pointer of type array_t* must be dereferenced.","title":"Storage"},{"location":"features/types/#strings","text":"RFC 7159 describes JSON strings as follows: A string is a sequence of zero or more Unicode characters. Unicode values are split by the JSON class into byte-sized characters during deserialization.","title":"Strings"},{"location":"features/types/#default-type_2","text":"With the default values for StringType ( std::string ), the default value for string_t is std :: string .","title":"Default type"},{"location":"features/types/#encoding","text":"Strings are stored in UTF-8 encoding. Therefore, functions like std::string::size() or std::string::length() return the number of bytes in the string rather than the number of characters or glyphs.","title":"Encoding"},{"location":"features/types/#string-comparison","text":"RFC 7159 states: Software implementations are typically required to test names of object members for equality. Implementations that transform the textual representation into sequences of Unicode code units and then perform the comparison numerically, code unit by code unit, are interoperable in the sense that implementations will agree in all cases on equality or inequality of two strings. For example, implementations that compare strings with escaped characters unconverted may incorrectly find that \"a\\\\b\" and \"a\\u005Cb\" are not equal. This implementation is interoperable as it does compare strings code unit by code unit.","title":"String comparison"},{"location":"features/types/#storage_3","text":"String values are stored as pointers in a basic_json type. That is, for any access to string values, a pointer of type string_t* must be dereferenced.","title":"Storage"},{"location":"features/types/#booleans","text":"RFC 7159 implicitly describes a boolean as a type which differentiates the two literals true and false .","title":"Booleans"},{"location":"features/types/#default-type_3","text":"With the default values for BooleanType ( bool ), the default value for boolean_t is bool .","title":"Default type"},{"location":"features/types/#storage_4","text":"Boolean values are stored directly inside a basic_json type.","title":"Storage"},{"location":"features/types/#numbers","text":"RFC 7159 describes numbers as follows: The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted. This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer or a floating-point number. Therefore, three different types, number_integer_t , number_unsigned_t , and number_float_t are used.","title":"Numbers"},{"location":"features/types/#default-types","text":"With the default values for NumberIntegerType ( std::int64_t ), the default value for number_integer_t is std::int64_t . With the default values for NumberUnsignedType ( std::uint64_t ), the default value for number_unsigned_t is std::uint64_t . With the default values for NumberFloatType ( double ), the default value for number_float_t is double .","title":"Default types"},{"location":"features/types/#default-behavior","text":"The restrictions about leading zeros is not enforced in C++. Instead, leading zeros in integer literals lead to an interpretation as octal number. Internally, the value will be stored as decimal number. For instance, the C++ integer literal 010 will be serialized to 8 . During deserialization, leading zeros yield an error. Not-a-number (NaN) values will be serialized to null .","title":"Default behavior"},{"location":"features/types/#limits_2","text":"RFC 7159 specifies: An implementation may set limits on the range and precision of numbers. When the default type is used, the maximal integer number that can be stored is 9223372036854775807 ( INT64_MAX ) and the minimal integer number that can be stored is - 9223372036854775808 ( INT64_MIN ). Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will be automatically be stored as number_unsigned_t or number_float_t . When the default type is used, the maximal unsigned integer number that can be stored is 18446744073709551615 ( UINT64_MAX ) and the minimal integer number that can be stored is 0 . Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will be automatically be stored as number_integer_t or number_float_t . RFC 7159 further states: Note that when such software is used, numbers that are integers and are in the range [-2^{53}+1, 2^{53}-1] [-2^{53}+1, 2^{53}-1] are interoperable in the sense that implementations will agree exactly on their numeric values. As this range is a subrange of the exactly supported range [ INT64_MIN , INT64_MAX ], this class's integer type is interoperable. RFC 7159 states: This specification allows implementations to set limits on the range and precision of numbers accepted. Since software that implements IEEE 754-2008 binary64 (double precision) numbers is generally available and widely used, good interoperability can be achieved by implementations that expect no more precision or range than these provide, in the sense that implementations will approximate JSON numbers within the expected precision. This implementation does exactly follow this approach, as it uses double precision floating-point numbers. Note values smaller than - 1.79769313486232e+308 and values greater than 1.79769313486232e+308 will be stored as NaN internally and be serialized to null .","title":"Limits"},{"location":"features/types/#storage_5","text":"Integer number values, unsigned integer number values, and floating-point number values are stored directly inside a basic_json type.","title":"Storage"},{"location":"features/binary_formats/","text":"Overview \u00b6 Though JSON is a ubiquitous data format, it is not a very compact format suitable for data exchange, for instance over a network. Hence, the library supports BSON (Binary JSON), CBOR (Concise Binary Object Representation), MessagePack , and UBJSON (Universal Binary JSON) to efficiently encode JSON values to byte vectors and to decode such vectors. Comparison \u00b6 Completeness \u00b6 Format Serialization Deserialization BSON incomplete: top-level value must be an object incomplete, but all JSON types are supported CBOR complete incomplete, but all JSON types are supported MessagePack complete complete UBJSON complete complete Binary values \u00b6 Format Binary values Binary subtypes BSON supported supported CBOR supported not supported MessagePack supported supported UBJSON not supported not supported See binary values for more information. Sizes \u00b6 Format canada.json twitter.json citm_catalog.json jeopardy.json BSON 85,8 % 95,2 % 95,8 % 106,7 % CBOR 50,5 % 86,3 % 68,4 % 88,0 % MessagePack 50,6 % 86,0 % 68,5 % 87,9 % UBJSON 53,2 % 91,3 % 78,2 % 96,6 % UBJSON (size) 58,6 % 92,3 % 86,8 % 97,4 % UBJSON (size+type) 55,9 % 92,3 % 85,0 % 95,0 % Sizes compared to minified JSON value.","title":"Overview"},{"location":"features/binary_formats/#overview","text":"Though JSON is a ubiquitous data format, it is not a very compact format suitable for data exchange, for instance over a network. Hence, the library supports BSON (Binary JSON), CBOR (Concise Binary Object Representation), MessagePack , and UBJSON (Universal Binary JSON) to efficiently encode JSON values to byte vectors and to decode such vectors.","title":"Overview"},{"location":"features/binary_formats/#comparison","text":"","title":"Comparison"},{"location":"features/binary_formats/#completeness","text":"Format Serialization Deserialization BSON incomplete: top-level value must be an object incomplete, but all JSON types are supported CBOR complete incomplete, but all JSON types are supported MessagePack complete complete UBJSON complete complete","title":"Completeness"},{"location":"features/binary_formats/#binary-values","text":"Format Binary values Binary subtypes BSON supported supported CBOR supported not supported MessagePack supported supported UBJSON not supported not supported See binary values for more information.","title":"Binary values"},{"location":"features/binary_formats/#sizes","text":"Format canada.json twitter.json citm_catalog.json jeopardy.json BSON 85,8 % 95,2 % 95,8 % 106,7 % CBOR 50,5 % 86,3 % 68,4 % 88,0 % MessagePack 50,6 % 86,0 % 68,5 % 87,9 % UBJSON 53,2 % 91,3 % 78,2 % 96,6 % UBJSON (size) 58,6 % 92,3 % 86,8 % 97,4 % UBJSON (size+type) 55,9 % 92,3 % 85,0 % 95,0 % Sizes compared to minified JSON value.","title":"Sizes"},{"location":"features/binary_formats/bson/","text":"BSON \u00b6 BSON, short for Bin\u00adary JSON, is a bin\u00adary-en\u00adcoded seri\u00adal\u00adiz\u00ada\u00adtion of JSON-like doc\u00adu\u00adments. Like JSON, BSON sup\u00adports the em\u00adbed\u00adding of doc\u00adu\u00adments and ar\u00adrays with\u00adin oth\u00ader doc\u00adu\u00adments and ar\u00adrays. BSON also con\u00adtains ex\u00adten\u00adsions that al\u00adlow rep\u00adres\u00adent\u00ada\u00adtion of data types that are not part of the JSON spec. For ex\u00adample, BSON has a Date type and a BinData type. References BSON Website - the main source on BSON BSON Specification - the specification Serialization \u00b6 The library uses the following mapping from JSON values types to BSON types: JSON value type value/range BSON type marker null null null 0x0A boolean true , false boolean 0x08 number_integer -9223372036854775808..-2147483649 int64 0x12 number_integer -2147483648..2147483647 int32 0x10 number_integer 2147483648..9223372036854775807 int64 0x12 number_unsigned 0..2147483647 int32 0x10 number_unsigned 2147483648..9223372036854775807 int64 0x12 number_unsigned 9223372036854775808..18446744073709551615 -- -- number_float any value double 0x01 string any value string 0x02 array any value document 0x04 object any value document 0x03 binary any value binary 0x05 Incomplete mapping The mapping is incomplete , since only JSON-objects (and things contained therein) can be serialized to BSON. Also, integers larger than 9223372036854775807 cannot be serialized to BSON, and the keys may not contain U+0000, since they are serialized a zero-terminated c-strings. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to BSON std :: vector < uint8_t > v = json :: to_bson ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0x1b 0x00 0x00 0x00 0x08 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0x00 0x01 0x10 0x73 0x63 0x68 0x65 0x6d 0x61 0x00 0x00 0x00 0x00 0x00 0x00 Deserialization \u00b6 The library maps BSON record types to JSON value types as follows: BSON type BSON marker byte JSON value type double 0x01 number_float string 0x02 string document 0x03 object array 0x04 array binary 0x05 binary undefined 0x06 unsupported ObjectId 0x07 unsupported boolean 0x08 boolean UTC Date-Time 0x09 unsupported null 0x0A null Regular Expr. 0x0B unsupported DB Pointer 0x0C unsupported JavaScript Code 0x0D unsupported Symbol 0x0E unsupported JavaScript Code 0x0F unsupported int32 0x10 number_integer Timestamp 0x11 unsupported 128-bit decimal float 0x13 unsupported Max Key 0x7F unsupported Min Key 0xFF unsupported Incomplete mapping The mapping is incomplete . The unsupported mappings are indicated in the table above. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x1b , 0x00 , 0x00 , 0x00 , 0x08 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0x00 , 0x01 , 0x10 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 }; // deserialize it with BSON json j = json :: from_bson ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"BSON"},{"location":"features/binary_formats/bson/#bson","text":"BSON, short for Bin\u00adary JSON, is a bin\u00adary-en\u00adcoded seri\u00adal\u00adiz\u00ada\u00adtion of JSON-like doc\u00adu\u00adments. Like JSON, BSON sup\u00adports the em\u00adbed\u00adding of doc\u00adu\u00adments and ar\u00adrays with\u00adin oth\u00ader doc\u00adu\u00adments and ar\u00adrays. BSON also con\u00adtains ex\u00adten\u00adsions that al\u00adlow rep\u00adres\u00adent\u00ada\u00adtion of data types that are not part of the JSON spec. For ex\u00adample, BSON has a Date type and a BinData type. References BSON Website - the main source on BSON BSON Specification - the specification","title":"BSON"},{"location":"features/binary_formats/bson/#serialization","text":"The library uses the following mapping from JSON values types to BSON types: JSON value type value/range BSON type marker null null null 0x0A boolean true , false boolean 0x08 number_integer -9223372036854775808..-2147483649 int64 0x12 number_integer -2147483648..2147483647 int32 0x10 number_integer 2147483648..9223372036854775807 int64 0x12 number_unsigned 0..2147483647 int32 0x10 number_unsigned 2147483648..9223372036854775807 int64 0x12 number_unsigned 9223372036854775808..18446744073709551615 -- -- number_float any value double 0x01 string any value string 0x02 array any value document 0x04 object any value document 0x03 binary any value binary 0x05 Incomplete mapping The mapping is incomplete , since only JSON-objects (and things contained therein) can be serialized to BSON. Also, integers larger than 9223372036854775807 cannot be serialized to BSON, and the keys may not contain U+0000, since they are serialized a zero-terminated c-strings. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to BSON std :: vector < uint8_t > v = json :: to_bson ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0x1b 0x00 0x00 0x00 0x08 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0x00 0x01 0x10 0x73 0x63 0x68 0x65 0x6d 0x61 0x00 0x00 0x00 0x00 0x00 0x00","title":"Serialization"},{"location":"features/binary_formats/bson/#deserialization","text":"The library maps BSON record types to JSON value types as follows: BSON type BSON marker byte JSON value type double 0x01 number_float string 0x02 string document 0x03 object array 0x04 array binary 0x05 binary undefined 0x06 unsupported ObjectId 0x07 unsupported boolean 0x08 boolean UTC Date-Time 0x09 unsupported null 0x0A null Regular Expr. 0x0B unsupported DB Pointer 0x0C unsupported JavaScript Code 0x0D unsupported Symbol 0x0E unsupported JavaScript Code 0x0F unsupported int32 0x10 number_integer Timestamp 0x11 unsupported 128-bit decimal float 0x13 unsupported Max Key 0x7F unsupported Min Key 0xFF unsupported Incomplete mapping The mapping is incomplete . The unsupported mappings are indicated in the table above. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x1b , 0x00 , 0x00 , 0x00 , 0x08 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0x00 , 0x01 , 0x10 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 , 0x00 }; // deserialize it with BSON json j = json :: from_bson ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"Deserialization"},{"location":"features/binary_formats/cbor/","text":"CBOR \u00b6 The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. References CBOR Website - the main source on CBOR CBOR Playground - an interactive webpage to translate between JSON and CBOR RFC 7049 - the CBOR specification Serialization \u00b6 The library uses the following mapping from JSON values types to CBOR types according to the CBOR specification (RFC 7049): JSON value type value/range CBOR type first byte null null Null 0xF6 boolean true True 0xF5 boolean false False 0xF4 number_integer -9223372036854775808..-2147483649 Negative integer (8 bytes follow) 0x3B number_integer -2147483648..-32769 Negative integer (4 bytes follow) 0x3A number_integer -32768..-129 Negative integer (2 bytes follow) 0x39 number_integer -128..-25 Negative integer (1 byte follow) 0x38 number_integer -24..-1 Negative integer 0x20..0x37 number_integer 0..23 Integer 0x00..0x17 number_integer 24..255 Unsigned integer (1 byte follow) 0x18 number_integer 256..65535 Unsigned integer (2 bytes follow) 0x19 number_integer 65536..4294967295 Unsigned integer (4 bytes follow) 0x1A number_integer 4294967296..18446744073709551615 Unsigned integer (8 bytes follow) 0x1B number_unsigned 0..23 Integer 0x00..0x17 number_unsigned 24..255 Unsigned integer (1 byte follow) 0x18 number_unsigned 256..65535 Unsigned integer (2 bytes follow) 0x19 number_unsigned 65536..4294967295 Unsigned integer (4 bytes follow) 0x1A number_unsigned 4294967296..18446744073709551615 Unsigned integer (8 bytes follow) 0x1B number_float any value representable by a float Single-Precision Float 0xFA number_float any value NOT representable by a float Double-Precision Float 0xFB string length : 0..23 UTF-8 string 0x60..0x77 string length : 23..255 UTF-8 string (1 byte follow) 0x78 string length : 256..65535 UTF-8 string (2 bytes follow) 0x79 string length : 65536..4294967295 UTF-8 string (4 bytes follow) 0x7A string length : 4294967296..18446744073709551615 UTF-8 string (8 bytes follow) 0x7B array size : 0..23 array 0x80..0x97 array size : 23..255 array (1 byte follow) 0x98 array size : 256..65535 array (2 bytes follow) 0x99 array size : 65536..4294967295 array (4 bytes follow) 0x9A array size : 4294967296..18446744073709551615 array (8 bytes follow) 0x9B object size : 0..23 map 0xA0..0xB7 object size : 23..255 map (1 byte follow) 0xB8 object size : 256..65535 map (2 bytes follow) 0xB9 object size : 65536..4294967295 map (4 bytes follow) 0xBA object size : 4294967296..18446744073709551615 map (8 bytes follow) 0xBB binary size : 0..23 byte string 0x40..0x57 binary size : 23..255 byte string (1 byte follow) 0x58 binary size : 256..65535 byte string (2 bytes follow) 0x59 binary size : 65536..4294967295 byte string (4 bytes follow) 0x5A binary size : 4294967296..18446744073709551615 byte string (8 bytes follow) 0x5B Complete mapping The mapping is complete in the sense that any JSON value type can be converted to a CBOR value. NaN/infinity handling If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the normal JSON serialization which serializes NaN or Infinity to null . Unused CBOR types The following CBOR types are not used in the conversion: UTF-8 strings terminated by \"break\" (0x7F) arrays terminated by \"break\" (0x9F) maps terminated by \"break\" (0xBF) byte strings terminated by \"break\" (0x5F) date/time (0xC0..0xC1) bignum (0xC2..0xC3) decimal fraction (0xC4) bigfloat (0xC5) expected conversions (0xD5..0xD7) simple values (0xE0..0xF3, 0xF8) undefined (0xF7) half-precision floats (0xF9) break (0xFF) Tagged items Binary subtypes will be serialized as tagged items. See binary values for an example. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to CBOR std :: vector < uint8_t > v = json :: to_cbor ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0xa2 0x67 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0xf5 0x66 0x73 0x63 0x68 0x65 0x6d 0x61 0x00 Deserialization \u00b6 The library maps CBOR types to JSON value types as follows: CBOR type JSON value type first byte Integer number_unsigned 0x00..0x17 Unsigned integer number_unsigned 0x18 Unsigned integer number_unsigned 0x19 Unsigned integer number_unsigned 0x1A Unsigned integer number_unsigned 0x1B Negative integer number_integer 0x20..0x37 Negative integer number_integer 0x38 Negative integer number_integer 0x39 Negative integer number_integer 0x3A Negative integer number_integer 0x3B Byte string binary 0x40..0x57 Byte string binary 0x58 Byte string binary 0x59 Byte string binary 0x5A Byte string binary 0x5B UTF-8 string string 0x60..0x77 UTF-8 string string 0x78 UTF-8 string string 0x79 UTF-8 string string 0x7A UTF-8 string string 0x7B UTF-8 string string 0x7F array array 0x80..0x97 array array 0x98 array array 0x99 array array 0x9A array array 0x9B array array 0x9F map object 0xA0..0xB7 map object 0xB8 map object 0xB9 map object 0xBA map object 0xBB map object 0xBF False false 0xF4 True true 0xF5 Null null 0xF6 Half-Precision Float number_float 0xF9 Single-Precision Float number_float 0xFA Double-Precision Float number_float 0xFB Incomplete mapping The mapping is incomplete in the sense that not all CBOR types can be converted to a JSON value. The following CBOR types are not supported and will yield parse errors: date/time (0xC0..0xC1) bignum (0xC2..0xC3) decimal fraction (0xC4) bigfloat (0xC5) expected conversions (0xD5..0xD7) simple values (0xE0..0xF3, 0xF8) undefined (0xF7) Object keys CBOR allows map keys of any type, whereas JSON only allows strings as keys in object values. Therefore, CBOR maps with keys other than UTF-8 strings are rejected. Tagged items Tagged items will throw a parse error by default. However, they can be ignored by passing cbor_tag_handler_t::ignore to function from_cbor . Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0xa2 , 0x67 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0xf5 , 0x66 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 }; // deserialize it with CBOR json j = json :: from_cbor ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"CBOR"},{"location":"features/binary_formats/cbor/#cbor","text":"The Concise Binary Object Representation (CBOR) is a data format whose design goals include the possibility of extremely small code size, fairly small message size, and extensibility without the need for version negotiation. References CBOR Website - the main source on CBOR CBOR Playground - an interactive webpage to translate between JSON and CBOR RFC 7049 - the CBOR specification","title":"CBOR"},{"location":"features/binary_formats/cbor/#serialization","text":"The library uses the following mapping from JSON values types to CBOR types according to the CBOR specification (RFC 7049): JSON value type value/range CBOR type first byte null null Null 0xF6 boolean true True 0xF5 boolean false False 0xF4 number_integer -9223372036854775808..-2147483649 Negative integer (8 bytes follow) 0x3B number_integer -2147483648..-32769 Negative integer (4 bytes follow) 0x3A number_integer -32768..-129 Negative integer (2 bytes follow) 0x39 number_integer -128..-25 Negative integer (1 byte follow) 0x38 number_integer -24..-1 Negative integer 0x20..0x37 number_integer 0..23 Integer 0x00..0x17 number_integer 24..255 Unsigned integer (1 byte follow) 0x18 number_integer 256..65535 Unsigned integer (2 bytes follow) 0x19 number_integer 65536..4294967295 Unsigned integer (4 bytes follow) 0x1A number_integer 4294967296..18446744073709551615 Unsigned integer (8 bytes follow) 0x1B number_unsigned 0..23 Integer 0x00..0x17 number_unsigned 24..255 Unsigned integer (1 byte follow) 0x18 number_unsigned 256..65535 Unsigned integer (2 bytes follow) 0x19 number_unsigned 65536..4294967295 Unsigned integer (4 bytes follow) 0x1A number_unsigned 4294967296..18446744073709551615 Unsigned integer (8 bytes follow) 0x1B number_float any value representable by a float Single-Precision Float 0xFA number_float any value NOT representable by a float Double-Precision Float 0xFB string length : 0..23 UTF-8 string 0x60..0x77 string length : 23..255 UTF-8 string (1 byte follow) 0x78 string length : 256..65535 UTF-8 string (2 bytes follow) 0x79 string length : 65536..4294967295 UTF-8 string (4 bytes follow) 0x7A string length : 4294967296..18446744073709551615 UTF-8 string (8 bytes follow) 0x7B array size : 0..23 array 0x80..0x97 array size : 23..255 array (1 byte follow) 0x98 array size : 256..65535 array (2 bytes follow) 0x99 array size : 65536..4294967295 array (4 bytes follow) 0x9A array size : 4294967296..18446744073709551615 array (8 bytes follow) 0x9B object size : 0..23 map 0xA0..0xB7 object size : 23..255 map (1 byte follow) 0xB8 object size : 256..65535 map (2 bytes follow) 0xB9 object size : 65536..4294967295 map (4 bytes follow) 0xBA object size : 4294967296..18446744073709551615 map (8 bytes follow) 0xBB binary size : 0..23 byte string 0x40..0x57 binary size : 23..255 byte string (1 byte follow) 0x58 binary size : 256..65535 byte string (2 bytes follow) 0x59 binary size : 65536..4294967295 byte string (4 bytes follow) 0x5A binary size : 4294967296..18446744073709551615 byte string (8 bytes follow) 0x5B Complete mapping The mapping is complete in the sense that any JSON value type can be converted to a CBOR value. NaN/infinity handling If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the normal JSON serialization which serializes NaN or Infinity to null . Unused CBOR types The following CBOR types are not used in the conversion: UTF-8 strings terminated by \"break\" (0x7F) arrays terminated by \"break\" (0x9F) maps terminated by \"break\" (0xBF) byte strings terminated by \"break\" (0x5F) date/time (0xC0..0xC1) bignum (0xC2..0xC3) decimal fraction (0xC4) bigfloat (0xC5) expected conversions (0xD5..0xD7) simple values (0xE0..0xF3, 0xF8) undefined (0xF7) half-precision floats (0xF9) break (0xFF) Tagged items Binary subtypes will be serialized as tagged items. See binary values for an example. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to CBOR std :: vector < uint8_t > v = json :: to_cbor ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0xa2 0x67 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0xf5 0x66 0x73 0x63 0x68 0x65 0x6d 0x61 0x00","title":"Serialization"},{"location":"features/binary_formats/cbor/#deserialization","text":"The library maps CBOR types to JSON value types as follows: CBOR type JSON value type first byte Integer number_unsigned 0x00..0x17 Unsigned integer number_unsigned 0x18 Unsigned integer number_unsigned 0x19 Unsigned integer number_unsigned 0x1A Unsigned integer number_unsigned 0x1B Negative integer number_integer 0x20..0x37 Negative integer number_integer 0x38 Negative integer number_integer 0x39 Negative integer number_integer 0x3A Negative integer number_integer 0x3B Byte string binary 0x40..0x57 Byte string binary 0x58 Byte string binary 0x59 Byte string binary 0x5A Byte string binary 0x5B UTF-8 string string 0x60..0x77 UTF-8 string string 0x78 UTF-8 string string 0x79 UTF-8 string string 0x7A UTF-8 string string 0x7B UTF-8 string string 0x7F array array 0x80..0x97 array array 0x98 array array 0x99 array array 0x9A array array 0x9B array array 0x9F map object 0xA0..0xB7 map object 0xB8 map object 0xB9 map object 0xBA map object 0xBB map object 0xBF False false 0xF4 True true 0xF5 Null null 0xF6 Half-Precision Float number_float 0xF9 Single-Precision Float number_float 0xFA Double-Precision Float number_float 0xFB Incomplete mapping The mapping is incomplete in the sense that not all CBOR types can be converted to a JSON value. The following CBOR types are not supported and will yield parse errors: date/time (0xC0..0xC1) bignum (0xC2..0xC3) decimal fraction (0xC4) bigfloat (0xC5) expected conversions (0xD5..0xD7) simple values (0xE0..0xF3, 0xF8) undefined (0xF7) Object keys CBOR allows map keys of any type, whereas JSON only allows strings as keys in object values. Therefore, CBOR maps with keys other than UTF-8 strings are rejected. Tagged items Tagged items will throw a parse error by default. However, they can be ignored by passing cbor_tag_handler_t::ignore to function from_cbor . Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0xa2 , 0x67 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0xf5 , 0x66 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 }; // deserialize it with CBOR json j = json :: from_cbor ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"Deserialization"},{"location":"features/binary_formats/messagepack/","text":"MessagePack \u00b6 MessagePack is an efficient binary serialization format. It lets you exchange data among multiple languages like JSON. But it's faster and smaller. Small integers are encoded into a single byte, and typical short strings require only one extra byte in addition to the strings themselves. References MessagePack website MessagePack specification Serialization \u00b6 The library uses the following mapping from JSON values types to MessagePack types according to the MessagePack specification: JSON value type value/range MessagePack type first byte null null nil 0xC0 boolean true true 0xC3 boolean false false 0xC2 number_integer -9223372036854775808..-2147483649 int64 0xD3 number_integer -2147483648..-32769 int32 0xD2 number_integer -32768..-129 int16 0xD1 number_integer -128..-33 int8 0xD0 number_integer -32..-1 negative fixint 0xE0..0xFF number_integer 0..127 positive fixint 0x00..0x7F number_integer 128..255 uint 8 0xCC number_integer 256..65535 uint 16 0xCD number_integer 65536..4294967295 uint 32 0xCE number_integer 4294967296..18446744073709551615 uint 64 0xCF number_unsigned 0..127 positive fixint 0x00..0x7F number_unsigned 128..255 uint 8 0xCC number_unsigned 256..65535 uint 16 0xCD number_unsigned 65536..4294967295 uint 32 0xCE number_unsigned 4294967296..18446744073709551615 uint 64 0xCF number_float any value representable by a float float 32 0xCA number_float any value NOT representable by a float float 64 0xCB string length : 0..31 fixstr 0xA0..0xBF string length : 32..255 str 8 0xD9 string length : 256..65535 str 16 0xDA string length : 65536..4294967295 str 32 0xDB array size : 0..15 fixarray 0x90..0x9F array size : 16..65535 array 16 0xDC array size : 65536..4294967295 array 32 0xDD object size : 0..15 fix map 0x80..0x8F object size : 16..65535 map 16 0xDE object size : 65536..4294967295 map 32 0xDF binary size : 0..255 bin 8 0xC4 binary size : 256..65535 bin 16 0xC5 binary size : 65536..4294967295 bin 32 0xC6 Complete mapping The mapping is complete in the sense that any JSON value type can be converted to a MessagePack value. Any MessagePack output created by to_msgpack can be successfully parsed by from_msgpack . Size constraints The following values can not be converted to a MessagePack value: strings with more than 4294967295 bytes byte strings with more than 4294967295 bytes arrays with more than 4294967295 elements objects with more than 4294967295 elements NaN/infinity handling If NaN or Infinity are stored inside a JSON number, they are serialized properly. function which serializes NaN or Infinity to null . Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to MessagePack std :: vector < uint8_t > v = json :: to_msgpack ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0x82 0xa7 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0xc3 0xa6 0x73 0x63 0x68 0x65 0x6d 0x61 0x00 Deserialization \u00b6 The library maps MessagePack types to JSON value types as follows: MessagePack type JSON value type first byte positive fixint number_unsigned 0x00..0x7F fixmap object 0x80..0x8F fixarray array 0x90..0x9F fixstr string 0xA0..0xBF nil null 0xC0 false false 0xC2 true true 0xC3 float 32 number_float 0xCA float 64 number_float 0xCB uint 8 number_unsigned 0xCC uint 16 number_unsigned 0xCD uint 32 number_unsigned 0xCE uint 64 number_unsigned 0xCF int 8 number_integer 0xD0 int 16 number_integer 0xD1 int 32 number_integer 0xD2 int 64 number_integer 0xD3 str 8 string 0xD9 str 16 string 0xDA str 32 string 0xDB array 16 array 0xDC array 32 array 0xDD map 16 object 0xDE map 32 object 0xDF bin 8 binary 0xC4 bin 16 binary 0xC5 bin 32 binary 0xC6 ext 8 binary 0xC7 ext 16 binary 0xC8 ext 32 binary 0xC9 fixext 1 binary 0xD4 fixext 2 binary 0xD5 fixext 4 binary 0xD6 fixext 8 binary 0xD7 fixext 16 binary 0xD8 negative fixint number_integer 0xE0-0xFF Info Any MessagePack output created by to_msgpack can be successfully parsed by from_msgpack . Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x82 , 0xa7 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0xc3 , 0xa6 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 }; // deserialize it with MessagePack json j = json :: from_msgpack ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"MessagePack"},{"location":"features/binary_formats/messagepack/#messagepack","text":"MessagePack is an efficient binary serialization format. It lets you exchange data among multiple languages like JSON. But it's faster and smaller. Small integers are encoded into a single byte, and typical short strings require only one extra byte in addition to the strings themselves. References MessagePack website MessagePack specification","title":"MessagePack"},{"location":"features/binary_formats/messagepack/#serialization","text":"The library uses the following mapping from JSON values types to MessagePack types according to the MessagePack specification: JSON value type value/range MessagePack type first byte null null nil 0xC0 boolean true true 0xC3 boolean false false 0xC2 number_integer -9223372036854775808..-2147483649 int64 0xD3 number_integer -2147483648..-32769 int32 0xD2 number_integer -32768..-129 int16 0xD1 number_integer -128..-33 int8 0xD0 number_integer -32..-1 negative fixint 0xE0..0xFF number_integer 0..127 positive fixint 0x00..0x7F number_integer 128..255 uint 8 0xCC number_integer 256..65535 uint 16 0xCD number_integer 65536..4294967295 uint 32 0xCE number_integer 4294967296..18446744073709551615 uint 64 0xCF number_unsigned 0..127 positive fixint 0x00..0x7F number_unsigned 128..255 uint 8 0xCC number_unsigned 256..65535 uint 16 0xCD number_unsigned 65536..4294967295 uint 32 0xCE number_unsigned 4294967296..18446744073709551615 uint 64 0xCF number_float any value representable by a float float 32 0xCA number_float any value NOT representable by a float float 64 0xCB string length : 0..31 fixstr 0xA0..0xBF string length : 32..255 str 8 0xD9 string length : 256..65535 str 16 0xDA string length : 65536..4294967295 str 32 0xDB array size : 0..15 fixarray 0x90..0x9F array size : 16..65535 array 16 0xDC array size : 65536..4294967295 array 32 0xDD object size : 0..15 fix map 0x80..0x8F object size : 16..65535 map 16 0xDE object size : 65536..4294967295 map 32 0xDF binary size : 0..255 bin 8 0xC4 binary size : 256..65535 bin 16 0xC5 binary size : 65536..4294967295 bin 32 0xC6 Complete mapping The mapping is complete in the sense that any JSON value type can be converted to a MessagePack value. Any MessagePack output created by to_msgpack can be successfully parsed by from_msgpack . Size constraints The following values can not be converted to a MessagePack value: strings with more than 4294967295 bytes byte strings with more than 4294967295 bytes arrays with more than 4294967295 elements objects with more than 4294967295 elements NaN/infinity handling If NaN or Infinity are stored inside a JSON number, they are serialized properly. function which serializes NaN or Infinity to null . Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": 0} ) \" _json ; // serialize it to MessagePack std :: vector < uint8_t > v = json :: to_msgpack ( j ); // print the vector content for ( auto & byte : v ) { std :: cout << \"0x\" << std :: hex << std :: setw ( 2 ) << std :: setfill ( '0' ) << ( int ) byte << \" \" ; } std :: cout << std :: endl ; } Output: 0x82 0xa7 0x63 0x6f 0x6d 0x70 0x61 0x63 0x74 0xc3 0xa6 0x73 0x63 0x68 0x65 0x6d 0x61 0x00","title":"Serialization"},{"location":"features/binary_formats/messagepack/#deserialization","text":"The library maps MessagePack types to JSON value types as follows: MessagePack type JSON value type first byte positive fixint number_unsigned 0x00..0x7F fixmap object 0x80..0x8F fixarray array 0x90..0x9F fixstr string 0xA0..0xBF nil null 0xC0 false false 0xC2 true true 0xC3 float 32 number_float 0xCA float 64 number_float 0xCB uint 8 number_unsigned 0xCC uint 16 number_unsigned 0xCD uint 32 number_unsigned 0xCE uint 64 number_unsigned 0xCF int 8 number_integer 0xD0 int 16 number_integer 0xD1 int 32 number_integer 0xD2 int 64 number_integer 0xD3 str 8 string 0xD9 str 16 string 0xDA str 32 string 0xDB array 16 array 0xDC array 32 array 0xDD map 16 object 0xDE map 32 object 0xDF bin 8 binary 0xC4 bin 16 binary 0xC5 bin 32 binary 0xC6 ext 8 binary 0xC7 ext 16 binary 0xC8 ext 32 binary 0xC9 fixext 1 binary 0xD4 fixext 2 binary 0xD5 fixext 4 binary 0xD6 fixext 8 binary 0xD7 fixext 16 binary 0xD8 negative fixint number_integer 0xE0-0xFF Info Any MessagePack output created by to_msgpack can be successfully parsed by from_msgpack . Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x82 , 0xa7 , 0x63 , 0x6f , 0x6d , 0x70 , 0x61 , 0x63 , 0x74 , 0xc3 , 0xa6 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6d , 0x61 , 0x00 }; // deserialize it with MessagePack json j = json :: from_msgpack ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"Deserialization"},{"location":"features/binary_formats/ubjson/","text":"UBJSON \u00b6 Universal Binary JSON (UBJSON) is a binary form directly imitating JSON, but requiring fewer bytes of data. It aims to achieve the generality of JSON, combined with being much easier to process than JSON. References UBJSON Website Serialization \u00b6 The library uses the following mapping from JSON values types to UBJSON types according to the UBJSON specification: JSON value type value/range UBJSON type marker null null null Z boolean true true T boolean false false F number_integer -9223372036854775808..-2147483649 int64 L number_integer -2147483648..-32769 int32 l number_integer -32768..-129 int16 I number_integer -128..127 int8 i number_integer 128..255 uint8 U number_integer 256..32767 int16 I number_integer 32768..2147483647 int32 l number_integer 2147483648..9223372036854775807 int64 L number_unsigned 0..127 int8 i number_unsigned 128..255 uint8 U number_unsigned 256..32767 int16 I number_unsigned 32768..2147483647 int32 l number_unsigned 2147483648..9223372036854775807 int64 L number_unsigned 2147483649..18446744073709551615 high-precision H number_float any value float64 D string with shortest length indicator string S array see notes on optimized format array [ object see notes on optimized format map { Complete mapping The mapping is complete in the sense that any JSON value type can be converted to a UBJSON value. Any UBJSON output created by to_ubjson can be successfully parsed by from_ubjson . Size constraints The following values can not be converted to a UBJSON value: strings with more than 9223372036854775807 bytes (theoretical) Unused UBJSON markers The following markers are not used in the conversion: Z : no-op values are not created. C : single-byte strings are serialized with S markers. NaN/infinity handling If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the dump() function which serializes NaN or Infinity to null . Optimized formats The optimized formats for containers are supported: Parameter use_size adds size information to the beginning of a container and removes the closing marker. Parameter use_type further checks whether all elements of a container have the same type and adds the type marker to the beginning of the container. The use_type parameter must only be used together with use_size = true . Note that use_size = true alone may result in larger representations - the benefit of this parameter is that the receiving side is immediately informed on the number of elements of the container. Binary values If the JSON data contains the binary type, the value stored is a list of integers, as suggested by the UBJSON documentation. In particular, this means that serialization and the deserialization of a JSON containing binary values into UBJSON and back will result in a different JSON object. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; // function to print UBJSON's diagnostic format void print_byte ( uint8_t byte ) { if ( 32 < byte and byte < 128 ) { std :: cout << ( char ) byte ; } else { std :: cout << ( int ) byte ; } } int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": false} ) \" _json ; // serialize it to UBJSON std :: vector < uint8_t > v = json :: to_ubjson ( j ); // print the vector content for ( auto & byte : v ) { print_byte ( byte ); } std :: cout << std :: endl ; // create an array of numbers json array = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 }; // serialize it to UBJSON using default representation std :: vector < uint8_t > v_array = json :: to_ubjson ( array ); // serialize it to UBJSON using size optimization std :: vector < uint8_t > v_array_size = json :: to_ubjson ( array , true ); // serialize it to UBJSON using type optimization std :: vector < uint8_t > v_array_size_and_type = json :: to_ubjson ( array , true , true ); // print the vector contents for ( auto & byte : v_array ) { print_byte ( byte ); } std :: cout << std :: endl ; for ( auto & byte : v_array_size ) { print_byte ( byte ); } std :: cout << std :: endl ; for ( auto & byte : v_array_size_and_type ) { print_byte ( byte ); } std :: cout << std :: endl ; } Output: { i7compactTi6schemaF } [ i1i2i3i4i5i6i7i8 ] [ # i8i1i2i3i4i5i6i7i8 [ $ i # i812345678 Deserialization \u00b6 The library maps UBJSON types to JSON value types as follows: UBJSON type JSON value type marker no-op no value, next value is read N null null Z false false F true true T float32 number_float d float64 number_float D uint8 number_unsigned U int8 number_integer i int16 number_integer I int32 number_integer l int64 number_integer L string string S char string C array array (optimized values are supported) [ object object (optimized values are supported) { Complete mapping The mapping is complete in the sense that any UBJSON value can be converted to a JSON value. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x7B , 0x69 , 0x07 , 0x63 , 0x6F , 0x6D , 0x70 , 0x61 , 0x63 , 0x74 , 0x54 , 0x69 , 0x06 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6D , 0x61 , 0x69 , 0x00 , 0x7D }; // deserialize it with UBJSON json j = json :: from_ubjson ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"UBJSON"},{"location":"features/binary_formats/ubjson/#ubjson","text":"Universal Binary JSON (UBJSON) is a binary form directly imitating JSON, but requiring fewer bytes of data. It aims to achieve the generality of JSON, combined with being much easier to process than JSON. References UBJSON Website","title":"UBJSON"},{"location":"features/binary_formats/ubjson/#serialization","text":"The library uses the following mapping from JSON values types to UBJSON types according to the UBJSON specification: JSON value type value/range UBJSON type marker null null null Z boolean true true T boolean false false F number_integer -9223372036854775808..-2147483649 int64 L number_integer -2147483648..-32769 int32 l number_integer -32768..-129 int16 I number_integer -128..127 int8 i number_integer 128..255 uint8 U number_integer 256..32767 int16 I number_integer 32768..2147483647 int32 l number_integer 2147483648..9223372036854775807 int64 L number_unsigned 0..127 int8 i number_unsigned 128..255 uint8 U number_unsigned 256..32767 int16 I number_unsigned 32768..2147483647 int32 l number_unsigned 2147483648..9223372036854775807 int64 L number_unsigned 2147483649..18446744073709551615 high-precision H number_float any value float64 D string with shortest length indicator string S array see notes on optimized format array [ object see notes on optimized format map { Complete mapping The mapping is complete in the sense that any JSON value type can be converted to a UBJSON value. Any UBJSON output created by to_ubjson can be successfully parsed by from_ubjson . Size constraints The following values can not be converted to a UBJSON value: strings with more than 9223372036854775807 bytes (theoretical) Unused UBJSON markers The following markers are not used in the conversion: Z : no-op values are not created. C : single-byte strings are serialized with S markers. NaN/infinity handling If NaN or Infinity are stored inside a JSON number, they are serialized properly. This behavior differs from the dump() function which serializes NaN or Infinity to null . Optimized formats The optimized formats for containers are supported: Parameter use_size adds size information to the beginning of a container and removes the closing marker. Parameter use_type further checks whether all elements of a container have the same type and adds the type marker to the beginning of the container. The use_type parameter must only be used together with use_size = true . Note that use_size = true alone may result in larger representations - the benefit of this parameter is that the receiving side is immediately informed on the number of elements of the container. Binary values If the JSON data contains the binary type, the value stored is a list of integers, as suggested by the UBJSON documentation. In particular, this means that serialization and the deserialization of a JSON containing binary values into UBJSON and back will result in a different JSON object. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; // function to print UBJSON's diagnostic format void print_byte ( uint8_t byte ) { if ( 32 < byte and byte < 128 ) { std :: cout << ( char ) byte ; } else { std :: cout << ( int ) byte ; } } int main () { // create a JSON value json j = R \" ( {\"compact\": true, \"schema\": false} ) \" _json ; // serialize it to UBJSON std :: vector < uint8_t > v = json :: to_ubjson ( j ); // print the vector content for ( auto & byte : v ) { print_byte ( byte ); } std :: cout << std :: endl ; // create an array of numbers json array = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 }; // serialize it to UBJSON using default representation std :: vector < uint8_t > v_array = json :: to_ubjson ( array ); // serialize it to UBJSON using size optimization std :: vector < uint8_t > v_array_size = json :: to_ubjson ( array , true ); // serialize it to UBJSON using type optimization std :: vector < uint8_t > v_array_size_and_type = json :: to_ubjson ( array , true , true ); // print the vector contents for ( auto & byte : v_array ) { print_byte ( byte ); } std :: cout << std :: endl ; for ( auto & byte : v_array_size ) { print_byte ( byte ); } std :: cout << std :: endl ; for ( auto & byte : v_array_size_and_type ) { print_byte ( byte ); } std :: cout << std :: endl ; } Output: { i7compactTi6schemaF } [ i1i2i3i4i5i6i7i8 ] [ # i8i1i2i3i4i5i6i7i8 [ $ i # i812345678","title":"Serialization"},{"location":"features/binary_formats/ubjson/#deserialization","text":"The library maps UBJSON types to JSON value types as follows: UBJSON type JSON value type marker no-op no value, next value is read N null null Z false false F true true T float32 number_float d float64 number_float D uint8 number_unsigned U int8 number_integer i int16 number_integer I int32 number_integer l int64 number_integer L string string S char string C array array (optimized values are supported) [ object object (optimized values are supported) { Complete mapping The mapping is complete in the sense that any UBJSON value can be converted to a JSON value. Example #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // create byte vector std :: vector < uint8_t > v = { 0x7B , 0x69 , 0x07 , 0x63 , 0x6F , 0x6D , 0x70 , 0x61 , 0x63 , 0x74 , 0x54 , 0x69 , 0x06 , 0x73 , 0x63 , 0x68 , 0x65 , 0x6D , 0x61 , 0x69 , 0x00 , 0x7D }; // deserialize it with UBJSON json j = json :: from_ubjson ( v ); // print the deserialized JSON value std :: cout << std :: setw ( 2 ) << j << std :: endl ; } Output: { \"compact\" : true , \"schema\" : 0 }","title":"Deserialization"},{"location":"features/element_access/","text":"Overview \u00b6 There are many ways elements in a JSON value can be accessed: unchecked access via operator[] checked access via at access with default value via value iterators JSON pointers","title":"Overview"},{"location":"features/element_access/#overview","text":"There are many ways elements in a JSON value can be accessed: unchecked access via operator[] checked access via at access with default value via value iterators JSON pointers","title":"Overview"},{"location":"features/element_access/checked_access/","text":"Checked access: at \u00b6 Overview \u00b6 The at () member function performs checked access; that is, it returns a reference to the desired value if it exists and throws a basic_json::out_of_range exception otherwise. Example Consider the following JSON value: { \"name\" : \"Mary Smith\" , \"age\" : 42 , \"hobbies\" : [ \"hiking\" , \"reading\" ] } Assume the value is parsed to a json variable j . expression value j { \"name\" : \"Mary Smith\" , \"age\" : 42 , \"hobbies\" : [ \"hiking\" , \"reading\" ]} j . at ( \"name\" ) \"Mary Smith\" j . at ( \"age\" ) 42 j . at ( \"hobbies\" ) [ \"hiking\" , \"reading\" ] j . at ( \"hobbies\" ). at ( 0 ) \"hiking\" j . at ( \"hobbies\" ). at ( 1 ) \"reading\" The return value is a reference, so it can be modify the original value. Example j . at ( \"name\" ) = \"John Smith\" ; This code produces the following JSON value: { \"name\" : \"John Smith\" , \"age\" : 42 , \"hobbies\" : [ \"hiking\" , \"reading\" ] } When accessing an invalid index (i.e., and index greater than or equal to the array size) or the passed object key is non-existing, an exception is thrown. Example j . at ( \"hobbies\" ). at ( 3 ) = \"cooking\" ; This code produces the following exception: [json.exception.out_of_range.401] array index 3 is out of range Notes \u00b6 Exceptions at can only be used with objects (with a string argument) or with arrays (with a numeric argument). For other types, a basic_json::type_error is thrown. basic_json::out_of_range exception exceptions are thrown if the provided key is not found in an object or the provided index is invalid. Summary \u00b6 scenario non-const value const value access to existing object key reference to existing value is returned const reference to existing value is returned access to valid array index reference to existing value is returned const reference to existing value is returned access to non-existing object key basic_json::out_of_range exception is thrown basic_json::out_of_range exception is thrown access to invalid array index basic_json::out_of_range exception is thrown basic_json::out_of_range exception is thrown","title":"Checked access: at"},{"location":"features/element_access/checked_access/#checked-access-at","text":"","title":"Checked access: at"},{"location":"features/element_access/checked_access/#overview","text":"The at () member function performs checked access; that is, it returns a reference to the desired value if it exists and throws a basic_json::out_of_range exception otherwise. Example Consider the following JSON value: { \"name\" : \"Mary Smith\" , \"age\" : 42 , \"hobbies\" : [ \"hiking\" , \"reading\" ] } Assume the value is parsed to a json variable j . expression value j { \"name\" : \"Mary Smith\" , \"age\" : 42 , \"hobbies\" : [ \"hiking\" , \"reading\" ]} j . at ( \"name\" ) \"Mary Smith\" j . at ( \"age\" ) 42 j . at ( \"hobbies\" ) [ \"hiking\" , \"reading\" ] j . at ( \"hobbies\" ). at ( 0 ) \"hiking\" j . at ( \"hobbies\" ). at ( 1 ) \"reading\" The return value is a reference, so it can be modify the original value. Example j . at ( \"name\" ) = \"John Smith\" ; This code produces the following JSON value: { \"name\" : \"John Smith\" , \"age\" : 42 , \"hobbies\" : [ \"hiking\" , \"reading\" ] } When accessing an invalid index (i.e., and index greater than or equal to the array size) or the passed object key is non-existing, an exception is thrown. Example j . at ( \"hobbies\" ). at ( 3 ) = \"cooking\" ; This code produces the following exception: [json.exception.out_of_range.401] array index 3 is out of range","title":"Overview"},{"location":"features/element_access/checked_access/#notes","text":"Exceptions at can only be used with objects (with a string argument) or with arrays (with a numeric argument). For other types, a basic_json::type_error is thrown. basic_json::out_of_range exception exceptions are thrown if the provided key is not found in an object or the provided index is invalid.","title":"Notes"},{"location":"features/element_access/checked_access/#summary","text":"scenario non-const value const value access to existing object key reference to existing value is returned const reference to existing value is returned access to valid array index reference to existing value is returned const reference to existing value is returned access to non-existing object key basic_json::out_of_range exception is thrown basic_json::out_of_range exception is thrown access to invalid array index basic_json::out_of_range exception is thrown basic_json::out_of_range exception is thrown","title":"Summary"},{"location":"features/element_access/default_value/","text":"Access with default value: value \u00b6 Overview \u00b6 In many situations such as configuration files, missing values are not exceptional, but may be treated as if a default value was present. Example Consider the following JSON value: { \"logOutput\" : \"result.log\" , \"append\" : true } Assume the value is parsed to a json variable j . expression value j { \"logOutput\" : \"result.log\" , \"append\" : true } j . value ( \"logOutput\" , \"logfile.log\" ) \"result.log\" j . value ( \"append\" , true ) true j . value ( \"append\" , false ) true j . value ( \"logLevel\" , \"verbose\" ) \"verbose\" Note \u00b6 Exceptions value can only be used with objects. For other types, a basic_json::type_error is thrown.","title":"Access with default value: value"},{"location":"features/element_access/default_value/#access-with-default-value-value","text":"","title":"Access with default value: value"},{"location":"features/element_access/default_value/#overview","text":"In many situations such as configuration files, missing values are not exceptional, but may be treated as if a default value was present. Example Consider the following JSON value: { \"logOutput\" : \"result.log\" , \"append\" : true } Assume the value is parsed to a json variable j . expression value j { \"logOutput\" : \"result.log\" , \"append\" : true } j . value ( \"logOutput\" , \"logfile.log\" ) \"result.log\" j . value ( \"append\" , true ) true j . value ( \"append\" , false ) true j . value ( \"logLevel\" , \"verbose\" ) \"verbose\"","title":"Overview"},{"location":"features/element_access/default_value/#note","text":"Exceptions value can only be used with objects. For other types, a basic_json::type_error is thrown.","title":"Note"},{"location":"features/element_access/unchecked_access/","text":"Unchecked access: operator[] \u00b6 Overview \u00b6 Elements in a JSON object and a JSON array can be accessed via operator [] similar to a std :: map and a std :: vector , respectively. Example Consider the following JSON value: { \"name\" : \"Mary Smith\" , \"age\" : 42 , \"hobbies\" : [ \"hiking\" , \"reading\" ] } Assume the value is parsed to a json variable j . expression value j { \"name\" : \"Mary Smith\" , \"age\" : 42 , \"hobbies\" : [ \"hiking\" , \"reading\" ]} j [ \"name\" ] \"Mary Smith\" j [ \"age\" ] 42 j [ \"hobbies\" ] [ \"hiking\" , \"reading\" ] j [ \"hobbies\" ][ 0 ] \"hiking\" j [ \"hobbies\" ][ 1 ] \"reading\" The return value is a reference, so it can be modify the original value. In case the passed object key is non-existing, a null value is inserted which can be immediately be overwritten. Example j [ \"name\" ] = \"John Smith\" ; j [ \"maidenName\" ] = \"Jones\" ; This code produces the following JSON value: { \"name\" : \"John Smith\" , \"maidenName\" : \"Jones\" , \"age\" : 42 , \"hobbies\" : [ \"hiking\" , \"reading\" ] } When accessing an invalid index (i.e., and index greater than or equal to the array size), the JSON array is resized such that the passed index is the new maximal index. Intermediate values are filled with null . Example j [ \"hobbies\" ][ 0 ] = \"running\" ; j [ \"hobbies\" ][ 3 ] = \"cooking\" ; This code produces the following JSON value: { \"name\" : \"John Smith\" , \"maidenName\" : \"Jones\" , \"age\" : 42 , \"hobbies\" : [ \"running\" , \"reading\" , null , \"cooking\" ] } Notes \u00b6 Design rationale The library behaves differently to std :: vector and std :: map : std :: vector :: operator [] never inserts a new element. std :: map :: operator [] is not available for const values. The type json wraps all JSON value types. It would be impossible to remove operator[] for const objects. At the same time, inserting elements for non-const objects is really convenient as it avoids awkward insert calls. To this end, we decided to have an inserting non-const behavior for both arrays and objects. Info The access is unchecked. In case the passed object key does not exist or the passed array index is invalid, no exception is thrown. Danger It is undefined behavior to access a const object with a non-existing key. It is undefined behavior to access a const array with an invalid index. In debug mode, an assertion will fire in both cases. You can disable assertions by defining the preprocessor symbol NDEBUG or redefine the macro JSON_ASSERT(x) . Exceptions operator[] can only be used with objects (with a string argument) or with arrays (with a numeric argument). For other types, a basic_json::type_error is thrown. Summary \u00b6 scenario non-const value const value access to existing object key reference to existing value is returned const reference to existing value is returned access to valid array index reference to existing value is returned const reference to existing value is returned access to non-existing object key reference to newly inserted null value is returned undefined behavior ; assertion in debug mode access to invalid array index reference to newly inserted null value is returned; any index between previous maximal index and passed index are filled with null undefined behavior ; assertion in debug mode","title":"Unchecked access: operator[]"},{"location":"features/element_access/unchecked_access/#unchecked-access-operator","text":"","title":"Unchecked access: operator[]"},{"location":"features/element_access/unchecked_access/#overview","text":"Elements in a JSON object and a JSON array can be accessed via operator [] similar to a std :: map and a std :: vector , respectively. Example Consider the following JSON value: { \"name\" : \"Mary Smith\" , \"age\" : 42 , \"hobbies\" : [ \"hiking\" , \"reading\" ] } Assume the value is parsed to a json variable j . expression value j { \"name\" : \"Mary Smith\" , \"age\" : 42 , \"hobbies\" : [ \"hiking\" , \"reading\" ]} j [ \"name\" ] \"Mary Smith\" j [ \"age\" ] 42 j [ \"hobbies\" ] [ \"hiking\" , \"reading\" ] j [ \"hobbies\" ][ 0 ] \"hiking\" j [ \"hobbies\" ][ 1 ] \"reading\" The return value is a reference, so it can be modify the original value. In case the passed object key is non-existing, a null value is inserted which can be immediately be overwritten. Example j [ \"name\" ] = \"John Smith\" ; j [ \"maidenName\" ] = \"Jones\" ; This code produces the following JSON value: { \"name\" : \"John Smith\" , \"maidenName\" : \"Jones\" , \"age\" : 42 , \"hobbies\" : [ \"hiking\" , \"reading\" ] } When accessing an invalid index (i.e., and index greater than or equal to the array size), the JSON array is resized such that the passed index is the new maximal index. Intermediate values are filled with null . Example j [ \"hobbies\" ][ 0 ] = \"running\" ; j [ \"hobbies\" ][ 3 ] = \"cooking\" ; This code produces the following JSON value: { \"name\" : \"John Smith\" , \"maidenName\" : \"Jones\" , \"age\" : 42 , \"hobbies\" : [ \"running\" , \"reading\" , null , \"cooking\" ] }","title":"Overview"},{"location":"features/element_access/unchecked_access/#notes","text":"Design rationale The library behaves differently to std :: vector and std :: map : std :: vector :: operator [] never inserts a new element. std :: map :: operator [] is not available for const values. The type json wraps all JSON value types. It would be impossible to remove operator[] for const objects. At the same time, inserting elements for non-const objects is really convenient as it avoids awkward insert calls. To this end, we decided to have an inserting non-const behavior for both arrays and objects. Info The access is unchecked. In case the passed object key does not exist or the passed array index is invalid, no exception is thrown. Danger It is undefined behavior to access a const object with a non-existing key. It is undefined behavior to access a const array with an invalid index. In debug mode, an assertion will fire in both cases. You can disable assertions by defining the preprocessor symbol NDEBUG or redefine the macro JSON_ASSERT(x) . Exceptions operator[] can only be used with objects (with a string argument) or with arrays (with a numeric argument). For other types, a basic_json::type_error is thrown.","title":"Notes"},{"location":"features/element_access/unchecked_access/#summary","text":"scenario non-const value const value access to existing object key reference to existing value is returned const reference to existing value is returned access to valid array index reference to existing value is returned const reference to existing value is returned access to non-existing object key reference to newly inserted null value is returned undefined behavior ; assertion in debug mode access to invalid array index reference to newly inserted null value is returned; any index between previous maximal index and passed index are filled with null undefined behavior ; assertion in debug mode","title":"Summary"},{"location":"features/parsing/","text":"Overview \u00b6 Note This page is under construction. Input \u00b6 SAX vs. DOM parsing \u00b6 Exceptions \u00b6 See parsing and exceptions .","title":"Overview"},{"location":"features/parsing/#overview","text":"Note This page is under construction.","title":"Overview"},{"location":"features/parsing/#input","text":"","title":"Input"},{"location":"features/parsing/#sax-vs-dom-parsing","text":"","title":"SAX vs. DOM parsing"},{"location":"features/parsing/#exceptions","text":"See parsing and exceptions .","title":"Exceptions"},{"location":"features/parsing/parse_exceptions/","text":"Parsing and exceptions \u00b6 When the input is not valid JSON, an exception of type parse_error is thrown. This exception contains the position in the input where the error occurred, together with a diagnostic message and the last read input token. The exceptions page contains a list of examples for parse error exceptions . In case you process untrusted input, always enclose your code with a try / catch block, like json j ; try { j = json :: parse ( my_input ); } catch ( json :: exception :: parse_error & ex ) { std :: cerr << \"parse error at byte \" << ex . byte << std :: endl ; } In case exceptions are undesired or not supported by the environment, there are different ways to proceed: Switch off exceptions \u00b6 The parse() function accepts as last parameter a bool variable allow_exceptions which controls whether an exception is thrown when a parse error occurs ( true , default) or whether a discarded value should be returned ( false ). json j = json :: parse ( my_input , nullptr , false ); if ( j . is_discarded ()) { std :: cerr << \"parse error\" << std :: endl ; } Note there is no diagnostic information available in this scenario. Use accept() function \u00b6 Alternatively, function accept() can be used which does not return a json value, but a bool indicating whether the input is valid JSON. if ( ! json :: accept ( my_input )) { std :: cerr << \"parse error\" << std :: endl ; } Again, there is no diagnostic information available. User-defined SAX interface \u00b6 Finally, you can implement the SAX interface and decide what should happen in case of a parse error. This function has the following interface: bool parse_error ( std :: size_t position , const std :: string & last_token , const json :: exception & ex ); The return value indicates whether the parsing should continue, so the function should usually return false . Example #include <iostream> #include \"json.hpp\" using json = nlohmann :: json ; class sax_no_exception : public nlohmann :: detail :: json_sax_dom_parser < json > { public : sax_no_exception ( json & j ) : nlohmann :: detail :: json_sax_dom_parser < json > ( j , false ) {} bool parse_error ( std :: size_t position , const std :: string & last_token , const json :: exception & ex ) { std :: cerr << \"parse error at input byte \" << position << \" \\n \" << ex . what () << \" \\n \" << \"last read: \\\" \" << last_token << \" \\\" \" << std :: endl ; return false ; } }; int main () { std :: string myinput = \"[1,2,3,]\" ; json result ; sax_no_exception sax ( result ); bool parse_result = json :: sax_parse ( myinput , & sax ); if ( ! parse_result ) { std :: cerr << \"parsing unsuccessful!\" << std :: endl ; } std :: cout << \"parsed value: \" << result << std :: endl ; } Output: parse error at input byte 8 [json.exception.parse_error.101] parse error at line 1, column 8: syntax error while parsing value - unexpected ']'; expected '[', '{', or a literal last read: \"3,]\" parsing unsuccessful! parsed value: [1,2,3]","title":"Parsing and exceptions"},{"location":"features/parsing/parse_exceptions/#parsing-and-exceptions","text":"When the input is not valid JSON, an exception of type parse_error is thrown. This exception contains the position in the input where the error occurred, together with a diagnostic message and the last read input token. The exceptions page contains a list of examples for parse error exceptions . In case you process untrusted input, always enclose your code with a try / catch block, like json j ; try { j = json :: parse ( my_input ); } catch ( json :: exception :: parse_error & ex ) { std :: cerr << \"parse error at byte \" << ex . byte << std :: endl ; } In case exceptions are undesired or not supported by the environment, there are different ways to proceed:","title":"Parsing and exceptions"},{"location":"features/parsing/parse_exceptions/#switch-off-exceptions","text":"The parse() function accepts as last parameter a bool variable allow_exceptions which controls whether an exception is thrown when a parse error occurs ( true , default) or whether a discarded value should be returned ( false ). json j = json :: parse ( my_input , nullptr , false ); if ( j . is_discarded ()) { std :: cerr << \"parse error\" << std :: endl ; } Note there is no diagnostic information available in this scenario.","title":"Switch off exceptions"},{"location":"features/parsing/parse_exceptions/#use-accept-function","text":"Alternatively, function accept() can be used which does not return a json value, but a bool indicating whether the input is valid JSON. if ( ! json :: accept ( my_input )) { std :: cerr << \"parse error\" << std :: endl ; } Again, there is no diagnostic information available.","title":"Use accept() function"},{"location":"features/parsing/parse_exceptions/#user-defined-sax-interface","text":"Finally, you can implement the SAX interface and decide what should happen in case of a parse error. This function has the following interface: bool parse_error ( std :: size_t position , const std :: string & last_token , const json :: exception & ex ); The return value indicates whether the parsing should continue, so the function should usually return false . Example #include <iostream> #include \"json.hpp\" using json = nlohmann :: json ; class sax_no_exception : public nlohmann :: detail :: json_sax_dom_parser < json > { public : sax_no_exception ( json & j ) : nlohmann :: detail :: json_sax_dom_parser < json > ( j , false ) {} bool parse_error ( std :: size_t position , const std :: string & last_token , const json :: exception & ex ) { std :: cerr << \"parse error at input byte \" << position << \" \\n \" << ex . what () << \" \\n \" << \"last read: \\\" \" << last_token << \" \\\" \" << std :: endl ; return false ; } }; int main () { std :: string myinput = \"[1,2,3,]\" ; json result ; sax_no_exception sax ( result ); bool parse_result = json :: sax_parse ( myinput , & sax ); if ( ! parse_result ) { std :: cerr << \"parsing unsuccessful!\" << std :: endl ; } std :: cout << \"parsed value: \" << result << std :: endl ; } Output: parse error at input byte 8 [json.exception.parse_error.101] parse error at line 1, column 8: syntax error while parsing value - unexpected ']'; expected '[', '{', or a literal last read: \"3,]\" parsing unsuccessful! parsed value: [1,2,3]","title":"User-defined SAX interface"},{"location":"features/parsing/parser_callbacks/","text":"Parser Callbacks \u00b6 Overview \u00b6 With a parser callback function, the result of parsing a JSON text can be influenced. When passed to parse , it is called on certain events (passed as parse_event_t via parameter event ) with a set recursion depth depth and context JSON value parsed . The return value of the callback function is a boolean indicating whether the element that emitted the callback shall be kept or not. The type of the callback function is: template < typename BasicJsonType > using parser_callback_t = std :: function < bool ( int depth , parse_event_t event , BasicJsonType & parsed ) > ; Callback event types \u00b6 We distinguish six scenarios (determined by the event type) in which the callback function can be called. The following table describes the values of the parameters depth , event , and parsed . parameter event description parameter depth parameter parsed parse_event_t::object_start the parser read { and started to process a JSON object depth of the parent of the JSON object a JSON value with type discarded parse_event_t::key the parser read a key of a value in an object depth of the currently parsed JSON object a JSON string containing the key parse_event_t::object_end the parser read } and finished processing a JSON object depth of the parent of the JSON object the parsed JSON object parse_event_t::array_start the parser read [ and started to process a JSON array depth of the parent of the JSON array a JSON value with type discarded parse_event_t::array_end the parser read ] and finished processing a JSON array depth of the parent of the JSON array the parsed JSON array parse_event_t::value the parser finished reading a JSON value depth of the value the parsed JSON value Example When parsing the following JSON text, { \"name\" : \"Berlin\" , \"location\" : [ 52.519444 , 13.406667 ] } these calls are made to the callback function: event depth parsed object_start 0 discarded key 1 \"name\" value 1 \"Berlin\" key 1 \"location\" array_start 1 discarded value 2 52.519444 value 2 13.406667 array_end 1 [ 52.519444 , 13.406667 ] object_end 0 { \"location\" :[ 52.519444 , 13.406667 ], \"name\" : \"Berlin\" } Return value \u00b6 Discarding a value (i.e., returning false ) has different effects depending on the context in which function was called: Discarded values in structured types are skipped. That is, the parser will behave as if the discarded value was never read. In case a value outside a structured type is skipped, it is replaced with null . This case happens if the top-level element is skipped. Example The example below demonstrates the parse() function with and without callback function. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // a JSON text auto text = R \" ( { \"Image\": { \"Width\": 800, \"Height\": 600, \"Title\": \"View from 15th Floor\", \"Thumbnail\": { \"Url\": \"http://www.example.com/image/481989943\", \"Height\": 125, \"Width\": 100 }, \"Animated\" : false, \"IDs\": [116, 943, 234, 38793] } } ) \" ; // parse and serialize JSON json j_complete = json :: parse ( text ); std :: cout << std :: setw ( 4 ) << j_complete << \" \\n\\n \" ; // define parser callback json :: parser_callback_t cb = []( int depth , json :: parse_event_t event , json & parsed ) { // skip object elements with key \"Thumbnail\" if ( event == json :: parse_event_t :: key and parsed == json ( \"Thumbnail\" )) { return false ; } else { return true ; } }; // parse (with callback) and serialize JSON json j_filtered = json :: parse ( text , cb ); std :: cout << std :: setw ( 4 ) << j_filtered << '\\n' ; } Output: { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Thumbnail\" : { \"Height\" : 125 , \"Url\" : \"http://www.example.com/image/481989943\" , \"Width\" : 100 }, \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } } { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } }","title":"Parser Callbacks"},{"location":"features/parsing/parser_callbacks/#parser-callbacks","text":"","title":"Parser Callbacks"},{"location":"features/parsing/parser_callbacks/#overview","text":"With a parser callback function, the result of parsing a JSON text can be influenced. When passed to parse , it is called on certain events (passed as parse_event_t via parameter event ) with a set recursion depth depth and context JSON value parsed . The return value of the callback function is a boolean indicating whether the element that emitted the callback shall be kept or not. The type of the callback function is: template < typename BasicJsonType > using parser_callback_t = std :: function < bool ( int depth , parse_event_t event , BasicJsonType & parsed ) > ;","title":"Overview"},{"location":"features/parsing/parser_callbacks/#callback-event-types","text":"We distinguish six scenarios (determined by the event type) in which the callback function can be called. The following table describes the values of the parameters depth , event , and parsed . parameter event description parameter depth parameter parsed parse_event_t::object_start the parser read { and started to process a JSON object depth of the parent of the JSON object a JSON value with type discarded parse_event_t::key the parser read a key of a value in an object depth of the currently parsed JSON object a JSON string containing the key parse_event_t::object_end the parser read } and finished processing a JSON object depth of the parent of the JSON object the parsed JSON object parse_event_t::array_start the parser read [ and started to process a JSON array depth of the parent of the JSON array a JSON value with type discarded parse_event_t::array_end the parser read ] and finished processing a JSON array depth of the parent of the JSON array the parsed JSON array parse_event_t::value the parser finished reading a JSON value depth of the value the parsed JSON value Example When parsing the following JSON text, { \"name\" : \"Berlin\" , \"location\" : [ 52.519444 , 13.406667 ] } these calls are made to the callback function: event depth parsed object_start 0 discarded key 1 \"name\" value 1 \"Berlin\" key 1 \"location\" array_start 1 discarded value 2 52.519444 value 2 13.406667 array_end 1 [ 52.519444 , 13.406667 ] object_end 0 { \"location\" :[ 52.519444 , 13.406667 ], \"name\" : \"Berlin\" }","title":"Callback event types"},{"location":"features/parsing/parser_callbacks/#return-value","text":"Discarding a value (i.e., returning false ) has different effects depending on the context in which function was called: Discarded values in structured types are skipped. That is, the parser will behave as if the discarded value was never read. In case a value outside a structured type is skipped, it is replaced with null . This case happens if the top-level element is skipped. Example The example below demonstrates the parse() function with and without callback function. #include <iostream> #include <iomanip> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { // a JSON text auto text = R \" ( { \"Image\": { \"Width\": 800, \"Height\": 600, \"Title\": \"View from 15th Floor\", \"Thumbnail\": { \"Url\": \"http://www.example.com/image/481989943\", \"Height\": 125, \"Width\": 100 }, \"Animated\" : false, \"IDs\": [116, 943, 234, 38793] } } ) \" ; // parse and serialize JSON json j_complete = json :: parse ( text ); std :: cout << std :: setw ( 4 ) << j_complete << \" \\n\\n \" ; // define parser callback json :: parser_callback_t cb = []( int depth , json :: parse_event_t event , json & parsed ) { // skip object elements with key \"Thumbnail\" if ( event == json :: parse_event_t :: key and parsed == json ( \"Thumbnail\" )) { return false ; } else { return true ; } }; // parse (with callback) and serialize JSON json j_filtered = json :: parse ( text , cb ); std :: cout << std :: setw ( 4 ) << j_filtered << '\\n' ; } Output: { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Thumbnail\" : { \"Height\" : 125 , \"Url\" : \"http://www.example.com/image/481989943\" , \"Width\" : 100 }, \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } } { \"Image\" : { \"Animated\" : false , \"Height\" : 600 , \"IDs\" : [ 116 , 943 , 234 , 38793 ], \"Title\" : \"View from 15th Floor\" , \"Width\" : 800 } }","title":"Return value"},{"location":"features/parsing/sax_interface/","text":"SAX Interface \u00b6 The library uses a SAX-like interface with the following functions: // called when null is parsed bool null (); // called when a boolean is parsed; value is passed bool boolean ( bool val ); // called when a signed or unsigned integer number is parsed; value is passed bool number_integer ( number_integer_t val ); bool number_unsigned ( number_unsigned_t val ); // called when a floating-point number is parsed; value and original string is passed bool number_float ( number_float_t val , const string_t & s ); // called when a string is parsed; value is passed and can be safely moved away bool string ( string_t & val ); // called when a binary value is parsed; value is passed and can be safely moved away bool binary ( binary & val ); // called when an object or array begins or ends, resp. The number of elements is passed (or -1 if not known) bool start_object ( std :: size_t elements ); bool end_object (); bool start_array ( std :: size_t elements ); bool end_array (); // called when an object key is parsed; value is passed and can be safely moved away bool key ( string_t & val ); // called when a parse error occurs; byte position, the last token, and an exception is passed bool parse_error ( std :: size_t position , const std :: string & last_token , const json :: exception & ex ); The return value of each function determines whether parsing should proceed. To implement your own SAX handler, proceed as follows: Implement the SAX interface in a class. You can use class nlohmann::json_sax<json> as base class, but you can also use any class where the functions described above are implemented and public. Create an object of your SAX interface class, e.g. my_sax . Call bool json :: sax_parse ( input , & my_sax ); where the first parameter can be any input like a string or an input stream and the second parameter is a pointer to your SAX interface. Note the sax_parse function only returns a bool indicating the result of the last executed SAX event. It does not return json value - it is up to you to decide what to do with the SAX events. Furthermore, no exceptions are thrown in case of a parse error - it is up to you what to do with the exception object passed to your parse_error implementation. Internally, the SAX interface is used for the DOM parser (class json_sax_dom_parser ) as well as the acceptor ( json_sax_acceptor ), see file json_sax.hpp .","title":"SAX Interface"},{"location":"features/parsing/sax_interface/#sax-interface","text":"The library uses a SAX-like interface with the following functions: // called when null is parsed bool null (); // called when a boolean is parsed; value is passed bool boolean ( bool val ); // called when a signed or unsigned integer number is parsed; value is passed bool number_integer ( number_integer_t val ); bool number_unsigned ( number_unsigned_t val ); // called when a floating-point number is parsed; value and original string is passed bool number_float ( number_float_t val , const string_t & s ); // called when a string is parsed; value is passed and can be safely moved away bool string ( string_t & val ); // called when a binary value is parsed; value is passed and can be safely moved away bool binary ( binary & val ); // called when an object or array begins or ends, resp. The number of elements is passed (or -1 if not known) bool start_object ( std :: size_t elements ); bool end_object (); bool start_array ( std :: size_t elements ); bool end_array (); // called when an object key is parsed; value is passed and can be safely moved away bool key ( string_t & val ); // called when a parse error occurs; byte position, the last token, and an exception is passed bool parse_error ( std :: size_t position , const std :: string & last_token , const json :: exception & ex ); The return value of each function determines whether parsing should proceed. To implement your own SAX handler, proceed as follows: Implement the SAX interface in a class. You can use class nlohmann::json_sax<json> as base class, but you can also use any class where the functions described above are implemented and public. Create an object of your SAX interface class, e.g. my_sax . Call bool json :: sax_parse ( input , & my_sax ); where the first parameter can be any input like a string or an input stream and the second parameter is a pointer to your SAX interface. Note the sax_parse function only returns a bool indicating the result of the last executed SAX event. It does not return json value - it is up to you to decide what to do with the SAX events. Furthermore, no exceptions are thrown in case of a parse error - it is up to you what to do with the exception object passed to your parse_error implementation. Internally, the SAX interface is used for the DOM parser (class json_sax_dom_parser ) as well as the acceptor ( json_sax_acceptor ), see file json_sax.hpp .","title":"SAX Interface"},{"location":"home/code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at mail@nlohmann.me . The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"home/code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"home/code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"home/code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"home/code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"home/code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"home/code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at mail@nlohmann.me . The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"home/code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"home/design_goals/","text":"Design goals \u00b6 There are myriads of JSON libraries out there, and each may even have its reason to exist. Our class had these design goals: Intuitive syntax . In languages such as Python, JSON feels like a first class data type. We used all the operator magic of modern C++ to achieve the same feeling in your code. Check out the examples below and you'll know what I mean. Trivial integration . Our whole code consists of a single header file json.hpp . That's it. No library, no subproject, no dependencies, no complex build system. The class is written in vanilla C++11. All in all, everything should require no adjustment of your compiler flags or project settings. Serious testing . Our class is heavily unit-tested and covers 100% of the code, including all exceptional behavior. Furthermore, we checked with Valgrind and the Clang Sanitizers that there are no memory leaks. Google OSS-Fuzz additionally runs fuzz tests against all parsers 24/7, effectively executing billions of tests so far. To maintain high quality, the project is following the Core Infrastructure Initiative (CII) best practices . Other aspects were not so important to us: Memory efficiency . Each JSON object has an overhead of one pointer (the maximal size of a union) and one enumeration element (1 byte). The default generalization uses the following C++ data types: std::string for strings, int64_t , uint64_t or double for numbers, std::map for objects, std::vector for arrays, and bool for Booleans. However, you can template the generalized class basic_json to your needs. Speed . There are certainly faster JSON libraries out there. However, if your goal is to speed up your development by adding JSON support with a single header, then this library is the way to go. If you know how to use a std::vector or std::map , you are already set. See the contribution guidelines for more information.","title":"Design goals"},{"location":"home/design_goals/#design-goals","text":"There are myriads of JSON libraries out there, and each may even have its reason to exist. Our class had these design goals: Intuitive syntax . In languages such as Python, JSON feels like a first class data type. We used all the operator magic of modern C++ to achieve the same feeling in your code. Check out the examples below and you'll know what I mean. Trivial integration . Our whole code consists of a single header file json.hpp . That's it. No library, no subproject, no dependencies, no complex build system. The class is written in vanilla C++11. All in all, everything should require no adjustment of your compiler flags or project settings. Serious testing . Our class is heavily unit-tested and covers 100% of the code, including all exceptional behavior. Furthermore, we checked with Valgrind and the Clang Sanitizers that there are no memory leaks. Google OSS-Fuzz additionally runs fuzz tests against all parsers 24/7, effectively executing billions of tests so far. To maintain high quality, the project is following the Core Infrastructure Initiative (CII) best practices . Other aspects were not so important to us: Memory efficiency . Each JSON object has an overhead of one pointer (the maximal size of a union) and one enumeration element (1 byte). The default generalization uses the following C++ data types: std::string for strings, int64_t , uint64_t or double for numbers, std::map for objects, std::vector for arrays, and bool for Booleans. However, you can template the generalized class basic_json to your needs. Speed . There are certainly faster JSON libraries out there. However, if your goal is to speed up your development by adding JSON support with a single header, then this library is the way to go. If you know how to use a std::vector or std::map , you are already set. See the contribution guidelines for more information.","title":"Design goals"},{"location":"home/exceptions/","text":"Exceptions \u00b6 Overview \u00b6 Base type \u00b6 All exceptions inherit from class json::exception (which in turn inherits from std::exception ). It is used as the base class for all exceptions thrown by the basic_json class. This class can hence be used as \"wildcard\" to catch exceptions. Switch off exceptions \u00b6 Exceptions are used widely within the library. They can, however, be switched off with either using the compiler flag -fno-exceptions or by defining the symbol JSON_NOEXCEPTION . In this case, exceptions are replaced by abort() calls. You can further control this behavior by defining JSON_THROW_USER (overriding throw ), JSON_TRY_USER (overriding try ), and JSON_CATCH_USER (overriding catch ). Note that JSON_THROW_USER should leave the current scope (e.g., by throwing or aborting), as continuing after it may yield undefined behavior. Example The code below switches off exceptions and creates a log entry with a detailed error message in case of errors. #include <iostream> #define JSON_TRY_USER if(true) #define JSON_CATCH_USER(exception) if(false) #define JSON_THROW_USER(exception) \\ {std::clog << \"Error in \" << __FILE__ << \":\" << __LINE__ \\ << \" (function \" << __FUNCTION__ << \") - \" \\ << (exception).what() << std::endl; \\ std::abort();} #include <nlohmann/json.hpp> Parse errors \u00b6 This exception is thrown by the library when a parse error occurs. Parse errors can occur during the deserialization of JSON text, CBOR, MessagePack, as well as when using JSON Patch. Exceptions have ids 1xx. Byte index Member byte holds the byte index of the last read character in the input file. For an input with n bytes, 1 is the index of the first character and n+1 is the index of the terminating null byte or the end of file. This also holds true when reading a byte vector (CBOR or MessagePack). Example The following code shows how a parse_error exception can be caught. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { try { // parsing input with a syntax error json :: parse ( \"[1,2,3,]\" ); } catch ( json :: parse_error & e ) { // output exception information std :: cout << \"message: \" << e . what () << '\\n' << \"exception id: \" << e . id << '\\n' << \"byte position of error: \" << e . byte << std :: endl ; } } Output: message: [json.exception.parse_error.101] parse error at line 1, column 8: syntax error while parsing value - unexpected ']'; expected '[', '{', or a literal exception id: 101 byte position of error: 8 json.exception.parse_error.101 \u00b6 This error indicates a syntax error while deserializing a JSON text. The error message describes that an unexpected token (character) was encountered, and the member byte indicates the error position. Example message Input ended prematurely: [json.exception.parse_error.101] parse error at 2: unexpected end of input; expected string literal No input: [json.exception.parse_error.101] parse error at line 1, column 1: syntax error while parsing value - unexpected end of input; expected '[', '{', or a literal Control character was not escaped: [json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\\\; last read: '\"<U+0009>'\" String was not closed: [json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: missing closing quote; last read: '\"' Invalid number format: [json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid number; expected '+', '-', or digit after exponent; last read: '1E' \\u was not be followed by four hex digits: [json.exception.parse_error.101] parse error at line 1, column 6: syntax error while parsing value - invalid string: '\\u' must be followed by 4 hex digits; last read: '\"\\u01\"' Invalid UTF-8 surrogate pair: [json.exception.parse_error.101] parse error at line 1, column 13: syntax error while parsing value - invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF; last read: '\"\\uD7FF\\uDC00'\" Invalid UTF-8 byte: [json.exception.parse_error.101] parse error at line 3, column 24: syntax error while parsing value - invalid string: ill-formed UTF-8 byte; last read: '\"vous \\352t' Tip Make sure the input is correctly read. Try to write the input to standard output to check if, for instance, the input file was successfully openened. Paste the input to a JSON validator like http://jsonlint.com or a tool like jq . json.exception.parse_error.102 \u00b6 JSON uses the \\uxxxx format to describe Unicode characters. Code points above above 0xFFFF are split into two \\uxxxx entries (\"surrogate pairs\"). This error indicates that the surrogate pair is incomplete or contains an invalid code point. Example message parse error at 14: missing or wrong low surrogate json.exception.parse_error.103 \u00b6 Unicode supports code points up to 0x10FFFF. Code points above 0x10FFFF are invalid. Example message parse error: code points above 0x10FFFF are invalid json.exception.parse_error.104 \u00b6 RFC 6902 requires a JSON Patch document to be a JSON document that represents an array of objects. Example message [json.exception.parse_error.104] parse error: JSON patch must be an array of objects json.exception.parse_error.105 \u00b6 An operation of a JSON Patch document must contain exactly one \"op\" member, whose value indicates the operation to perform. Its value must be one of \"add\", \"remove\", \"replace\", \"move\", \"copy\", or \"test\"; other values are errors. Example message [json.exception.parse_error.105] parse error: operation 'add' must have member 'value' [json.exception.parse_error.105] parse error: operation 'copy' must have string member 'from' [json.exception.parse_error.105] parse error: operation value 'foo' is invalid json.exception.parse_error.106 \u00b6 An array index in a JSON Pointer ( RFC 6901 ) may be 0 or any number without a leading 0 . Example message [json.exception.parse_error.106] parse error: array index '01' must not begin with '0' json.exception.parse_error.107 \u00b6 A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a / character. Example message [json.exception.parse_error.107] parse error at byte 1: JSON pointer must be empty or begin with '/' - was: 'foo' json.exception.parse_error.108 \u00b6 In a JSON Pointer, only ~0 and ~1 are valid escape sequences. Example message [json.exception.parse_error.108] parse error: escape character '~' must be followed with '0' or '1' json.exception.parse_error.109 \u00b6 A JSON Pointer array index must be a number. Example message [json.exception.parse_error.109] parse error: array index 'one' is not a number [json.exception.parse_error.109] parse error: array index '+1' is not a number json.exception.parse_error.110 \u00b6 When parsing CBOR or MessagePack, the byte vector ends before the complete value has been read. Example message [json.exception.parse_error.110] parse error at byte 5: syntax error while parsing CBOR string: unexpected end of input [json.exception.parse_error.110] parse error at byte 2: syntax error while parsing UBJSON value: expected end of input; last byte: 0x5A json.exception.parse_error.112 \u00b6 Not all types of CBOR or MessagePack are supported. This exception occurs if an unsupported byte was read. Example message [json.exception.parse_error.112] parse error at byte 1: syntax error while parsing CBOR value: invalid byte: 0x1C json.exception.parse_error.113 \u00b6 While parsing a map key, a value that is not a string has been read. Example message [json.exception.parse_error.113] parse error at byte 2: syntax error while parsing CBOR string: expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0xFF [json.exception.parse_error.113] parse error at byte 2: syntax error while parsing MessagePack string: expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0xFF [json.exception.parse_error.113] parse error at byte 2: syntax error while parsing UBJSON char: byte after 'C' must be in range 0x00..0x7F; last byte: 0x82 json.exception.parse_error.114 \u00b6 The parsing of the corresponding BSON record type is not implemented (yet). Example message [json.exception.parse_error.114] parse error at byte 5: Unsupported BSON record type 0xFF json.exception.parse_error.115 \u00b6 A UBJSON high-precision number could not be parsed. Example message [json.exception.parse_error.115] parse error at byte 5: syntax error while parsing UBJSON high-precision number: invalid number text: 1A Iterator errors \u00b6 This exception is thrown if iterators passed to a library function do not match the expected semantics. Exceptions have ids 2xx. Example The following code shows how an invalid_iterator exception can be caught. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { try { // calling iterator::key() on non-object iterator json j = \"string\" ; json :: iterator it = j . begin (); auto k = it . key (); } catch ( json :: invalid_iterator & e ) { // output exception information std :: cout << \"message: \" << e . what () << '\\n' << \"exception id: \" << e . id << std :: endl ; } } Output: message: [json.exception.invalid_iterator.207] cannot use key() for non-object iterators exception id: 207 json.exception.invalid_iterator.201 \u00b6 The iterators passed to constructor basic_json(InputIT first, InputIT last) are not compatible, meaning they do not belong to the same container. Therefore, the range ( first , last ) is invalid. Example message [json.exception.invalid_iterator.201] iterators are not compatible json.exception.invalid_iterator.202 \u00b6 In an erase or insert function, the passed iterator pos does not belong to the JSON value for which the function was called. It hence does not define a valid position for the deletion/insertion. Example message [json.exception.invalid_iterator.202] iterator does not fit current value [json.exception.invalid_iterator.202] iterators first and last must point to objects json.exception.invalid_iterator.203 \u00b6 Either iterator passed to function erase(IteratorType first, IteratorType last ) does not belong to the JSON value from which values shall be erased. It hence does not define a valid range to delete values from. Example message [json.exception.invalid_iterator.203] iterators do not fit current value json.exception.invalid_iterator.204 \u00b6 When an iterator range for a primitive type (number, boolean, or string) is passed to a constructor or an erase function, this range has to be exactly ( begin(), end()), because this is the only way the single stored value is expressed. All other ranges are invalid. Example message [json.exception.invalid_iterator.204] iterators out of range json.exception.invalid_iterator.205 \u00b6 When an iterator for a primitive type (number, boolean, or string) is passed to an erase function, the iterator has to be the begin() iterator, because it is the only way to address the stored value. All other iterators are invalid. Example message [json.exception.invalid_iterator.205] iterator out of range json.exception.invalid_iterator.206 \u00b6 The iterators passed to constructor basic_json(InputIT first, InputIT last) belong to a JSON null value and hence to not define a valid range. Example message [json.exception.invalid_iterator.206] cannot construct with iterators from null json.exception.invalid_iterator.207 \u00b6 The key() member function can only be used on iterators belonging to a JSON object, because other types do not have a concept of a key. Example message [json.exception.invalid_iterator.207] cannot use key() for non-object iterators json.exception.invalid_iterator.208 \u00b6 The operator[] to specify a concrete offset cannot be used on iterators belonging to a JSON object, because JSON objects are unordered. Example message [json.exception.invalid_iterator.208] cannot use operator[] for object iterators json.exception.invalid_iterator.209 \u00b6 The offset operators ( + , - , += , -= ) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered. Example message [json.exception.invalid_iterator.209] cannot use offsets with object iterators json.exception.invalid_iterator.210 \u00b6 The iterator range passed to the insert function are not compatible, meaning they do not belong to the same container. Therefore, the range ( first , last ) is invalid. Example message [json.exception.invalid_iterator.210] iterators do not fit json.exception.invalid_iterator.211 \u00b6 The iterator range passed to the insert function must not be a subrange of the container to insert to. Example message [json.exception.invalid_iterator.211] passed iterators may not belong to container json.exception.invalid_iterator.212 \u00b6 When two iterators are compared, they must belong to the same container. Example message [json.exception.invalid_iterator.212] cannot compare iterators of different containers json.exception.invalid_iterator.213 \u00b6 The order of object iterators cannot be compared, because JSON objects are unordered. Example message [json.exception.invalid_iterator.213] cannot compare order of object iterators json.exception.invalid_iterator.214 \u00b6 Cannot get value for iterator: Either the iterator belongs to a null value or it is an iterator to a primitive type (number, boolean, or string), but the iterator is different to begin() . Example message [json.exception.invalid_iterator.214] cannot get value Type errors \u00b6 This exception is thrown in case of a type error; that is, a library function is executed on a JSON value whose type does not match the expected semantics. Exceptions have ids 3xx. Example The following code shows how a type_error exception can be caught. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { try { // calling push_back() on a string value json j = \"string\" ; j . push_back ( \"another string\" ); } catch ( json :: type_error & e ) { // output exception information std :: cout << \"message: \" << e . what () << '\\n' << \"exception id: \" << e . id << std :: endl ; } } Output: message: [json.exception.type_error.308] cannot use push_back() with string exception id: 308 json.exception.type_error.301 \u00b6 To create an object from an initializer list, the initializer list must consist only of a list of pairs whose first element is a string. When this constraint is violated, an array is created instead. Example message [json.exception.type_error.301] cannot create object from initializer list json.exception.type_error.302 \u00b6 During implicit or explicit value conversion, the JSON type must be compatible to the target type. For instance, a JSON string can only be converted into string types, but not into numbers or boolean types. Example message [json.exception.type_error.302] type must be object, but is null [json.exception.type_error.302] type must be string, but is object json.exception.type_error.303 \u00b6 To retrieve a reference to a value stored in a basic_json object with get_ref , the type of the reference must match the value type. For instance, for a JSON array, the ReferenceType must be array_t & . Example message [json.exception.type_error.303] incompatible ReferenceType for get_ref, actual type is object [json.exception.type_error.303] incompatible ReferenceType for get_ref, actual type is number\" json.exception.type_error.304 \u00b6 The at() member functions can only be executed for certain JSON types. Example message [json.exception.type_error.304] cannot use at() with string [json.exception.type_error.304] cannot use at() with number json.exception.type_error.305 \u00b6 The operator[] member functions can only be executed for certain JSON types. Example message [json.exception.type_error.305] cannot use operator[] with a string argument with array [json.exception.type_error.305] cannot use operator[] with a numeric argument with object json.exception.type_error.306 \u00b6 The value() member functions can only be executed for certain JSON types. Example message [json.exception.type_error.306] cannot use value() with number json.exception.type_error.307 \u00b6 The erase() member functions can only be executed for certain JSON types. Example message [json.exception.type_error.307] cannot use erase() with string json.exception.type_error.308 \u00b6 The push_back() and operator+= member functions can only be executed for certain JSON types. Example message [json.exception.type_error.308] cannot use push_back() with string json.exception.type_error.309 \u00b6 The insert() member functions can only be executed for certain JSON types. Example message [json.exception.type_error.309] cannot use insert() with array [json.exception.type_error.309] cannot use insert() with number json.exception.type_error.310 \u00b6 The swap() member functions can only be executed for certain JSON types. Example message [json.exception.type_error.310] cannot use swap() with number json.exception.type_error.311 \u00b6 The emplace() and emplace_back() member functions can only be executed for certain JSON types. Example message [json.exception.type_error.311] cannot use emplace() with number [json.exception.type_error.311] cannot use emplace_back() with number json.exception.type_error.312 \u00b6 The update() member functions can only be executed for certain JSON types. Example message [json.exception.type_error.312] cannot use update() with array json.exception.type_error.313 \u00b6 The unflatten function converts an object whose keys are JSON Pointers back into an arbitrary nested JSON value. The JSON Pointers must not overlap, because then the resulting value would not be well defined. Example message [json.exception.type_error.313] invalid value to unflatten json.exception.type_error.314 \u00b6 The unflatten function only works for an object whose keys are JSON Pointers. Example message Calling unflatten() on an array [ 1 , 2 , 3 ] : [json.exception.type_error.314] only objects can be unflattened json.exception.type_error.315 \u00b6 The unflatten() function only works for an object whose keys are JSON Pointers and whose values are primitive. Example message Calling unflatten() on an object { \"/1\" , [1,2,3] } : [json.exception.type_error.315] values in object must be primitive json.exception.type_error.316 \u00b6 The dump() function only works with UTF-8 encoded strings; that is, if you assign a std::string to a JSON value, make sure it is UTF-8 encoded. Example message Calling dump() on a JSON value containing an ISO 8859-1 encoded string: [json.exception.type_error.316] invalid UTF-8 byte at index 15: 0x6F Tip Store the source file with UTF-8 encoding. Pass an error handler as last parameter to the dump() function to avoid this exception: json::error_handler_t::replace will replace invalid bytes sequences with U+FFFD json::error_handler_t::ignore will silently ignore invalid byte sequences json.exception.type_error.317 \u00b6 The dynamic type of the object cannot be represented in the requested serialization format (e.g. a raw true or null JSON object cannot be serialized to BSON) Example message Serializing null to BSON: [json.exception.type_error.317] to serialize to BSON, top-level type must be object, but is null Serializing [ 1 , 2 , 3 ] to BSON: [json.exception.type_error.317] to serialize to BSON, top-level type must be object, but is array Tip Encapsulate the JSON value in an object. That is, instead of serializing true , serialize { \"value\" : true } Out of range \u00b6 This exception is thrown in case a library function is called on an input parameter that exceeds the expected range, for instance in case of array indices or nonexisting object keys. Exceptions have ids 4xx. Example The following code shows how an out_of_range exception can be caught. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { try { // calling at() for an invalid index json j = { 1 , 2 , 3 , 4 }; j . at ( 4 ) = 10 ; } catch ( json :: out_of_range & e ) { // output exception information std :: cout << \"message: \" << e . what () << '\\n' << \"exception id: \" << e . id << std :: endl ; } } Output: message: [json.exception.out_of_range.401] array index 4 is out of range exception id: 401 json.exception.out_of_range.401 \u00b6 The provided array index i is larger than size-1 . Example message array index 3 is out of range json.exception.out_of_range.402 \u00b6 The special array index - in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it. Example message array index '-' (3) is out of range json.exception.out_of_range.403 \u00b6 The provided key was not found in the JSON object. Example message key 'foo' not found json.exception.out_of_range.404 \u00b6 A reference token in a JSON Pointer could not be resolved. Example message unresolved reference token 'foo' json.exception.out_of_range.405 \u00b6 The JSON Patch operations 'remove' and 'add' can not be applied to the root element of the JSON value. Example message JSON pointer has no parent json.exception.out_of_range.406 \u00b6 A parsed number could not be stored as without changing it to NaN or INF. Example message number overflow parsing '10E1000' json.exception.out_of_range.407 \u00b6 UBJSON and BSON only support integer numbers up to 9223372036854775807. Example message number overflow serializing '9223372036854775808' Note Since version 3.9.0, integer numbers beyond int64 are serialized as high-precision UBJSON numbers, and this exception does not further occur. json.exception.out_of_range.408 \u00b6 The size (following # ) of an UBJSON array or object exceeds the maximal capacity. Example message excessive array size: 8658170730974374167 json.exception.out_of_range.409 \u00b6 Key identifiers to be serialized to BSON cannot contain code point U+0000, since the key is stored as zero-terminated c-string. Example message BSON key cannot contain code point U+0000 (at byte 2) Further exceptions \u00b6 This exception is thrown in case of errors that cannot be classified with the other exception types. Exceptions have ids 5xx. Example The following code shows how an other_error exception can be caught. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { try { // executing a failing JSON Patch operation json value = R \" ( { \"best_biscuit\": { \"name\": \"Oreo\" } } ) \" _json ; json patch = R \" ( [{ \"op\": \"test\", \"path\": \"/best_biscuit/name\", \"value\": \"Choco Leibniz\" }] ) \" _json ; value . patch ( patch ); } catch ( json :: other_error & e ) { // output exception information std :: cout << \"message: \" << e . what () << '\\n' << \"exception id: \" << e . id << std :: endl ; } } Output: message: [json.exception.other_error.501] unsuccessful: {\"op\":\"test\",\"path\":\"/best_biscuit/name\",\"value\":\"Choco Leibniz\"} exception id: 501 json.exception.other_error.501 \u00b6 A JSON Patch operation 'test' failed. The unsuccessful operation is also printed. Example message Executing { \"op\" : \"test\" , \"path\" : \"/baz\" , \"value\" : \"bar\" } on { \"baz\" : \"qux\" } : [json.exception.other_error.501] unsuccessful: {\"op\":\"test\",\"path\":\"/baz\",\"value\":\"bar\"}","title":"Exceptions"},{"location":"home/exceptions/#exceptions","text":"","title":"Exceptions"},{"location":"home/exceptions/#overview","text":"","title":"Overview"},{"location":"home/exceptions/#base-type","text":"All exceptions inherit from class json::exception (which in turn inherits from std::exception ). It is used as the base class for all exceptions thrown by the basic_json class. This class can hence be used as \"wildcard\" to catch exceptions.","title":"Base type"},{"location":"home/exceptions/#switch-off-exceptions","text":"Exceptions are used widely within the library. They can, however, be switched off with either using the compiler flag -fno-exceptions or by defining the symbol JSON_NOEXCEPTION . In this case, exceptions are replaced by abort() calls. You can further control this behavior by defining JSON_THROW_USER (overriding throw ), JSON_TRY_USER (overriding try ), and JSON_CATCH_USER (overriding catch ). Note that JSON_THROW_USER should leave the current scope (e.g., by throwing or aborting), as continuing after it may yield undefined behavior. Example The code below switches off exceptions and creates a log entry with a detailed error message in case of errors. #include <iostream> #define JSON_TRY_USER if(true) #define JSON_CATCH_USER(exception) if(false) #define JSON_THROW_USER(exception) \\ {std::clog << \"Error in \" << __FILE__ << \":\" << __LINE__ \\ << \" (function \" << __FUNCTION__ << \") - \" \\ << (exception).what() << std::endl; \\ std::abort();} #include <nlohmann/json.hpp>","title":"Switch off exceptions"},{"location":"home/exceptions/#parse-errors","text":"This exception is thrown by the library when a parse error occurs. Parse errors can occur during the deserialization of JSON text, CBOR, MessagePack, as well as when using JSON Patch. Exceptions have ids 1xx. Byte index Member byte holds the byte index of the last read character in the input file. For an input with n bytes, 1 is the index of the first character and n+1 is the index of the terminating null byte or the end of file. This also holds true when reading a byte vector (CBOR or MessagePack). Example The following code shows how a parse_error exception can be caught. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { try { // parsing input with a syntax error json :: parse ( \"[1,2,3,]\" ); } catch ( json :: parse_error & e ) { // output exception information std :: cout << \"message: \" << e . what () << '\\n' << \"exception id: \" << e . id << '\\n' << \"byte position of error: \" << e . byte << std :: endl ; } } Output: message: [json.exception.parse_error.101] parse error at line 1, column 8: syntax error while parsing value - unexpected ']'; expected '[', '{', or a literal exception id: 101 byte position of error: 8","title":"Parse errors"},{"location":"home/exceptions/#jsonexceptionparse_error101","text":"This error indicates a syntax error while deserializing a JSON text. The error message describes that an unexpected token (character) was encountered, and the member byte indicates the error position. Example message Input ended prematurely: [json.exception.parse_error.101] parse error at 2: unexpected end of input; expected string literal No input: [json.exception.parse_error.101] parse error at line 1, column 1: syntax error while parsing value - unexpected end of input; expected '[', '{', or a literal Control character was not escaped: [json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\\\; last read: '\"<U+0009>'\" String was not closed: [json.exception.parse_error.101] parse error at line 1, column 2: syntax error while parsing value - invalid string: missing closing quote; last read: '\"' Invalid number format: [json.exception.parse_error.101] parse error at line 1, column 3: syntax error while parsing value - invalid number; expected '+', '-', or digit after exponent; last read: '1E' \\u was not be followed by four hex digits: [json.exception.parse_error.101] parse error at line 1, column 6: syntax error while parsing value - invalid string: '\\u' must be followed by 4 hex digits; last read: '\"\\u01\"' Invalid UTF-8 surrogate pair: [json.exception.parse_error.101] parse error at line 1, column 13: syntax error while parsing value - invalid string: surrogate U+DC00..U+DFFF must follow U+D800..U+DBFF; last read: '\"\\uD7FF\\uDC00'\" Invalid UTF-8 byte: [json.exception.parse_error.101] parse error at line 3, column 24: syntax error while parsing value - invalid string: ill-formed UTF-8 byte; last read: '\"vous \\352t' Tip Make sure the input is correctly read. Try to write the input to standard output to check if, for instance, the input file was successfully openened. Paste the input to a JSON validator like http://jsonlint.com or a tool like jq .","title":"json.exception.parse_error.101"},{"location":"home/exceptions/#jsonexceptionparse_error102","text":"JSON uses the \\uxxxx format to describe Unicode characters. Code points above above 0xFFFF are split into two \\uxxxx entries (\"surrogate pairs\"). This error indicates that the surrogate pair is incomplete or contains an invalid code point. Example message parse error at 14: missing or wrong low surrogate","title":"json.exception.parse_error.102"},{"location":"home/exceptions/#jsonexceptionparse_error103","text":"Unicode supports code points up to 0x10FFFF. Code points above 0x10FFFF are invalid. Example message parse error: code points above 0x10FFFF are invalid","title":"json.exception.parse_error.103"},{"location":"home/exceptions/#jsonexceptionparse_error104","text":"RFC 6902 requires a JSON Patch document to be a JSON document that represents an array of objects. Example message [json.exception.parse_error.104] parse error: JSON patch must be an array of objects","title":"json.exception.parse_error.104"},{"location":"home/exceptions/#jsonexceptionparse_error105","text":"An operation of a JSON Patch document must contain exactly one \"op\" member, whose value indicates the operation to perform. Its value must be one of \"add\", \"remove\", \"replace\", \"move\", \"copy\", or \"test\"; other values are errors. Example message [json.exception.parse_error.105] parse error: operation 'add' must have member 'value' [json.exception.parse_error.105] parse error: operation 'copy' must have string member 'from' [json.exception.parse_error.105] parse error: operation value 'foo' is invalid","title":"json.exception.parse_error.105"},{"location":"home/exceptions/#jsonexceptionparse_error106","text":"An array index in a JSON Pointer ( RFC 6901 ) may be 0 or any number without a leading 0 . Example message [json.exception.parse_error.106] parse error: array index '01' must not begin with '0'","title":"json.exception.parse_error.106"},{"location":"home/exceptions/#jsonexceptionparse_error107","text":"A JSON Pointer must be a Unicode string containing a sequence of zero or more reference tokens, each prefixed by a / character. Example message [json.exception.parse_error.107] parse error at byte 1: JSON pointer must be empty or begin with '/' - was: 'foo'","title":"json.exception.parse_error.107"},{"location":"home/exceptions/#jsonexceptionparse_error108","text":"In a JSON Pointer, only ~0 and ~1 are valid escape sequences. Example message [json.exception.parse_error.108] parse error: escape character '~' must be followed with '0' or '1'","title":"json.exception.parse_error.108"},{"location":"home/exceptions/#jsonexceptionparse_error109","text":"A JSON Pointer array index must be a number. Example message [json.exception.parse_error.109] parse error: array index 'one' is not a number [json.exception.parse_error.109] parse error: array index '+1' is not a number","title":"json.exception.parse_error.109"},{"location":"home/exceptions/#jsonexceptionparse_error110","text":"When parsing CBOR or MessagePack, the byte vector ends before the complete value has been read. Example message [json.exception.parse_error.110] parse error at byte 5: syntax error while parsing CBOR string: unexpected end of input [json.exception.parse_error.110] parse error at byte 2: syntax error while parsing UBJSON value: expected end of input; last byte: 0x5A","title":"json.exception.parse_error.110"},{"location":"home/exceptions/#jsonexceptionparse_error112","text":"Not all types of CBOR or MessagePack are supported. This exception occurs if an unsupported byte was read. Example message [json.exception.parse_error.112] parse error at byte 1: syntax error while parsing CBOR value: invalid byte: 0x1C","title":"json.exception.parse_error.112"},{"location":"home/exceptions/#jsonexceptionparse_error113","text":"While parsing a map key, a value that is not a string has been read. Example message [json.exception.parse_error.113] parse error at byte 2: syntax error while parsing CBOR string: expected length specification (0x60-0x7B) or indefinite string type (0x7F); last byte: 0xFF [json.exception.parse_error.113] parse error at byte 2: syntax error while parsing MessagePack string: expected length specification (0xA0-0xBF, 0xD9-0xDB); last byte: 0xFF [json.exception.parse_error.113] parse error at byte 2: syntax error while parsing UBJSON char: byte after 'C' must be in range 0x00..0x7F; last byte: 0x82","title":"json.exception.parse_error.113"},{"location":"home/exceptions/#jsonexceptionparse_error114","text":"The parsing of the corresponding BSON record type is not implemented (yet). Example message [json.exception.parse_error.114] parse error at byte 5: Unsupported BSON record type 0xFF","title":"json.exception.parse_error.114"},{"location":"home/exceptions/#jsonexceptionparse_error115","text":"A UBJSON high-precision number could not be parsed. Example message [json.exception.parse_error.115] parse error at byte 5: syntax error while parsing UBJSON high-precision number: invalid number text: 1A","title":"json.exception.parse_error.115"},{"location":"home/exceptions/#iterator-errors","text":"This exception is thrown if iterators passed to a library function do not match the expected semantics. Exceptions have ids 2xx. Example The following code shows how an invalid_iterator exception can be caught. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { try { // calling iterator::key() on non-object iterator json j = \"string\" ; json :: iterator it = j . begin (); auto k = it . key (); } catch ( json :: invalid_iterator & e ) { // output exception information std :: cout << \"message: \" << e . what () << '\\n' << \"exception id: \" << e . id << std :: endl ; } } Output: message: [json.exception.invalid_iterator.207] cannot use key() for non-object iterators exception id: 207","title":"Iterator errors"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator201","text":"The iterators passed to constructor basic_json(InputIT first, InputIT last) are not compatible, meaning they do not belong to the same container. Therefore, the range ( first , last ) is invalid. Example message [json.exception.invalid_iterator.201] iterators are not compatible","title":"json.exception.invalid_iterator.201"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator202","text":"In an erase or insert function, the passed iterator pos does not belong to the JSON value for which the function was called. It hence does not define a valid position for the deletion/insertion. Example message [json.exception.invalid_iterator.202] iterator does not fit current value [json.exception.invalid_iterator.202] iterators first and last must point to objects","title":"json.exception.invalid_iterator.202"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator203","text":"Either iterator passed to function erase(IteratorType first, IteratorType last ) does not belong to the JSON value from which values shall be erased. It hence does not define a valid range to delete values from. Example message [json.exception.invalid_iterator.203] iterators do not fit current value","title":"json.exception.invalid_iterator.203"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator204","text":"When an iterator range for a primitive type (number, boolean, or string) is passed to a constructor or an erase function, this range has to be exactly ( begin(), end()), because this is the only way the single stored value is expressed. All other ranges are invalid. Example message [json.exception.invalid_iterator.204] iterators out of range","title":"json.exception.invalid_iterator.204"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator205","text":"When an iterator for a primitive type (number, boolean, or string) is passed to an erase function, the iterator has to be the begin() iterator, because it is the only way to address the stored value. All other iterators are invalid. Example message [json.exception.invalid_iterator.205] iterator out of range","title":"json.exception.invalid_iterator.205"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator206","text":"The iterators passed to constructor basic_json(InputIT first, InputIT last) belong to a JSON null value and hence to not define a valid range. Example message [json.exception.invalid_iterator.206] cannot construct with iterators from null","title":"json.exception.invalid_iterator.206"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator207","text":"The key() member function can only be used on iterators belonging to a JSON object, because other types do not have a concept of a key. Example message [json.exception.invalid_iterator.207] cannot use key() for non-object iterators","title":"json.exception.invalid_iterator.207"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator208","text":"The operator[] to specify a concrete offset cannot be used on iterators belonging to a JSON object, because JSON objects are unordered. Example message [json.exception.invalid_iterator.208] cannot use operator[] for object iterators","title":"json.exception.invalid_iterator.208"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator209","text":"The offset operators ( + , - , += , -= ) cannot be used on iterators belonging to a JSON object, because JSON objects are unordered. Example message [json.exception.invalid_iterator.209] cannot use offsets with object iterators","title":"json.exception.invalid_iterator.209"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator210","text":"The iterator range passed to the insert function are not compatible, meaning they do not belong to the same container. Therefore, the range ( first , last ) is invalid. Example message [json.exception.invalid_iterator.210] iterators do not fit","title":"json.exception.invalid_iterator.210"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator211","text":"The iterator range passed to the insert function must not be a subrange of the container to insert to. Example message [json.exception.invalid_iterator.211] passed iterators may not belong to container","title":"json.exception.invalid_iterator.211"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator212","text":"When two iterators are compared, they must belong to the same container. Example message [json.exception.invalid_iterator.212] cannot compare iterators of different containers","title":"json.exception.invalid_iterator.212"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator213","text":"The order of object iterators cannot be compared, because JSON objects are unordered. Example message [json.exception.invalid_iterator.213] cannot compare order of object iterators","title":"json.exception.invalid_iterator.213"},{"location":"home/exceptions/#jsonexceptioninvalid_iterator214","text":"Cannot get value for iterator: Either the iterator belongs to a null value or it is an iterator to a primitive type (number, boolean, or string), but the iterator is different to begin() . Example message [json.exception.invalid_iterator.214] cannot get value","title":"json.exception.invalid_iterator.214"},{"location":"home/exceptions/#type-errors","text":"This exception is thrown in case of a type error; that is, a library function is executed on a JSON value whose type does not match the expected semantics. Exceptions have ids 3xx. Example The following code shows how a type_error exception can be caught. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { try { // calling push_back() on a string value json j = \"string\" ; j . push_back ( \"another string\" ); } catch ( json :: type_error & e ) { // output exception information std :: cout << \"message: \" << e . what () << '\\n' << \"exception id: \" << e . id << std :: endl ; } } Output: message: [json.exception.type_error.308] cannot use push_back() with string exception id: 308","title":"Type errors"},{"location":"home/exceptions/#jsonexceptiontype_error301","text":"To create an object from an initializer list, the initializer list must consist only of a list of pairs whose first element is a string. When this constraint is violated, an array is created instead. Example message [json.exception.type_error.301] cannot create object from initializer list","title":"json.exception.type_error.301"},{"location":"home/exceptions/#jsonexceptiontype_error302","text":"During implicit or explicit value conversion, the JSON type must be compatible to the target type. For instance, a JSON string can only be converted into string types, but not into numbers or boolean types. Example message [json.exception.type_error.302] type must be object, but is null [json.exception.type_error.302] type must be string, but is object","title":"json.exception.type_error.302"},{"location":"home/exceptions/#jsonexceptiontype_error303","text":"To retrieve a reference to a value stored in a basic_json object with get_ref , the type of the reference must match the value type. For instance, for a JSON array, the ReferenceType must be array_t & . Example message [json.exception.type_error.303] incompatible ReferenceType for get_ref, actual type is object [json.exception.type_error.303] incompatible ReferenceType for get_ref, actual type is number\"","title":"json.exception.type_error.303"},{"location":"home/exceptions/#jsonexceptiontype_error304","text":"The at() member functions can only be executed for certain JSON types. Example message [json.exception.type_error.304] cannot use at() with string [json.exception.type_error.304] cannot use at() with number","title":"json.exception.type_error.304"},{"location":"home/exceptions/#jsonexceptiontype_error305","text":"The operator[] member functions can only be executed for certain JSON types. Example message [json.exception.type_error.305] cannot use operator[] with a string argument with array [json.exception.type_error.305] cannot use operator[] with a numeric argument with object","title":"json.exception.type_error.305"},{"location":"home/exceptions/#jsonexceptiontype_error306","text":"The value() member functions can only be executed for certain JSON types. Example message [json.exception.type_error.306] cannot use value() with number","title":"json.exception.type_error.306"},{"location":"home/exceptions/#jsonexceptiontype_error307","text":"The erase() member functions can only be executed for certain JSON types. Example message [json.exception.type_error.307] cannot use erase() with string","title":"json.exception.type_error.307"},{"location":"home/exceptions/#jsonexceptiontype_error308","text":"The push_back() and operator+= member functions can only be executed for certain JSON types. Example message [json.exception.type_error.308] cannot use push_back() with string","title":"json.exception.type_error.308"},{"location":"home/exceptions/#jsonexceptiontype_error309","text":"The insert() member functions can only be executed for certain JSON types. Example message [json.exception.type_error.309] cannot use insert() with array [json.exception.type_error.309] cannot use insert() with number","title":"json.exception.type_error.309"},{"location":"home/exceptions/#jsonexceptiontype_error310","text":"The swap() member functions can only be executed for certain JSON types. Example message [json.exception.type_error.310] cannot use swap() with number","title":"json.exception.type_error.310"},{"location":"home/exceptions/#jsonexceptiontype_error311","text":"The emplace() and emplace_back() member functions can only be executed for certain JSON types. Example message [json.exception.type_error.311] cannot use emplace() with number [json.exception.type_error.311] cannot use emplace_back() with number","title":"json.exception.type_error.311"},{"location":"home/exceptions/#jsonexceptiontype_error312","text":"The update() member functions can only be executed for certain JSON types. Example message [json.exception.type_error.312] cannot use update() with array","title":"json.exception.type_error.312"},{"location":"home/exceptions/#jsonexceptiontype_error313","text":"The unflatten function converts an object whose keys are JSON Pointers back into an arbitrary nested JSON value. The JSON Pointers must not overlap, because then the resulting value would not be well defined. Example message [json.exception.type_error.313] invalid value to unflatten","title":"json.exception.type_error.313"},{"location":"home/exceptions/#jsonexceptiontype_error314","text":"The unflatten function only works for an object whose keys are JSON Pointers. Example message Calling unflatten() on an array [ 1 , 2 , 3 ] : [json.exception.type_error.314] only objects can be unflattened","title":"json.exception.type_error.314"},{"location":"home/exceptions/#jsonexceptiontype_error315","text":"The unflatten() function only works for an object whose keys are JSON Pointers and whose values are primitive. Example message Calling unflatten() on an object { \"/1\" , [1,2,3] } : [json.exception.type_error.315] values in object must be primitive","title":"json.exception.type_error.315"},{"location":"home/exceptions/#jsonexceptiontype_error316","text":"The dump() function only works with UTF-8 encoded strings; that is, if you assign a std::string to a JSON value, make sure it is UTF-8 encoded. Example message Calling dump() on a JSON value containing an ISO 8859-1 encoded string: [json.exception.type_error.316] invalid UTF-8 byte at index 15: 0x6F Tip Store the source file with UTF-8 encoding. Pass an error handler as last parameter to the dump() function to avoid this exception: json::error_handler_t::replace will replace invalid bytes sequences with U+FFFD json::error_handler_t::ignore will silently ignore invalid byte sequences","title":"json.exception.type_error.316"},{"location":"home/exceptions/#jsonexceptiontype_error317","text":"The dynamic type of the object cannot be represented in the requested serialization format (e.g. a raw true or null JSON object cannot be serialized to BSON) Example message Serializing null to BSON: [json.exception.type_error.317] to serialize to BSON, top-level type must be object, but is null Serializing [ 1 , 2 , 3 ] to BSON: [json.exception.type_error.317] to serialize to BSON, top-level type must be object, but is array Tip Encapsulate the JSON value in an object. That is, instead of serializing true , serialize { \"value\" : true }","title":"json.exception.type_error.317"},{"location":"home/exceptions/#out-of-range","text":"This exception is thrown in case a library function is called on an input parameter that exceeds the expected range, for instance in case of array indices or nonexisting object keys. Exceptions have ids 4xx. Example The following code shows how an out_of_range exception can be caught. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { try { // calling at() for an invalid index json j = { 1 , 2 , 3 , 4 }; j . at ( 4 ) = 10 ; } catch ( json :: out_of_range & e ) { // output exception information std :: cout << \"message: \" << e . what () << '\\n' << \"exception id: \" << e . id << std :: endl ; } } Output: message: [json.exception.out_of_range.401] array index 4 is out of range exception id: 401","title":"Out of range"},{"location":"home/exceptions/#jsonexceptionout_of_range401","text":"The provided array index i is larger than size-1 . Example message array index 3 is out of range","title":"json.exception.out_of_range.401"},{"location":"home/exceptions/#jsonexceptionout_of_range402","text":"The special array index - in a JSON Pointer never describes a valid element of the array, but the index past the end. That is, it can only be used to add elements at this position, but not to read it. Example message array index '-' (3) is out of range","title":"json.exception.out_of_range.402"},{"location":"home/exceptions/#jsonexceptionout_of_range403","text":"The provided key was not found in the JSON object. Example message key 'foo' not found","title":"json.exception.out_of_range.403"},{"location":"home/exceptions/#jsonexceptionout_of_range404","text":"A reference token in a JSON Pointer could not be resolved. Example message unresolved reference token 'foo'","title":"json.exception.out_of_range.404"},{"location":"home/exceptions/#jsonexceptionout_of_range405","text":"The JSON Patch operations 'remove' and 'add' can not be applied to the root element of the JSON value. Example message JSON pointer has no parent","title":"json.exception.out_of_range.405"},{"location":"home/exceptions/#jsonexceptionout_of_range406","text":"A parsed number could not be stored as without changing it to NaN or INF. Example message number overflow parsing '10E1000'","title":"json.exception.out_of_range.406"},{"location":"home/exceptions/#jsonexceptionout_of_range407","text":"UBJSON and BSON only support integer numbers up to 9223372036854775807. Example message number overflow serializing '9223372036854775808' Note Since version 3.9.0, integer numbers beyond int64 are serialized as high-precision UBJSON numbers, and this exception does not further occur.","title":"json.exception.out_of_range.407"},{"location":"home/exceptions/#jsonexceptionout_of_range408","text":"The size (following # ) of an UBJSON array or object exceeds the maximal capacity. Example message excessive array size: 8658170730974374167","title":"json.exception.out_of_range.408"},{"location":"home/exceptions/#jsonexceptionout_of_range409","text":"Key identifiers to be serialized to BSON cannot contain code point U+0000, since the key is stored as zero-terminated c-string. Example message BSON key cannot contain code point U+0000 (at byte 2)","title":"json.exception.out_of_range.409"},{"location":"home/exceptions/#further-exceptions","text":"This exception is thrown in case of errors that cannot be classified with the other exception types. Exceptions have ids 5xx. Example The following code shows how an other_error exception can be caught. #include <iostream> #include <nlohmann/json.hpp> using json = nlohmann :: json ; int main () { try { // executing a failing JSON Patch operation json value = R \" ( { \"best_biscuit\": { \"name\": \"Oreo\" } } ) \" _json ; json patch = R \" ( [{ \"op\": \"test\", \"path\": \"/best_biscuit/name\", \"value\": \"Choco Leibniz\" }] ) \" _json ; value . patch ( patch ); } catch ( json :: other_error & e ) { // output exception information std :: cout << \"message: \" << e . what () << '\\n' << \"exception id: \" << e . id << std :: endl ; } } Output: message: [json.exception.other_error.501] unsuccessful: {\"op\":\"test\",\"path\":\"/best_biscuit/name\",\"value\":\"Choco Leibniz\"} exception id: 501","title":"Further exceptions"},{"location":"home/exceptions/#jsonexceptionother_error501","text":"A JSON Patch operation 'test' failed. The unsuccessful operation is also printed. Example message Executing { \"op\" : \"test\" , \"path\" : \"/baz\" , \"value\" : \"bar\" } on { \"baz\" : \"qux\" } : [json.exception.other_error.501] unsuccessful: {\"op\":\"test\",\"path\":\"/baz\",\"value\":\"bar\"}","title":"json.exception.other_error.501"},{"location":"home/faq/","text":"Frequently Asked Questions (FAQ) \u00b6 Limitations \u00b6 Relaxed parsing \u00b6 Question Can you add an option to ignore trailing commas? For the same reason this library does not support comments , this library also does not support any feature which would jeopardize interoperability. Parse errors reading non-ASCII characters \u00b6 Questions Why is the parser complaining about a Chinese character? Does the library support Unicode? I get an exception [json.exception.parse_error.101] parse error at line 1, column 53: syntax error while parsing value - invalid string: ill-formed UTF-8 byte; last read: '\"Test\u00e9$')\" The library supports Unicode input as follows: Only UTF-8 encoded input is supported which is the default encoding for JSON according to RFC 8259 . std::u16string and std::u32string can be parsed, assuming UTF-16 and UTF-32 encoding, respectively. These encodings are not supported when reading from files or other input containers. Other encodings such as Latin-1 or ISO 8859-1 are not supported and will yield parse or serialization errors. Unicode noncharacters will not be replaced by the library. Invalid surrogates (e.g., incomplete pairs such as \\uDEAD ) will yield parse errors. The strings stored in the library are UTF-8 encoded. When using the default string type ( std::string ), note that its length/size functions return the number of stored bytes rather than the number of characters or glyphs. When you store strings with different encodings in the library, calling dump() may throw an exception unless json::error_handler_t::replace or json::error_handler_t::ignore are used as error handlers. In most cases, the parser is right to complain, because the input is not UTF-8 encoded. This is especially true for Microsoft Windows where Latin-1 or ISO 8859-1 is often the standard encoding. Key name in exceptions \u00b6 Question Can I get the key of the object item that caused an exception? No, this is not possible. See https://github.com/nlohmann/json/issues/932 for a longer discussion. Serialization issues \u00b6 Number precision \u00b6 Question It seems that precision is lost when serializing a double. Can I change the precision for floating-point serialization? The library uses std::numeric_limits<number_float_t>::digits10 (15 for IEEE double s) digits for serialization. This value is sufficient to guarantee roundtripping. If one uses more than this number of digits of precision, then string -> value -> string is not guaranteed to round-trip. cppreference.com The value of std::numeric_limits<T>::digits10 is the number of base-10 digits that can be represented by the type T without change, that is, any number with this many significant decimal digits can be converted to a value of type T and back to decimal form, without change due to rounding or overflow. Tip The website https://float.exposed gives a good insight into the internal storage of floating-point numbers. Compilation issues \u00b6 Android SDK \u00b6 Question Why does the code not compile with Android SDK? Android defaults to using very old compilers and C++ libraries. To fix this, add the following to your Application.mk . This will switch to the LLVM C++ library, the Clang compiler, and enable C++11 and other features disabled by default. APP_STL : = c++_shared NDK_TOOLCHAIN_VERSION : = clang3.6 APP_CPPFLAGS + = -frtti -fexceptions The code compiles successfully with Android NDK , Revision 9 - 11 (and possibly later) and CrystaX's Android NDK version 10. Missing STL function \u00b6 Questions Why do I get a compilation error 'to_string' is not a member of 'std' (or similarly, for strtod or strtof )? Why does the code not compile with MinGW or Android SDK? This is not an issue with the code, but rather with the compiler itself. On Android, see above to build with a newer environment. For MinGW, please refer to this site and this discussion for information on how to fix this bug. For Android NDK using APP_STL := gnustl_static , please refer to this discussion .","title":"FAQ"},{"location":"home/faq/#frequently-asked-questions-faq","text":"","title":"Frequently Asked Questions (FAQ)"},{"location":"home/faq/#limitations","text":"","title":"Limitations"},{"location":"home/faq/#relaxed-parsing","text":"Question Can you add an option to ignore trailing commas? For the same reason this library does not support comments , this library also does not support any feature which would jeopardize interoperability.","title":"Relaxed parsing"},{"location":"home/faq/#parse-errors-reading-non-ascii-characters","text":"Questions Why is the parser complaining about a Chinese character? Does the library support Unicode? I get an exception [json.exception.parse_error.101] parse error at line 1, column 53: syntax error while parsing value - invalid string: ill-formed UTF-8 byte; last read: '\"Test\u00e9$')\" The library supports Unicode input as follows: Only UTF-8 encoded input is supported which is the default encoding for JSON according to RFC 8259 . std::u16string and std::u32string can be parsed, assuming UTF-16 and UTF-32 encoding, respectively. These encodings are not supported when reading from files or other input containers. Other encodings such as Latin-1 or ISO 8859-1 are not supported and will yield parse or serialization errors. Unicode noncharacters will not be replaced by the library. Invalid surrogates (e.g., incomplete pairs such as \\uDEAD ) will yield parse errors. The strings stored in the library are UTF-8 encoded. When using the default string type ( std::string ), note that its length/size functions return the number of stored bytes rather than the number of characters or glyphs. When you store strings with different encodings in the library, calling dump() may throw an exception unless json::error_handler_t::replace or json::error_handler_t::ignore are used as error handlers. In most cases, the parser is right to complain, because the input is not UTF-8 encoded. This is especially true for Microsoft Windows where Latin-1 or ISO 8859-1 is often the standard encoding.","title":"Parse errors reading non-ASCII characters"},{"location":"home/faq/#key-name-in-exceptions","text":"Question Can I get the key of the object item that caused an exception? No, this is not possible. See https://github.com/nlohmann/json/issues/932 for a longer discussion.","title":"Key name in exceptions"},{"location":"home/faq/#serialization-issues","text":"","title":"Serialization issues"},{"location":"home/faq/#number-precision","text":"Question It seems that precision is lost when serializing a double. Can I change the precision for floating-point serialization? The library uses std::numeric_limits<number_float_t>::digits10 (15 for IEEE double s) digits for serialization. This value is sufficient to guarantee roundtripping. If one uses more than this number of digits of precision, then string -> value -> string is not guaranteed to round-trip. cppreference.com The value of std::numeric_limits<T>::digits10 is the number of base-10 digits that can be represented by the type T without change, that is, any number with this many significant decimal digits can be converted to a value of type T and back to decimal form, without change due to rounding or overflow. Tip The website https://float.exposed gives a good insight into the internal storage of floating-point numbers.","title":"Number precision"},{"location":"home/faq/#compilation-issues","text":"","title":"Compilation issues"},{"location":"home/faq/#android-sdk","text":"Question Why does the code not compile with Android SDK? Android defaults to using very old compilers and C++ libraries. To fix this, add the following to your Application.mk . This will switch to the LLVM C++ library, the Clang compiler, and enable C++11 and other features disabled by default. APP_STL : = c++_shared NDK_TOOLCHAIN_VERSION : = clang3.6 APP_CPPFLAGS + = -frtti -fexceptions The code compiles successfully with Android NDK , Revision 9 - 11 (and possibly later) and CrystaX's Android NDK version 10.","title":"Android SDK"},{"location":"home/faq/#missing-stl-function","text":"Questions Why do I get a compilation error 'to_string' is not a member of 'std' (or similarly, for strtod or strtof )? Why does the code not compile with MinGW or Android SDK? This is not an issue with the code, but rather with the compiler itself. On Android, see above to build with a newer environment. For MinGW, please refer to this site and this discussion for information on how to fix this bug. For Android NDK using APP_STL := gnustl_static , please refer to this discussion .","title":"Missing STL function"},{"location":"home/license/","text":"License \u00b6 The class is licensed under the MIT License : Copyright \u00a9 2013-2020 Niels Lohmann Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. The class contains the UTF-8 Decoder from Bjoern Hoehrmann which is licensed under the MIT License (see above). Copyright \u00a9 2008-2009 Bj\u00f6rn Hoehrmann bjoern@hoehrmann.de The class contains a slightly modified version of the Grisu2 algorithm from Florian Loitsch which is licensed under the MIT License (see above). Copyright \u00a9 2009 Florian Loitsch The class contains a copy of Hedley from Evan Nemerson which is licensed as CC0-1.0 .","title":"License"},{"location":"home/license/#license","text":"The class is licensed under the MIT License : Copyright \u00a9 2013-2020 Niels Lohmann Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \u201cSoftware\u201d), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \u201cAS IS\u201d, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. The class contains the UTF-8 Decoder from Bjoern Hoehrmann which is licensed under the MIT License (see above). Copyright \u00a9 2008-2009 Bj\u00f6rn Hoehrmann bjoern@hoehrmann.de The class contains a slightly modified version of the Grisu2 algorithm from Florian Loitsch which is licensed under the MIT License (see above). Copyright \u00a9 2009 Florian Loitsch The class contains a copy of Hedley from Evan Nemerson which is licensed as CC0-1.0 .","title":"License"},{"location":"home/releases/","text":"Releases \u00b6 v3.7.3 \u00b6 Files include.zip (274 KB) include.zip.asc (1 KB) json.hpp (791 KB) json.hpp.asc (1 KB) Release date: 2019-11-17 SHA-256: 3b5d2b8f8282b80557091514d8ab97e27f9574336c804ee666fda673a9b59926 (json.hpp), 87b5884741427220d3a33df1363ae0e8b898099fbc59f1c451113f6732891014 (include.zip) Summary \u00b6 This release fixes a bug introduced in release 3.7.2 which could yield quadratic complexity in destructor calls. All changes are backward-compatible. Bug Fixes \u00b6 Removed reserve() calls from the destructor which could lead to quadratic complexity. #1837 #1838 Deprecated functions \u00b6 This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead. v3.7.2 \u00b6 Files include.zip (274 KB) include.zip.asc (1 KB) json.hpp (791 KB) json.hpp.asc (1 KB) Release date: 2019-11-10 SHA-256: 0a65fcbbe1b334d3f45c9498e5ee28c3f3b2428aea98557da4a3ff12f0f14ad6 (json.hpp), 67f69c9a93b7fa0612dc1b6273119d2c560317333581845f358aaa68bff8f087 (include.zip) Summary \u00b6 Project bad_json_parsers tested how JSON parser libraries react on deeply nested inputs . It turns out that this library segfaulted at a certain nesting depth. This bug was fixed with this release. Now the parsing is only bounded by the available memory. All changes are backward-compatible. Bug Fixes \u00b6 Fixed a bug that lead to stack overflow for deeply nested JSON values (objects, array) by changing the implementation of the destructor from a recursive to an iterative approach. #832, #1419, #1835 Further Changes \u00b6 Added WhiteStone Bolt. #1830 Deprecated functions \u00b6 This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead. v3.7.1 \u00b6 Files include.zip (273 KB) include.zip.asc (1 KB) json.hpp (789 KB) json.hpp.asc (1 KB) Release date: 2019-11-06 SHA-256: b5ba7228f3c22a882d379e93d08eab4349458ee16fbf45291347994eac7dc7ce (json.hpp), 77b9f54b34e7989e6f402afb516f7ff2830df551c3a36973085e2c7a6b1045fe (include.zip) Summary \u00b6 This release fixes several small bugs in the library. All changes are backward-compatible. Bug Fixes \u00b6 Fixed a segmentation fault when serializing std::int64_t minimum value. #1708 #1722 Fixed the contains() function for JSON Pointers. #1727 #1741 Fixed too lax SFINAE guard for conversion from std::pair and std::tuple to json . #1805 #1806 #1825 #1826 Fixed some regressions detected by UBSAN. Updated CI to use Clang-Tidy 7.1.0. #1716 #1728 Fixed integer truncation in iteration_proxy . #1797 Updated Hedley to v11 to fix a E2512 error in MSVC. #1799 Fixed a compile error in enum deserialization of non non-default-constructible types. #1647 #1821 Fixed the conversion from json to std::valarray . Improvements \u00b6 The items() function can now be used with a custom string type. #1765 Made json_pointer::back const . #1764 #1769 Meson is part of the release archive. #1672 #1694 Improved documentation on the Meson and Spack package manager. #1694 #1720 Further Changes \u00b6 Added GitHub Workflow with ubuntu-latest /GCC 7.4.0 as CI step. Added GCC 9 to Travis CI to compile with C++20 support. #1724 Added MSVC 2019 to the AppVeyor CI. #1780 Added badge to fuzzing status . Fixed some cppcheck warnings. #1760 Fixed several typos in the documentation. #1720 #1767 #1803 Added documentation on the JSON_THROW_USER , JSON_TRY_USER , and JSON_CATCH_USER macros to control user-defined exception handling. Used GitHub's CODEOWNERS and SECURITY feature. Removed GLOB from CMake files. #1779 Updated to Doctest 2.3.5. Deprecated functions \u00b6 This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead. v3.7.0 \u00b6 Files include.zip (143 KB) include.zip.asc (1 KB) json.hpp (782 KB) json.hpp.asc (1 KB) Release date: 2019-07-28 SHA-256: a503214947952b69f0062f572cb74c17582a495767446347ce2e452963fc2ca4 (json.hpp), 541c34438fd54182e9cdc68dd20c898d766713ad6d901fb2c6e28ff1f1e7c10d (include.zip) Summary \u00b6 This release introduces a few convenience functions and performs a lot of house keeping (bug fixes and small improvements). All changes are backward-compatible. New Features \u00b6 Add overload of the contains function to check if a JSON pointer is valid without throwing exceptions, just like its counterpart for object keys . #1600 Add a function to_string to allow for generic conversion to strings. #916 #1585 Add return value for the emplace_back function , returning a reference to the added element just like C++17 is introducing this for std::vector . #1609 Add info how to use the library with the pacman package manager on MSYS2. #1670 Bug Fixes \u00b6 Fix an issue where typedefs with certain names yielded a compilation error. #1642 #1643 Fix a conversion to std::string_view in the unit tests. #1634 #1639 Fix MSVC Debug build. #1536 #1570 #1608 Fix get_to method to clear existing content before writing. #1511 #1555 Fix a -Wc++17-extensions warning. nodiscard attributes are now only used with Clang when -std=c++17 is used. #1535 #1551 Improvements \u00b6 Switch from Catch to doctest for the unit tests which speeds up compilation and runtime of the 112,112,308 tests. Add an explicit section to the README about the frequently addressed topics character encoding , comments in JSON , and the order of object keys . Further Changes \u00b6 Use GNUInstallDirs to set library install directories. #1673 Fix links in the README . #1620 #1621 #1622 #1623 #1625 Mention json type on the documentation start page . #1616 Complete documentation of value() function with respect to type_error.302 exception. #1601 Fix links in the documentation. #1598 Add regression tests for MSVC. #1543 #1570 Use CircleCI for continuous integration . Use Doozer for continuous integration on Linux (CentOS, Raspbian, Fedora) Add tests to check each CMake flag ( JSON_BuildTests , JSON_Install , JSON_MultipleHeaders , JSON_Sanitizer , JSON_Valgrind , JSON_NoExceptions , JSON_Coverage ). Use Hedley to avoid re-inventing several compiler-agnostic feature macros like JSON_DEPRECATED , JSON_NODISCARD , JSON_LIKELY , JSON_UNLIKELY , JSON_HAS_CPP_14 , or JSON_HAS_CPP_17 . Functions taking or returning pointers are annotated accordingly when a pointer will not be null. Build and run tests on AppVeyor in DEBUG and RELEASE mode. Deprecated functions \u00b6 This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead. v3.6.1 \u00b6 Files include.zip (136 KB) include.zip.asc (1 KB) json.hpp (711 KB) json.hpp.asc (1 KB) Release date: 2019-03-20 SHA-256: d2eeb25d2e95bffeb08ebb7704cdffd2e8fca7113eba9a0b38d60a5c391ea09a (json.hpp), 69cc88207ce91347ea530b227ff0776db82dcb8de6704e1a3d74f4841bc651cf (include.zip) Summary \u00b6 This release fixes a regression and a bug introduced by the earlier 3.6.0 release. All changes are backward-compatible. Bug Fixes \u00b6 Fixed regression of #590 which could lead to compilation errors with GCC 7 and GCC 8. #1530 Fixed a compilation error when <Windows.h> was included. #1531 Further Changes \u00b6 Fixed a warning for missing field initializers. #1527 Deprecated functions \u00b6 This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead. v3.6.0 \u00b6 Files include.zip (136 KB) include.zip.asc (1 KB) json.hpp (711 KB) json.hpp.asc (1 KB) Release date: 2019-03-20 SHA-256: ce9839370f28094c71107c405affb3b08c4a098154988014cbb0800b1c44a831 (json.hpp), 237c5e66e7f8186a02804ce9dbd5f69ce89fe7424ef84adf6142e973bd9532f4 (include.zip) \u2139\ufe0f This release introduced a regression. Please update to version 3.6.1 ! Summary \u00b6 This release adds some convenience functions for JSON Pointers , introduces a contains function to check if a key is present in an object, and improves the performance of integer serialization . Furthermore, a lot of small bug fixes and improvements have been made. All changes are backward-compatible. New Features \u00b6 Overworked the public interface for JSON Pointers. The creation of JSON Pointers is simplified with operator/ and operator/= . JSON Pointers can be inspected with empty , back , and parent_pointer , and manipulated with push_back and pop_back . #1434 Added a boolean method contains to check whether an element exists in a JSON object with a given key. Returns false when called on non-object types. #1471 #1474 Bug Fixes \u00b6 Fixed a compilation issues with libc 2.12. #1483 #1514 Fixed endian conversion on PPC64. #1489 Fixed library to compile with GCC 9. #1472 #1492 Fixed a compilation issue with GCC 7 on CentOS. #1496 Fixed an integer overflow. #1447 Fixed buffer flushing in serializer. #1445 #1446 Improvements \u00b6 The performance of dumping integers has been greatly improved. #1411 Added CMake parameter JSON_Install to control whether the library should be installed (default: on). #1330 Fixed a lot of compiler and linter warnings. #1400 #1435 #1502 Reduced required CMake version from 3.8 to 3.1. #1409 #1428 #1441 #1498 Added nodiscard attribute to meta() , array() , object() , from_cbor , from_msgpack , from_ubjson , from_bson , and parse . #1433 Further Changes \u00b6 Added missing headers. #1500 Fixed typos and broken links in README. #1417 #1423 #1425 #1451 #1455 #1491 Fixed documentation of parse function. #1473 Suppressed warning that cannot be fixed inside the library. #1401 #1468 Imroved package manager suppert: Updated Buckaroo instructions. #1495 Improved Meson support. #1463 Added Conda package manager documentation. #1430 Added NuGet package manager documentation. #1132 Continuous Integration Removed unstable or deprecated Travis builders (Xcode 6.4 - 8.2) and added Xcode 10.1 builder. Added Clang 7 to Travis CI. Fixed AppVeyor x64 builds. #1374 #1414 Updated thirdparty libraries: Catch 1.12.0 -> 1.12.2 Google Benchmark 1.3.0 -> 1.4.1 Doxygen 1.8.15 -> 1.8.16 Deprecated functions \u00b6 This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead. v3.5.0 \u00b6 Files include.zip (133 KB) include.zip.asc (1 KB) json.hpp (693 KB) json.hpp.asc (1 KB) Release date: 2018-12-22 SHA-256: 8a6dbf3bf01156f438d0ca7e78c2971bca50eec4ca6f0cf59adf3464c43bb9d5 (json.hpp), 3564da9c5b0cf2e032f97c69baedf10ddbc98030c337d0327a215ea72259ea21 (include.zip) Summary \u00b6 This release introduces the support for structured bindings and reading from FILE* . Besides, a few bugs have been fixed. All changes are backward-compatible. New Features \u00b6 Structured bindings are now supported for JSON objects and arrays via the items() member function, so finally this code is possible: for ( auto & [ key , val ] : j . items ()) { std :: cout << key << ':' << val << '\\n' ; } #1388 #1391 Added support for reading from FILE* to support situations in which streams are nit available or would require too much RAM. #1370 #1392 Bug Fixes \u00b6 The eofbit was not set for input streams when the end of a stream was reached while parsing. #1340 #1343 Fixed a bug in the SAX parser for BSON arrays. Improvements \u00b6 Added support for Clang 5.0.1 (PS4 version). #1341 #1342 Further Changes \u00b6 Added a warning for implicit conversions to the documentation: It is not recommended to use implicit conversions when reading from a JSON value. Details about this recommendation can be found here . #1363 Fixed typos in the documentation. #1329 #1380 #1382 Fixed a C4800 warning. #1364 Fixed a -Wshadow warning #1346 Wrapped std::snprintf calls to avoid error in MSVC. #1337 Added code to allow installation via Meson. #1345 Deprecated functions \u00b6 This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead. v3.4.0 \u00b6 Files include.zip (132 KB) include.zip.asc (1 KB) json.hpp (689 KB) json.hpp.asc (1 KB) Release date: 2018-10-30 SHA-256: 63da6d1f22b2a7bb9e4ff7d6b255cf691a161ff49532dcc45d398a53e295835f (json.hpp), bfec46fc0cee01c509cf064d2254517e7fa80d1e7647fea37cf81d97c5682bdc (include.zip) Summary \u00b6 This release introduces three new features: BSON (Binary JSON) is next to CBOR, MessagePack, and UBJSON the fourth binary (de)serialization format supported by the library. Adjustable error handlers for invalid Unicode allows to specify the behavior when invalid byte sequences are serialized. Simplified enum/JSON mapping with a macro in case the default mapping to integers is not desired. Furthermore, some effort has been invested in improving the parse error messages . Besides, a few bugs have been fixed. All changes are backward-compatible. New Features \u00b6 The library can read and write a subset of BSON (Binary JSON) . All data types known from JSON are supported, whereas other types more tied to MongoDB such as timestamps, object ids, or binary data are currently not implemented. See the README for examples. #1244 #1320 The behavior when the library encounters an invalid Unicode sequence during serialization can now be controlled by defining one of three Unicode error handlers : (1) throw an exception (default behavior), (2) replace invalid sequences by the Unicode replacement character (U+FFFD), or (3) ignore/filter invalid sequences. See the documentation of the dump function for examples. #1198 #1314 To easily specify a user-defined enum/JSON mapping , a macro NLOHMANN_JSON_SERIALIZE_ENUM has been introduced. See the README section for more information. #1208 #1323 Bug Fixes \u00b6 fixed truncation #1286 #1315 fixed an issue with std::pair #1299 #1301 fixed an issue with std::variant #1292 #1294 fixed a bug in the JSON Pointer parser Improvements \u00b6 The diagnosis messages for parse errors have been improved: error messages now indicated line/column positions where possible (in addition to a byte count) and also the context in which the error occurred (e.g., \"while parsing a JSON string\"). Example: error parse error at 2: syntax error - invalid string: control character must be escaped; last read: '<U+0009>' is now reported as parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t; last read: '<U+0009>' . #1280 #1288 #1303 Further Changes \u00b6 improved Meson documentation #1305 fixed some more linter warnings #1280 fixed Clang detection for third-party Google Benchmark library #1277 Deprecated functions \u00b6 This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead. v3.3.0 \u00b6 Files include.zip (123 KB) include.zip.asc (1 KB) json.hpp (635 KB) json.hpp.asc (1 KB) Release date: 2018-10-05 SHA-256: f1327bb60c58757a3dd2b0c9c45d49503d571337681d950ec621f8374bcc14d4 (json.hpp), 9588d63557333aaa485e92221ec38014a85a6134e7486fe3441e0541a5a89576 (include.zip) Summary \u00b6 This release adds support for GCC 4.8 . Furthermore, it adds a function get_to to write a JSON value to a passed reference. Another topic of this release was the CMake support which has been overworked and documented. Besides, a lot of bugs have been fixed and slight improvements have been made. All changes are backward-compatible. New Features \u00b6 The library can now also built with GCC 4.8 . Though this compiler does not fully support C++11, it can successfully compile and run the test suite. Note that bug 57824 in GCC 4.8 still forbids to use multiline raw strings in arguments to macros. #1257 Added new function get_to to write a JSON value to a passed reference. The destination type is automatically derived which allows more succinct code compared to the get function. #1227 #1231 Bug Fixes \u00b6 Fixed a bug in the CMake file that made target_link_libraries to not properly include nlohmann_json . #1243 #1245 #1260 Fixed a warning in MSVC 2017 complaining about a constexpr if. #1204 #1268 #1272 Fixed a bug that prevented compilation with ICPC. #755 #1222 Improved the SFINAE correctness to fix a bug in the conversion operator. #1237 #1238 Fixed a -Wctor-dtor-privacy warning. #1224 Fixed a warning on a lambda in unevaluated context. #1225 #1230 Fixed a bug introduced in version 3.2.0 where defining JSON_CATCH_USER led to duplicate macro definition of JSON_INTERNAL_CATCH . #1213 #1214 Fixed a bug that prevented compilation with Clang 3.4.2 in RHEL 7. #1179 #1249 Improvements \u00b6 Added documentation on CMake integration of the library. #1270 Changed the CMake file to use find_package(nlohmann_json) without installing the library. #1202 Improved error messages in case operator[] is used with the wrong combination (json.exception.type_error.305) of JSON container type and argument type. Example: \"cannot use operator[] with a string argument\". #1220 #1221 Added a license and version information to the Meson build file. #1252 Removed static assertions to indicated missing to_json or from_json functions as such assertions do not play well with SFINAE. These assertions also led to problems with GMock. #960 #1212 #1228 The test suite now does not wait forever if run in a wrong directory and input files are not found. #1262 The test suite does not show deprecation warnings for deprecated functions which frequently led to confusion. #1271 Further Changes \u00b6 GCC 4.8 and Xcode 10 were added to the continuous integration suite at Travis. Added lgtm checks to pull requests. Added tests for CMake integration. #1260 Deprecated functions \u00b6 This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead. v3.2.0 \u00b6 Files include.zip (124 KB) include.zip.asc (1 KB) json.hpp (636 KB) json.hpp.asc (1 KB) Release date: 2018-08-20 SHA-256: ce6b5610a051ec6795fa11c33854abebb086f0fd67c311f5921c3c07f9531b44 (json.hpp), 35ee642558b90e2f9bc758995c4788c4b4d4dec54eef95fb8f38cb4d49c8fc7c (include.zip) Summary \u00b6 This release introduces a SAX interface to the library. While this may be a very special feature used by only few people, it allowed to unify all functions that consumed input and created some kind of JSON value. Internally, now all existing functions like parse , accept , from_cbor , from_msgpack , and from_ubjson use the SAX interface with different event processors. This allowed to separate the input processing from the value generation. Furthermore, throwing an exception in case of a parse error is now optional and up to the event processor. Finally, the JSON parser is now non-recursive (meaning it does not use the call stack, but std::vector<bool> to track the hierarchy of structured values) which allows to process nested input more efficiently. Furthermore, the library finally is able to parse from wide string types . This is the first step toward opening the library from UTF-8 to UTF-16 and UTF-32. This release further fixes several bugs in the library. All changes are backward-compatible. New Features \u00b6 added a parser with a SAX interface (#971, #1153) support to parse from wide string types std::wstring , std::u16string , and std::u32string ; the input will be converted to UTF-8 (#1031) added support for std::string_view when using C++17 (#1028) allow to roundtrip std::map and std::unordered_map from JSON if key type is not convertible to string; in these cases, values are serialized to arrays of pairs (#1079, #1089, #1133, #1138) Bug Fixes \u00b6 allow to create nullptr_t from JSON allowing to properly roundtrip null values (#1169) allow compare user-defined string types (#1130) better support for algorithms using iterators from items() (#1045, #1134) added parameter to avoid compilation error with MSVC 2015 debug builds (#1114) re-added accidentially skipped unit tests (#1176) fixed MSVC issue with std::swap (#1168) Improvements \u00b6 key() function for iterators returns a const reference rather than a string copy (#1098) binary formats CBOR, MessagePack, and UBJSON now supports float as type for floating-point numbers (#1021) Further Changes \u00b6 changed issue templates improved continuous integration: added builders for Xcode 9.3 and 9.4, added builders for GCC 8 and Clang 6, added builder for MinGW, added builders for MSVC targeting x86 required CMake version is now at least 3.8 (#1040) overworked CMake file wrt. packaging (#1048) added package managers: Spack (#1041) and CocoaPods (#1148) fixed Meson include directory (#1142) preprocessor macro JSON_SKIP_UNSUPPORTED_COMPILER_CHECK can skip the rejection of unsupported compilers - use at your own risk! (#1128) preprocessor macro JSON_INTERNAL_CATCH / JSON_INTERNAL_CATCH_USER allows to control the behavior of exception handling inside the library (#1187) added note on char to JSON conversion added note how to send security-related issue via encrypted email removed dependency to std::stringstream (#1117) added SPDX-License-Identifier added updated JSON Parsing Test Suite, described in Parsing JSON is a Minefield \ud83d\udca3 updated to Catch 1.12.0 Deprecated functions \u00b6 This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead. v3.1.2 \u00b6 Files include.zip (115 KB) include.zip.asc (1 KB) json.hpp (582 KB) json.hpp.asc (1 KB) Release date: 2018-03-14 SHA-256: fbdfec4b4cf63b3b565d09f87e6c3c183bdd45c5be1864d3fcb338f6f02c1733 (json.hpp), 495362ee1b9d03d9526ba9ccf1b4a9c37691abe3a642ddbced13e5778c16660c (include.zip) Summary \u00b6 This release fixes several bugs in the library. All changes are backward-compatible. Bug Fixes \u00b6 Fixed a memory leak occurring in the parser callback (#1001). Different specializations of basic_json (e.g., using different template arguments for strings or objects) can now be used in assignments (#972, #977, #986). Fixed a logical error in an iterator range check (#992). Improvements \u00b6 The parser and the serialization now support user-defined string types (#1006, #1009). Further Changes \u00b6 Clang Analyzer is now used as additional static analyzer; see make clang_analyze . Overworked README by adding links to the documentation (#981). Deprecated functions \u00b6 This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead. v3.1.1 \u00b6 Files include.zip (114 KB) include.zip.asc (1 KB) json.hpp (577 KB) json.hpp.asc (1 KB) Release date: 2018-02-13 SHA-256: e14ce5e33d6a2daf748026bd4947f3d9686ca4cfd53d10c3da46a0a9aceb7f2e (json.hpp), fde771d4b9e4f222965c00758a2bdd627d04fb7b59e09b7f3d1965abdc848505 (include.zip) Summary \u00b6 This release fixes several bugs in the library. All changes are backward-compatible. Bug Fixes \u00b6 Fixed parsing of CBOR strings with indefinite length (#961). Earlier versions of this library misinterpreted the CBOR standard and rejected input with the 0x7F start byte. Fixed user-defined conversion to vector type (#924, #969). A wrong SFINAE check rejected code though a user-defined conversion was provided. Fixed documentation of the parser behavior for objects with duplicate keys (#963). The exact behavior is not specified by RFC 8259 and the library now also provides no guarantee which object key is stored. Added check to detect memory overflow when parsing UBJSON containers (#962). The optimized UBJSON format allowed for specifying an array with billions of null elements with a few bytes and the library did not check whether this size exceeded max_size() . Further Changes \u00b6 Code coverage is now calculated for the individual header files, allowing to find uncovered lines more quickly than by browsing through the single header version (#953, #957). A Makefile target run_benchmarks was added to quickly build and run the benchmark suite. The documentation was harmonized with respect to the header inclusion (#955). Now all examples and the README use #include <nlohmann/json.hpp> to allow for selecting single_include or include or whatever installation folder as include directory. Added note on how to use the library with the cget package manager (#954). Deprecated functions \u00b6 This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead. v3.1.0 \u00b6 Files include.zip (114 KB) include.zip.asc (1 KB) json.hpp (577 KB) json.hpp.asc (1 KB) Release date: 2018-02-01 SHA-256: d40f614d10a6e4e4e80dca9463da905285f20e93116c36d97d4dc1aa63d10ba4 (json.hpp), 2b7234fca394d1e27b7e017117ed80b7518fafbb4f4c13a7c069624f6f924673 (include.zip) Summary \u00b6 This release adds support for the UBJSON format and JSON Merge Patch . It also contains some minor changes and bug fixes. All changes are backward-compatible. New features \u00b6 The library now supports UBJSON (Universal Binary JSON Specification) as binary format to read and write JSON values space-efficiently. See the documentation overview for a comparison of the different formats CBOR, MessagePack, and UBJSON. JSON Merge Patch (RFC 7386) offers an intuitive means to describe patches between JSON values (#876, #877). See the documentation of merge_patch for more information. Improvements \u00b6 The library now uses the Grisu2 algorithm for printing floating-point numbers (based on the reference implementation by Florian Loitsch) which produces a short representation which is guaranteed to round-trip (#360, #935, #936). The UTF-8 handling was further simplified by using the decoder of Bj\u00f6rn Hoehrmann in more scenarios. Reorganization \u00b6 Though the library is released as a single header, its development got more and more complicated. With this release, the header is split into several files and the single-header file json.hpp can be generated from these development sources. In the repository, folder include contains the development sources and single_include contains the single json.hpp header (#700, #906, #907, #910, #911, #915, #920, #924, #925, #928, #944). The split further allowed for a forward declaration header include/nlohmann/json_fwd.hpp to speed up compilation times (#314). Further changes \u00b6 Google Benchmark is now used for micro benchmarks (see benchmarks folder, #921). The serialization (JSON and binary formats) now properly work with the libraries string template parameter, allowing for optimized string implementations to be used in constraint environments such as embedded software (#941, #950). The exceptional behavior can now be overridden by defining macros JSON_THROW_USER , JSON_TRY_USER , and JSON_CATCH_USER , defining the behavior of throw , try and catch , respectively. This allows to switch off C++'s exception mechanism yet still execute user-defined code in case an error condition occurs (#938). To facilitate the interplay with flex and Bison , the library does not use the variable name yytext any more as it could clash with macro definitions (#933). The library now defines NLOHMANN_JSON_VERSION_MAJOR , NLOHMANN_JSON_VERSION_MINOR , and NLOHMANN_JSON_VERSION_PATCH to allow for conditional compilation based on the included library version (#943, #948). A compilation error with ICC has been fixed (#947). Typos and links in the documentation have been fixed (#900, #930). A compiler error related to incomplete types has been fixed (#919). The tests form the UTF-8 decoder stress test have been added to the test suite. Deprecated functions \u00b6 Function iterator_wrapper has been deprecated (#874). Since its introduction, the name was up for discussion, as it was too technical. We now introduced the member function items() with the same semantics. iterator_wrapper will be removed in the next major version (i.e., 4.0.0). Furthermore, the following functions are deprecated since version 3.0.0 and will be removed in the next major version (i.e., 4.0.0): friend std::istream& operator<<(basic_json&, std::istream&) friend std::ostream& operator>>(const basic_json&, std::ostream&) Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead. v3.0.1 \u00b6 Files json.hpp (502 KB) json.hpp.asc (1 KB) Release date: 2017-12-29 SHA-256: c9b3591f1bb94e723a0cd7be861733a3a555b234ef132be1e9027a0364118c4c Summary \u00b6 This release fixes small issues in the implementation of JSON Pointer and JSON Patch . All changes are backward-compatible. Changes \u00b6 The \"copy\" operation of JSON Patch ( RFC 6902 ) requests that it is an error if the target path points into a non-existing array or object (see #894 for a detailed description). This release fixes the implementation to detect such invalid target paths and throw an exception. An array index in a JSON Pointer ( RFC 6901 ) must be an integer. This release fixes the implementation to throw an exception in case invalid array indices such as 10e2 are used. Added the JSON Patch tests from Byron Ruth and Mike McCabe. Fixed the documentation of the at(ptr) function with JSON Pointers to list all possible exceptions (see #888). Updated the container overview documentation (see #883). The CMake files now respect the BUILD_TESTING option (see #846, #885) Fixed some compiler warnings (see #858, #882). Deprecated functions \u00b6 To unify the interfaces and to improve similarity with the STL, the following functions are deprecated since version 3.0.0 and will be removed in the next major version (i.e., 4.0.0): friend std::istream& operator<<(basic_json&, std::istream&) friend std::ostream& operator>>(const basic_json&, std::ostream&) Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead. v3.0.0 \u00b6 Files json.hpp (501 KB) json.hpp.asc (1 KB) Release date: 2017-12-17 SHA-256: 076d4a0cb890a3c3d389c68421a11c3d77c64bd788e85d50f1b77ed252f2a462 Summary \u00b6 After almost a year, here is finally a new release of JSON for Modern C++, and it is a major one! As we adhere to semantic versioning , this means the release includes some breaking changes, so please read the next section carefully before you update. But don't worry, we also added a few new features and put a lot of effort into fixing a lot of bugs and straighten out a few inconsistencies. Breaking changes \u00b6 This section describes changes that change the public API of the library and may require changes in code using a previous version of the library. In section \"Moving from 2.x.x to 3.0.0\" at the end of the release notes, we describe in detail how existing code needs to be changed. The library now uses user-defined exceptions instead of re-using those defined in <stdexcept> (#244). This not only allows to add more information to the exceptions (every exception now has an identifier, and parse errors contain the position of the error), but also to easily catch all library exceptions with a single catch(json::exception) . When strings with a different encoding as UTF-8 were stored in JSON values, their serialization could not be parsed by the library itself, as only UTF-8 is supported. To enforce this library limitation and improve consistency, non-UTF-8 encoded strings now yield a json::type_error exception during serialization (#838). The check for valid UTF-8 is realized with code from Bj\u00f6rn Hoehrmann . NaN and infinity values can now be stored inside the JSON value without throwing an exception. They are, however, still serialized as null (#388). The library's iterator tag was changed from RandomAccessIterator to BidirectionalIterator (#593). Supporting RandomAccessIterator was incorrect as it assumed an ordering of values in a JSON objects which are unordered by definition. The library does not include the standard headers <iostream> , <ctype> , and <stdexcept> any more. You may need to add these headers to code relying on them. Removed constructor explicit basic_json(std::istream& i, const parser_callback_t cb = nullptr) which was deprecated in version 2.0.0 (#480). Deprecated functions \u00b6 To unify the interfaces and to improve similarity with the STL, the following functions are now deprecated and will be removed in the next major version (i.e., 4.0.0): friend std::istream& operator<<(basic_json&, std::istream&) friend std::ostream& operator>>(const basic_json&, std::ostream&) Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead. New features \u00b6 With all this breaking and deprecation out of the way, let's talk about features! We improved the diagnostic information for syntax errors (#301). Now, an exception json::parse_error is thrown which contains a detailed message on the error, but also a member byte to indicate the byte offset in the input where the error occurred. We added a non-throwing syntax check (#458): The new accept function returns a Boolean indicating whether the input is proper JSON. We also added a Boolean parameter allow_exceptions to the existing parse functions to return a discarded value in case a syntax error occurs instead of throwing an exception. An update function was added to merge two JSON objects (#428). In case you are wondering: the name was inspired by Python . The insert function now also supports an iterator range to add elements to an object. The binary exchange formats CBOR and MessagePack can now be parsed from input streams and written to output streams (#477). Input streams are now only read until the end of a JSON value instead of the end of the input (#367). The serialization function dump now has two optional parameters ensure_ascii to escape all non-ASCII characters with \\uxxxx and an indent_char parameter to choose whether to indent with spaces or tabs (#654). Added built-in type support for C arrays (#502), std::pair and std::tuple (#563, #614), enum and enum class (#545), std::vector<bool> (#494). Fixed support for std::valarray (#702), std::array (#553), and std::map<std::string, std::string> (#600, #607). Further changes \u00b6 Furthermore, there have been a lot of changes under the hood: Replaced the re2c generated scanner by a self-coded version which allows for a better modularization of the parser and better diagnostics. To test the new scanner, we added millions (8,860,608 to be exact) of unit tests to check all valid and invalid byte sequences of the Unicode standard. Google's OSS-Fuzz is still constantly fuzz-testing the library and found several issues that were fixed in this release (#497, #504, #514, #516, #518, #519, #575). We now also ignore UTF-8 byte order marks when parsing from an iterator range (#602). Values can be now moved from initializer lists (#663). Updated to Catch 1.9.7. Unfortunately, Catch2 currently has some performance issues. The non-exceptional paths of the library are now annotated with __builtin_expect to optimize branch prediction as long as no error occurs. MSVC now produces a stack trace in MSVC if a from_json or to_json function was not found for a user-defined type. We also added a debug visualizer nlohmann_json.natvis for better debugging in MSVC (#844). Overworked the documentation and added even more examples. The build workflow now relies on CMake and CTest. Special flags can be chosen with CMake, including coverage ( JSON_Coverage ), compilation without exceptions ( JSON_NoExceptions ), LLVM sanitizers ( JSON_Sanitizer ), or execution with Valgrind ( JSON_Valgrind ). Added support for package managers Meson (#576), Conan (#566), Hunter (#671, #829), and vcpkg (#753). Added CI builders: Xcode 8.3, 9.0, 9.1, and 9.2; GCC 7.2; Clang 3.8, 3.9, 4.0, and 5.0; Visual Studio 2017. The library is further built with C++17 settings on the latest Clang, GCC, and MSVC version to quickly detect new issues. Moving from 2.x.x to 3.0.0 \u00b6 User-defined Exceptions \u00b6 There are five different exceptions inheriting from json::exception : json::parse_error for syntax errors (including the binary formats), json::invalid_iterator for errors related to iterators, json::type_error for errors where functions were called with the wrong JSON type, json::out_of_range for range errors, and json::other_error for miscellaneous errors. To support these exception, the try / catch blocks of your code need to be adjusted: new exception previous exception parse_error.101 invalid_argument parse_error.102 invalid_argument parse_error.103 invalid_argument parse_error.104 invalid_argument parse_error.105 invalid_argument parse_error.106 domain_error parse_error.107 domain_error parse_error.108 domain_error parse_error.109 invalid_argument parse_error.110 out_of_range parse_error.111 invalid_argument parse_error.112 invalid_argument invalid_iterator.201 domain_error invalid_iterator.202 domain_error invalid_iterator.203 domain_error invalid_iterator.204 out_of_range invalid_iterator.205 out_of_range invalid_iterator.206 domain_error invalid_iterator.207 domain_error invalid_iterator.208 domain_error invalid_iterator.209 domain_error invalid_iterator.210 domain_error invalid_iterator.211 domain_error invalid_iterator.212 domain_error invalid_iterator.213 domain_error invalid_iterator.214 out_of_range type_error.301 domain_error type_error.302 domain_error type_error.303 domain_error type_error.304 domain_error type_error.305 domain_error type_error.306 domain_error type_error.307 domain_error type_error.308 domain_error type_error.309 domain_error type_error.310 domain_error type_error.311 domain_error type_error.313 domain_error type_error.314 domain_error type_error.315 domain_error out_of_range.401 out_of_range out_of_range.402 out_of_range out_of_range.403 out_of_range out_of_range.404 out_of_range out_of_range.405 domain_error other_error.501 domain_error Handling of NaN and INF \u00b6 If an overflow occurs during parsing a number from a JSON text, an exception json::out_of_range is thrown so that the overflow is detected early and roundtripping is guaranteed. NaN and INF floating-point values can be stored in a JSON value and are not replaced by null. That is, the basic_json class behaves like double in this regard (no exception occurs). However, NaN and INF are serialized to null . Removal of deprecated functions \u00b6 Function explicit basic_json(std::istream& i, const parser_callback_t cb = nullptr) should be replaced by the parse function: Let ss be a stream and cb be a parse callback function. Old code: json j ( ss , cb ); New code: json j = json :: parse ( ss , cb ); If no callback function is used, also the following code works: json j ; j << ss ; or json j ; ss >> j ; v2.1.1 \u00b6 Files json.hpp (437 KB) json.hpp.asc (1 KB) Release date: 2017-02-25 SHA-256: faa2321beb1aa7416d035e7417fcfa59692ac3d8c202728f9bcc302e2d558f57 Summary \u00b6 This release fixes a locale-related bug in the parser . To do so, the whole number handling (lexer, parser, and also the serialization) have been overworked. Furthermore, a lot of small changes added up that were added to this release. All changes are backward-compatible. Changes \u00b6 Locales that have a different character than . as decimal separator (e.g., the Norwegian locale nb_NO.UTF-8 ) led to truncated number parsing or parse errors. The library now has been fixed to work with any locale . Note that . is still the only valid decimal separator for JSON input. Numbers like 1.0 were correctly parsed as floating-point number, but serialized as integer ( 1 ). Now, floating-point numbers correctly round trip . Parsing incorrect JSON numbers with leading 0 ( 0123 ) could yield a buffer overflow . This is fixed now by detecting such errors directly by the lexer. Constructing a JSON value from a pointer was incorrectly interpreted as a Boolean; such code will now yield a compiler error. Comparing a JSON number with 0 led to a comparison with null . This is fixed now. All throw calls are now wrapped in macros. Starting during the preparation of this release (since 8 February 2017), commits and released files are cryptographically signed with this GPG key . Previous releases have also been signed. The parser for MessagePack and CBOR now supports an optional start index parameter to define a byte offset for the parser. Some more warnings have been fixed. With Clang, the code compiles without warnings with -Weverything (well, it needs -Wno-documentation-unknown-command and -Wno-deprecated-declarations , but you get the point). The code can be compiled easier with many Android NDKs by avoiding macros like UINT8_MAX which previously required defining a preprocessor macro for compilation. The unit tests now compile two times faster. Cotire is used to speed up the build. Fixed a lot of typos in the documentation. Added a section to the README file that lists all used third-party code/tools . Added a note on constructing a string value vs. parsing. The test suite now contains 11202597 unit tests. Improved the Doxygen documentation by shortening the template parameters of class basic_json . Removed Doozer. Added Codacity. Upgraded Catch to version 1.7.2. v2.1.0 \u00b6 Files json.hpp (426 KB) json.hpp.asc (1 KB) Release date: 2017-01-28 SHA-256: a571dee92515b685784fd527e38405cf3f5e13e96edbfe3f03d6df2e363a767b Summary \u00b6 This release introduces a means to convert from/to user-defined types. The release is backwards compatible. Changes \u00b6 The library now offers an elegant way to convert from and to arbitrary value types . All you need to do is to implement two functions: to_json and from_json . Then, a conversion is as simple as putting a = between variables. See the README for more information and examples. Exceptions can now be switched off. This can be done by defining the preprocessor symbol JSON_NOEXCEPTION or by passing -fno-exceptions to your compiler. In case the code would usually thrown an exception, abort() is now called. Information on the library can be queried with the new (static) function meta() which returns a JSON object with information on the version, compiler, and platform. See the documentation for an example. A bug in the CBOR parser was fixed which led to a buffer overflow. The function type_name() is now public. It allows to query the type of a JSON value as string. Added the Big List of Naughty Strings as test case. Updated to Catch v1.6.0 . Some typos in the documentation have been fixed. v2.0.10 \u00b6 Files json.hpp (409 KB) json.hpp.asc (1 KB) Release date: 2017-01-02 SHA-256: ec27d4e74e9ce0f78066389a70724afd07f10761009322dc020656704ad5296d Summary \u00b6 This release fixes several security-relevant bugs in the MessagePack and CBOR parsers. The fixes are backwards compatible. Changes \u00b6 Fixed a lot of bugs in the CBOR and MesssagePack parsers . These bugs occurred if invalid input was parsed and then could lead in buffer overflows. These bugs were found with Google's OSS-Fuzz , see #405, #407, #408, #409, #411, and #412 for more information. We now also use the Doozer continuous integration platform . The complete test suite is now also run with Clang's address sanitizer and undefined-behavior sanitizer . Overworked fuzz testing ; CBOR and MessagePack implementations are now fuzz-tested. Furthermore, all fuzz tests now include a round trip which ensures created output can again be properly parsed and yields the same JSON value. Clarified documentation of find() function to always return end() when called on non-object value types. Moved thirdparty test code to test/thirdparty directory. v2.0.9 \u00b6 Files json.hpp (406 KB) json.hpp.asc (1 KB) Release date: 2016-12-16 SHA-256: fbf3396f13e187d6c214c297bddc742d918ea9b55e10bfb3d9f458b9bfdc22e5 Summary \u00b6 This release implements with CBOR and MessagePack two binary serialization/deserialization formats . It further contains some small fixes and improvements. The fixes are backwards compatible. Changes \u00b6 The library can now read and write the binary formats CBOR (Concise Binary Object Representation) and MessagePack . Both formats are aimed to produce a very compact representation of JSON which can be parsed very efficiently. See the README file for more information and examples. simplified the iteration implementation allowing to remove dozens of lines of code fixed an integer overflow error detected by Google's OSS-Fuzz suppressed documentation warnings inside the library to facilitate compilation with -Wdocumentation fixed an overflow detection error in the number parser updated contribution guidelines to a list of frequentely asked features that will most likely be never added to the library added a table of contents to the README file to add some structure mentioned the many examples and the documentation in the README file split unit tests into individual independent binaries to speed up compilation and testing the test suite now contains 11201886 tests v2.0.8 \u00b6 Files json.hpp (360 KB) json.hpp.asc (1 KB) Release date: 2016-12-02 SHA-256: b70db0ad34f8e0e61dc3f0cbab88099336c9674c193d8a3439d93d6aca2d7120 Summary \u00b6 This release combines a lot of small fixes and improvements. The fixes are backwards compatible. Changes \u00b6 fixed a bug that froze the parser if a passed file was not found (now, std::invalid_argument is thrown) fixed a bug that lead to an error of a file at EOF was parsed again (now, std::invalid_argument is thrown) the well known functions emplace and emplace_back have been added to JSON values and work as expected improved the performance of the serialization ( dump function) improved the performance of the deserialization (parser) some continuous integration images at Travis were added and retired; see here for the current continuous integration setup the Coverity scan works again the benchmarking code has been improved to produce more stable results the README file has been extended and includes more frequently asked examples the test suite now contains 8905518 tests updated Catch to version 1.5.8 v2.0.7 \u00b6 Files json.hpp (355 KB) json.hpp.asc (1 KB) Release date: 2016-11-02 SHA-256: 5545c323670f8165bae90b9dc6078825e86ec310d96cc4e5b47233ea43715bbf Summary \u00b6 This release fixes a few bugs in the JSON parser found in the Parsing JSON is a Minefield \ud83d\udca3 article. The fixes are backwards compatible. Changes \u00b6 The article Parsing JSON is a Minefield \ud83d\udca3 discusses a lot of pitfalls of the JSON specification. When investigating the published test cases, a few bugs in the library were found and fixed: Files with less than 5 bytes can now be parsed without error. The library now properly rejects any file encoding other than UTF-8. Furthermore, incorrect surrogate pairs are properly detected and rejected. The library now accepts all but one \"yes\" test (y_string_utf16.json): UTF-16 is not supported. The library rejects all but one \"no\" test (n_number_then_00.json): Null bytes are treated as end of file instead of an error. This allows to parse input from null-terminated strings. The string length passed to a user-defined string literal is now exploited to choose a more efficient constructor. A few grammar mistakes in the README file have been fixed. v2.0.6 \u00b6 Files json.hpp (349 KB) json.hpp.asc (1 KB) Release date: 2016-10-15 SHA256: 459cc93d5e2f503e50c6d5876eb86bfea7daf405f5a567c5a2c9abc2383756ae Summary \u00b6 This release fixes the semantics of operator[] for JSON Pointers (see below). This fix is backwards compatible. Changes \u00b6 operator[] for JSON Pointers now behaves like the other versions of operator[] and transforms null values into objects or arrays if required. This allows to created nested structues like j[\"/foo/bar/2\"] = 17 (yielding {\"foo\": \"bar\": [null, null, 17]} ) without problems. overworked a helper SFINAE function fixed some documentation issues fixed the CMake files to allow to run the test suite outside the main project directory restored test coverage to 100%. v2.0.5 \u00b6 Files json.hpp (347 KB) json.hpp.asc (1 KB) Release date: 2016-09-14 SHA-256: 8b7565263a44e2b7d3b89808bc73d2d639037ff0c1f379e3d56dbd77e00b98d9 Summary \u00b6 This release fixes a regression bug in the stream parser (function parse() and the << / >> operators). This fix is backwards compatible. Changes \u00b6 Bug fix : The end of a file stream was not detected properly which led to parse errors. This bug should have been fixed with 2.0.4, but there was still a flaw in the code. v2.0.4 \u00b6 Files json.hpp (347 KB) json.hpp.asc (1 KB) Release date: 2016-09-11 SHA-256: 632ceec4c25c4e2153f71470d3a2b992c8355f6d8b4d627d05dd16095cd3aeda Summary \u00b6 This release fixes a bug in the stream parser (function parse() and the << / >> operators). This fix is backwards compatible. Changes \u00b6 Bug fix : The end of a file stream was not detected properly which led to parse errors. Fixed a compiler warning about an unused variable. v2.0.3 \u00b6 Files json.hpp (347 KB) json.hpp.asc (1 KB) Release date: 2016-08-31 SHA-256: 535b73efe5546fde9e763c14aeadfc7b58183c0b3cd43c29741025aba6cf6bd3 Summary \u00b6 This release combines a lot of small fixes and improvements. The release is backwards compatible. Changes \u00b6 The parser/deserialization functions have been generalized to process any contiguous sequence of 1-byte elements (e.g., char , unsigned char , uint8_t ). This includes all kind of string representations (string literals, char arrays, std::string , const char* ), contiguous containers (C-style arrays, std::vector , std::array , std::valarray , std::initializer_list ). User-defined containers providing random-access iterator access via std::begin and std::end can be used as well. See the documentation ( 1 , 2 , 3 , 4 ) for more information. Note that contiguous storage cannot be checked at compile time; if any of the parse functions are called with a noncompliant container, the behavior is undefined and will most likely yield segmentation violation. The preconditions are enforced by an assertion unless the library is compiled with preprocessor symbol NDEBUG . As a general remark on assertions : The library uses assertions to preclude undefined behavior. A prominent example for this is the operator[] for const JSON objects. The behavior of this const version of the operator is undefined if the given key does not exist in the JSON object, because unlike the non-const version, it cannot add a null value at the given key. Assertions can be switched of by defining the preprocessor symbol NDEBUG . See the documentation of assert for more information. In the course of cleaning up the parser/deserialization functions, the constructor basic_json(std::istream&, const parser_callback_t) has been deprecated and will be deleted with the next major release 3.0.0 to unify the interface of the library. Deserialization will be done by stream operators or by calling one of the parse functions. That is, calls like json j(i); for an input stream i need to be replaced by json j = json::parse(i); . Compilers will produce a deprecation warning if client code uses this function. Minor improvements: Improved the performance of the serialization by avoiding the re-creation of a locale object. Fixed two MSVC warnings. Compiling the test suite with /Wall now only warns about non-inlined functions (C4710) and the deprecation of the constructor from input-stream (C4996). Some project internals: The project has qualified for the Core Infrastructure Initiative Best Practices Badge . While most requirements where already satisfied, some led to a more explicit documentation of quality-ensuring procedures. For instance, static analysis is now executed with every commit on the build server. Furthermore, the contribution guidelines document how to communicate security issues privately. The test suite has been overworked and split into several files to allow for faster compilation and analysis. The execute the test suite, simply execute make check . The continuous integration with Travis was extended with Clang versions 3.6.0 to 3.8.1 and now includes 18 different compiler/OS combinations. An 11-day run of American fuzzy lop checked 962 million inputs on the parser and found no issue. v2.0.2 \u00b6 Files json.hpp (338 KB) json.hpp.asc (1 KB) Release date: 2016-07-31 SHA-256: 8e97b7965b4594b00998d6704465412360e1a0ed927badb51ded8b82291a8f3d Summary \u00b6 This release combines a lot of small fixes and improvements. The release is backwards compatible. Changes \u00b6 The parser has been overworked, and a lot of small issues have been fixed: Improved parser performance by avoiding recursion and using move semantics for the return value. Unescaped control charaters \\x10 - \\x1f are not accepted any more. Fixed a bug in the parser when reading from an input stream. Improved test case coverage for UTF-8 parsing: now, all valid Unicode code points are tested both escaped and unescaped. The precision of output streams is now preserved by the parser. Started to check the code correctness by proving termination of important loops. Furthermore, individual assertions have been replaced by a more systematic function which checks the class invariants. Note that assertions should be switched off in production by defining the preprocessor macro NDEBUG , see the documentation of assert . A lot of code cleanup : removed unused headers, fixed some compiler warnings, and fixed a build error for Windows-based Clang builds. Added some compile-time checks: Unsupported compilers are rejected during compilation with an #error command. Static assertion prohibits code with incompatible pointer types used in get_ptr() . Improved the documentation , and adjusted the documentation script to choose the correct version of sed . Replaced a lot of \"raw loops\" by STL functions like std::all_of , std::for_each , or std::accumulate . This facilitates reasoning about termination of loops and sometimes allowed to simplify functions to a single return statement. Implemented a value() function for JSON pointers (similar to at function). The Homebrew formula (see Integration ) is now tested for all Xcode builds (6.1 - 8.x) with Travis. Avoided output to std::cout in the test cases. v2.0.1 \u00b6 Files json.hpp (321 KB) json.hpp.asc (1 KB) Release date: 2016-06-28 SHA-256: ef550fcd7df572555bf068e9ec4e9d3b9e4cdd441cecb0dcea9ea7fd313f72dd Summary \u00b6 This release fixes a performance regression in the JSON serialization (function dump() ). This fix is backwards compatible. Changes \u00b6 The locale of the output stream (or the internal string stream if a JSON value is serialized to a string) is now adjusted once for the whole serialization instead of for each floating-point number. The locale of an output stream is now correctly reset to the previous value by the JSON library. v2.0.0 \u00b6 Files json.hpp (321 KB) json.hpp.asc (1 KB) Release date: 2016-06-24 SHA-256: ac9e1fb25c2ac9ca5fc501fcd2fe3281fe04f07018a1b48820e7b1b11491bb6c Summary \u00b6 This release adds several features such as JSON Pointers, JSON Patch, or support for 64 bit unsigned integers. Furthermore, several (subtle) bugs have been fixed. As noexcept and constexpr specifier have been added to several functions, the public API has effectively been changed in a (potential) non-backwards compatible manner. As we adhere to Semantic Versioning , this calls for a new major version, so say hello to 2\ufe0f\u20e3.0\ufe0f\u20e3.0\ufe0f\u20e3. Changes \u00b6 \ud83d\udd1f A JSON value now uses uint64_t (default value for template parameter NumberUnsignedType ) as data type for unsigned integer values. This type is used automatically when an unsigned number is parsed. Furthermore, constructors, conversion operators and an is_number_unsigned() test have been added. \ud83d\udc49 JSON Pointer ( RFC 6901 ) support: A JSON Pointer is a string (similar to an XPath expression) to address a value inside a structured JSON value. JSON Pointers can be used in at() and operator[] functions. Furthermore, JSON values can be \u201cflattened\u201d to key/value pairs using flatten() where each key is a JSON Pointer. The original value can be restored by \u201cunflattening\u201d the flattened value using unflatten() . \ud83c\udfe5 JSON Patch ( RFC 6902 ) support. A JSON Patch is a JSON value that describes the required edit operations (add, change, remove, \u2026) to transform a JSON value into another one. A JSON Patch can be created with function diff(const basic_json&) and applied with patch(const basic_json&) . Note the created patches use a rather primitive algorithm so far and leave room for improvement. \ud83c\uddea\ud83c\uddfa The code is now locale-independent : Floating-point numbers are always serialized with a period ( . ) as decimal separator and ignores different settings from the locale. \ud83c\udf7a Homebrew support: Install the library with brew tap nlohmann/json && brew install nlohmann_json . Added constructor to create a JSON value by parsing a std::istream (e.g., std::stringstream or std::ifstream ). Added noexcept specifier to basic_json(boolean_t) , basic_json(const number_integer_t) , basic_json(const int) , basic_json(const number_float_t) , iterator functions ( begin() , end() , etc.) When parsing numbers, the sign of 0.0 (vs. -0.0 ) is preserved. Improved MSVC 2015, Android, and MinGW support. See README for more information. Improved test coverage (added 2,225,386 tests). Removed some misuses of std::move . Fixed several compiler warnings. Improved error messages from JSON parser. Updated to re2c to version 0.16 to use a minimal DFAs for the lexer. Updated test suite to use Catch version 1.5.6. Made type getters ( is_number , etc.) and const value access constexpr . Functions push_back and operator+= now work with key/value pairs passed as initializer list, e.g. j_object += {\"key\", 1} . Overworked CMakeLists.txt to make it easier to integrate the library into other projects. Notes \u00b6 Parser error messages are still very vague and contain no information on the error location. The implemented diff function is rather primitive and does not create minimal diffs. The name of function iteration_wrapper may change in the future and the function will be deprecated in the next release. Roundtripping (i.e., parsing a JSON value from a string, serializing it, and comparing the strings) of floating-point numbers is not 100% accurate. Note that RFC 7159 defines no format to internally represent numbers and states not requirement for roundtripping. Nevertheless, benchmarks like Native JSON Benchmark treat roundtripping deviations as conformance errors. v1.1.0 \u00b6 Files json.hpp (257 KB) json.hpp.asc (1 KB) Release date: 2016-01-24 SHA-256: c0cf0e3017798ca6bb18e757ebc570d21a3bdac877845e2b9e9573d183ed2f05 Summary \u00b6 This release fixes several small bugs and adds functionality in a backwards-compatible manner. Compared to the last version (1.0.0) , the following changes have been made: Changes \u00b6 Fixed : Floating-point numbers are now serialized and deserialized properly such that rountripping works in more cases. [#185, #186, #190, #191, #194] Added : The code now contains assertions to detect undefined behavior during development. As the standard function assert is used, the assertions can be switched off by defining the preprocessor symbol NDEBUG during compilation. [#168] Added : It is now possible to get a reference to the stored values via the newly added function get_ref() . [#128, #184] Fixed : Access to object values via keys ( operator[] ) now works with all kind of string representations. [#171, #189] Fixed : The code now compiles again with Microsoft Visual Studio 2015 . [#144, #167, #188] Fixed : All required headers are now included. Fixed : Typos and other small issues. [#162, #166, #175, #177, #179, #180] Notes \u00b6 There are still known open issues (#178, #187) which will be fixed in version 2.0.0. However, these fixes will require a small API change and will not be entirely backwards-compatible. v1.0.0 \u00b6 Files json.hpp (243 KB) json.hpp.asc (1 KB) Release date: 2015-12-28 SHA-256: 767dc2fab1819d7b9e19b6e456d61e38d21ef7182606ecf01516e3f5230446de Summary \u00b6 This is the first official release. Compared to the prerelease version 1.0.0-rc1 , only a few minor improvements have been made: Changes \u00b6 Changed : A UTF-8 byte order mark is silently ignored. Changed : sprintf is no longer used. Changed : iterator_wrapper also works for const objects; note: the name may change! Changed : Error messages during deserialization have been improved. Added : The parse function now also works with type std::istream&& . Added : Function value(key, default_value) returns either a copy of an object's element at the specified key or a given default value if no element with the key exists. Added : Public functions are tagged with the version they were introduced. This shall allow for better versioning in the future. Added : All public functions and types are documented (see http://nlohmann.github.io/json/doxygen/ ) including executable examples. Added : Allocation of all types (in particular arrays, strings, and objects) is now exception-safe. Added : They descriptions of thrown exceptions have been overworked and are part of the tests suite and documentation.","title":"Releases"},{"location":"home/releases/#releases","text":"","title":"Releases"},{"location":"home/releases/#v373","text":"Files include.zip (274 KB) include.zip.asc (1 KB) json.hpp (791 KB) json.hpp.asc (1 KB) Release date: 2019-11-17 SHA-256: 3b5d2b8f8282b80557091514d8ab97e27f9574336c804ee666fda673a9b59926 (json.hpp), 87b5884741427220d3a33df1363ae0e8b898099fbc59f1c451113f6732891014 (include.zip)","title":"v3.7.3"},{"location":"home/releases/#summary","text":"This release fixes a bug introduced in release 3.7.2 which could yield quadratic complexity in destructor calls. All changes are backward-compatible.","title":"Summary"},{"location":"home/releases/#bug-fixes","text":"Removed reserve() calls from the destructor which could lead to quadratic complexity. #1837 #1838","title":"Bug Fixes"},{"location":"home/releases/#deprecated-functions","text":"This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead.","title":"Deprecated functions"},{"location":"home/releases/#v372","text":"Files include.zip (274 KB) include.zip.asc (1 KB) json.hpp (791 KB) json.hpp.asc (1 KB) Release date: 2019-11-10 SHA-256: 0a65fcbbe1b334d3f45c9498e5ee28c3f3b2428aea98557da4a3ff12f0f14ad6 (json.hpp), 67f69c9a93b7fa0612dc1b6273119d2c560317333581845f358aaa68bff8f087 (include.zip)","title":"v3.7.2"},{"location":"home/releases/#summary_1","text":"Project bad_json_parsers tested how JSON parser libraries react on deeply nested inputs . It turns out that this library segfaulted at a certain nesting depth. This bug was fixed with this release. Now the parsing is only bounded by the available memory. All changes are backward-compatible.","title":"Summary"},{"location":"home/releases/#bug-fixes_1","text":"Fixed a bug that lead to stack overflow for deeply nested JSON values (objects, array) by changing the implementation of the destructor from a recursive to an iterative approach. #832, #1419, #1835","title":"Bug Fixes"},{"location":"home/releases/#further-changes","text":"Added WhiteStone Bolt. #1830","title":"Further Changes"},{"location":"home/releases/#deprecated-functions_1","text":"This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead.","title":"Deprecated functions"},{"location":"home/releases/#v371","text":"Files include.zip (273 KB) include.zip.asc (1 KB) json.hpp (789 KB) json.hpp.asc (1 KB) Release date: 2019-11-06 SHA-256: b5ba7228f3c22a882d379e93d08eab4349458ee16fbf45291347994eac7dc7ce (json.hpp), 77b9f54b34e7989e6f402afb516f7ff2830df551c3a36973085e2c7a6b1045fe (include.zip)","title":"v3.7.1"},{"location":"home/releases/#summary_2","text":"This release fixes several small bugs in the library. All changes are backward-compatible.","title":"Summary"},{"location":"home/releases/#bug-fixes_2","text":"Fixed a segmentation fault when serializing std::int64_t minimum value. #1708 #1722 Fixed the contains() function for JSON Pointers. #1727 #1741 Fixed too lax SFINAE guard for conversion from std::pair and std::tuple to json . #1805 #1806 #1825 #1826 Fixed some regressions detected by UBSAN. Updated CI to use Clang-Tidy 7.1.0. #1716 #1728 Fixed integer truncation in iteration_proxy . #1797 Updated Hedley to v11 to fix a E2512 error in MSVC. #1799 Fixed a compile error in enum deserialization of non non-default-constructible types. #1647 #1821 Fixed the conversion from json to std::valarray .","title":"Bug Fixes"},{"location":"home/releases/#improvements","text":"The items() function can now be used with a custom string type. #1765 Made json_pointer::back const . #1764 #1769 Meson is part of the release archive. #1672 #1694 Improved documentation on the Meson and Spack package manager. #1694 #1720","title":"Improvements"},{"location":"home/releases/#further-changes_1","text":"Added GitHub Workflow with ubuntu-latest /GCC 7.4.0 as CI step. Added GCC 9 to Travis CI to compile with C++20 support. #1724 Added MSVC 2019 to the AppVeyor CI. #1780 Added badge to fuzzing status . Fixed some cppcheck warnings. #1760 Fixed several typos in the documentation. #1720 #1767 #1803 Added documentation on the JSON_THROW_USER , JSON_TRY_USER , and JSON_CATCH_USER macros to control user-defined exception handling. Used GitHub's CODEOWNERS and SECURITY feature. Removed GLOB from CMake files. #1779 Updated to Doctest 2.3.5.","title":"Further Changes"},{"location":"home/releases/#deprecated-functions_2","text":"This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead.","title":"Deprecated functions"},{"location":"home/releases/#v370","text":"Files include.zip (143 KB) include.zip.asc (1 KB) json.hpp (782 KB) json.hpp.asc (1 KB) Release date: 2019-07-28 SHA-256: a503214947952b69f0062f572cb74c17582a495767446347ce2e452963fc2ca4 (json.hpp), 541c34438fd54182e9cdc68dd20c898d766713ad6d901fb2c6e28ff1f1e7c10d (include.zip)","title":"v3.7.0"},{"location":"home/releases/#summary_3","text":"This release introduces a few convenience functions and performs a lot of house keeping (bug fixes and small improvements). All changes are backward-compatible.","title":"Summary"},{"location":"home/releases/#new-features","text":"Add overload of the contains function to check if a JSON pointer is valid without throwing exceptions, just like its counterpart for object keys . #1600 Add a function to_string to allow for generic conversion to strings. #916 #1585 Add return value for the emplace_back function , returning a reference to the added element just like C++17 is introducing this for std::vector . #1609 Add info how to use the library with the pacman package manager on MSYS2. #1670","title":"New Features"},{"location":"home/releases/#bug-fixes_3","text":"Fix an issue where typedefs with certain names yielded a compilation error. #1642 #1643 Fix a conversion to std::string_view in the unit tests. #1634 #1639 Fix MSVC Debug build. #1536 #1570 #1608 Fix get_to method to clear existing content before writing. #1511 #1555 Fix a -Wc++17-extensions warning. nodiscard attributes are now only used with Clang when -std=c++17 is used. #1535 #1551","title":"Bug Fixes"},{"location":"home/releases/#improvements_1","text":"Switch from Catch to doctest for the unit tests which speeds up compilation and runtime of the 112,112,308 tests. Add an explicit section to the README about the frequently addressed topics character encoding , comments in JSON , and the order of object keys .","title":"Improvements"},{"location":"home/releases/#further-changes_2","text":"Use GNUInstallDirs to set library install directories. #1673 Fix links in the README . #1620 #1621 #1622 #1623 #1625 Mention json type on the documentation start page . #1616 Complete documentation of value() function with respect to type_error.302 exception. #1601 Fix links in the documentation. #1598 Add regression tests for MSVC. #1543 #1570 Use CircleCI for continuous integration . Use Doozer for continuous integration on Linux (CentOS, Raspbian, Fedora) Add tests to check each CMake flag ( JSON_BuildTests , JSON_Install , JSON_MultipleHeaders , JSON_Sanitizer , JSON_Valgrind , JSON_NoExceptions , JSON_Coverage ). Use Hedley to avoid re-inventing several compiler-agnostic feature macros like JSON_DEPRECATED , JSON_NODISCARD , JSON_LIKELY , JSON_UNLIKELY , JSON_HAS_CPP_14 , or JSON_HAS_CPP_17 . Functions taking or returning pointers are annotated accordingly when a pointer will not be null. Build and run tests on AppVeyor in DEBUG and RELEASE mode.","title":"Further Changes"},{"location":"home/releases/#deprecated-functions_3","text":"This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead.","title":"Deprecated functions"},{"location":"home/releases/#v361","text":"Files include.zip (136 KB) include.zip.asc (1 KB) json.hpp (711 KB) json.hpp.asc (1 KB) Release date: 2019-03-20 SHA-256: d2eeb25d2e95bffeb08ebb7704cdffd2e8fca7113eba9a0b38d60a5c391ea09a (json.hpp), 69cc88207ce91347ea530b227ff0776db82dcb8de6704e1a3d74f4841bc651cf (include.zip)","title":"v3.6.1"},{"location":"home/releases/#summary_4","text":"This release fixes a regression and a bug introduced by the earlier 3.6.0 release. All changes are backward-compatible.","title":"Summary"},{"location":"home/releases/#bug-fixes_4","text":"Fixed regression of #590 which could lead to compilation errors with GCC 7 and GCC 8. #1530 Fixed a compilation error when <Windows.h> was included. #1531","title":"Bug Fixes"},{"location":"home/releases/#further-changes_3","text":"Fixed a warning for missing field initializers. #1527","title":"Further Changes"},{"location":"home/releases/#deprecated-functions_4","text":"This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead.","title":"Deprecated functions"},{"location":"home/releases/#v360","text":"Files include.zip (136 KB) include.zip.asc (1 KB) json.hpp (711 KB) json.hpp.asc (1 KB) Release date: 2019-03-20 SHA-256: ce9839370f28094c71107c405affb3b08c4a098154988014cbb0800b1c44a831 (json.hpp), 237c5e66e7f8186a02804ce9dbd5f69ce89fe7424ef84adf6142e973bd9532f4 (include.zip) \u2139\ufe0f This release introduced a regression. Please update to version 3.6.1 !","title":"v3.6.0"},{"location":"home/releases/#summary_5","text":"This release adds some convenience functions for JSON Pointers , introduces a contains function to check if a key is present in an object, and improves the performance of integer serialization . Furthermore, a lot of small bug fixes and improvements have been made. All changes are backward-compatible.","title":"Summary"},{"location":"home/releases/#new-features_1","text":"Overworked the public interface for JSON Pointers. The creation of JSON Pointers is simplified with operator/ and operator/= . JSON Pointers can be inspected with empty , back , and parent_pointer , and manipulated with push_back and pop_back . #1434 Added a boolean method contains to check whether an element exists in a JSON object with a given key. Returns false when called on non-object types. #1471 #1474","title":"New Features"},{"location":"home/releases/#bug-fixes_5","text":"Fixed a compilation issues with libc 2.12. #1483 #1514 Fixed endian conversion on PPC64. #1489 Fixed library to compile with GCC 9. #1472 #1492 Fixed a compilation issue with GCC 7 on CentOS. #1496 Fixed an integer overflow. #1447 Fixed buffer flushing in serializer. #1445 #1446","title":"Bug Fixes"},{"location":"home/releases/#improvements_2","text":"The performance of dumping integers has been greatly improved. #1411 Added CMake parameter JSON_Install to control whether the library should be installed (default: on). #1330 Fixed a lot of compiler and linter warnings. #1400 #1435 #1502 Reduced required CMake version from 3.8 to 3.1. #1409 #1428 #1441 #1498 Added nodiscard attribute to meta() , array() , object() , from_cbor , from_msgpack , from_ubjson , from_bson , and parse . #1433","title":"Improvements"},{"location":"home/releases/#further-changes_4","text":"Added missing headers. #1500 Fixed typos and broken links in README. #1417 #1423 #1425 #1451 #1455 #1491 Fixed documentation of parse function. #1473 Suppressed warning that cannot be fixed inside the library. #1401 #1468 Imroved package manager suppert: Updated Buckaroo instructions. #1495 Improved Meson support. #1463 Added Conda package manager documentation. #1430 Added NuGet package manager documentation. #1132 Continuous Integration Removed unstable or deprecated Travis builders (Xcode 6.4 - 8.2) and added Xcode 10.1 builder. Added Clang 7 to Travis CI. Fixed AppVeyor x64 builds. #1374 #1414 Updated thirdparty libraries: Catch 1.12.0 -> 1.12.2 Google Benchmark 1.3.0 -> 1.4.1 Doxygen 1.8.15 -> 1.8.16","title":"Further Changes"},{"location":"home/releases/#deprecated-functions_5","text":"This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead.","title":"Deprecated functions"},{"location":"home/releases/#v350","text":"Files include.zip (133 KB) include.zip.asc (1 KB) json.hpp (693 KB) json.hpp.asc (1 KB) Release date: 2018-12-22 SHA-256: 8a6dbf3bf01156f438d0ca7e78c2971bca50eec4ca6f0cf59adf3464c43bb9d5 (json.hpp), 3564da9c5b0cf2e032f97c69baedf10ddbc98030c337d0327a215ea72259ea21 (include.zip)","title":"v3.5.0"},{"location":"home/releases/#summary_6","text":"This release introduces the support for structured bindings and reading from FILE* . Besides, a few bugs have been fixed. All changes are backward-compatible.","title":"Summary"},{"location":"home/releases/#new-features_2","text":"Structured bindings are now supported for JSON objects and arrays via the items() member function, so finally this code is possible: for ( auto & [ key , val ] : j . items ()) { std :: cout << key << ':' << val << '\\n' ; } #1388 #1391 Added support for reading from FILE* to support situations in which streams are nit available or would require too much RAM. #1370 #1392","title":"New Features"},{"location":"home/releases/#bug-fixes_6","text":"The eofbit was not set for input streams when the end of a stream was reached while parsing. #1340 #1343 Fixed a bug in the SAX parser for BSON arrays.","title":"Bug Fixes"},{"location":"home/releases/#improvements_3","text":"Added support for Clang 5.0.1 (PS4 version). #1341 #1342","title":"Improvements"},{"location":"home/releases/#further-changes_5","text":"Added a warning for implicit conversions to the documentation: It is not recommended to use implicit conversions when reading from a JSON value. Details about this recommendation can be found here . #1363 Fixed typos in the documentation. #1329 #1380 #1382 Fixed a C4800 warning. #1364 Fixed a -Wshadow warning #1346 Wrapped std::snprintf calls to avoid error in MSVC. #1337 Added code to allow installation via Meson. #1345","title":"Further Changes"},{"location":"home/releases/#deprecated-functions_6","text":"This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead.","title":"Deprecated functions"},{"location":"home/releases/#v340","text":"Files include.zip (132 KB) include.zip.asc (1 KB) json.hpp (689 KB) json.hpp.asc (1 KB) Release date: 2018-10-30 SHA-256: 63da6d1f22b2a7bb9e4ff7d6b255cf691a161ff49532dcc45d398a53e295835f (json.hpp), bfec46fc0cee01c509cf064d2254517e7fa80d1e7647fea37cf81d97c5682bdc (include.zip)","title":"v3.4.0"},{"location":"home/releases/#summary_7","text":"This release introduces three new features: BSON (Binary JSON) is next to CBOR, MessagePack, and UBJSON the fourth binary (de)serialization format supported by the library. Adjustable error handlers for invalid Unicode allows to specify the behavior when invalid byte sequences are serialized. Simplified enum/JSON mapping with a macro in case the default mapping to integers is not desired. Furthermore, some effort has been invested in improving the parse error messages . Besides, a few bugs have been fixed. All changes are backward-compatible.","title":"Summary"},{"location":"home/releases/#new-features_3","text":"The library can read and write a subset of BSON (Binary JSON) . All data types known from JSON are supported, whereas other types more tied to MongoDB such as timestamps, object ids, or binary data are currently not implemented. See the README for examples. #1244 #1320 The behavior when the library encounters an invalid Unicode sequence during serialization can now be controlled by defining one of three Unicode error handlers : (1) throw an exception (default behavior), (2) replace invalid sequences by the Unicode replacement character (U+FFFD), or (3) ignore/filter invalid sequences. See the documentation of the dump function for examples. #1198 #1314 To easily specify a user-defined enum/JSON mapping , a macro NLOHMANN_JSON_SERIALIZE_ENUM has been introduced. See the README section for more information. #1208 #1323","title":"New Features"},{"location":"home/releases/#bug-fixes_7","text":"fixed truncation #1286 #1315 fixed an issue with std::pair #1299 #1301 fixed an issue with std::variant #1292 #1294 fixed a bug in the JSON Pointer parser","title":"Bug Fixes"},{"location":"home/releases/#improvements_4","text":"The diagnosis messages for parse errors have been improved: error messages now indicated line/column positions where possible (in addition to a byte count) and also the context in which the error occurred (e.g., \"while parsing a JSON string\"). Example: error parse error at 2: syntax error - invalid string: control character must be escaped; last read: '<U+0009>' is now reported as parse error at line 1, column 2: syntax error while parsing value - invalid string: control character U+0009 (HT) must be escaped to \\u0009 or \\t; last read: '<U+0009>' . #1280 #1288 #1303","title":"Improvements"},{"location":"home/releases/#further-changes_6","text":"improved Meson documentation #1305 fixed some more linter warnings #1280 fixed Clang detection for third-party Google Benchmark library #1277","title":"Further Changes"},{"location":"home/releases/#deprecated-functions_7","text":"This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead.","title":"Deprecated functions"},{"location":"home/releases/#v330","text":"Files include.zip (123 KB) include.zip.asc (1 KB) json.hpp (635 KB) json.hpp.asc (1 KB) Release date: 2018-10-05 SHA-256: f1327bb60c58757a3dd2b0c9c45d49503d571337681d950ec621f8374bcc14d4 (json.hpp), 9588d63557333aaa485e92221ec38014a85a6134e7486fe3441e0541a5a89576 (include.zip)","title":"v3.3.0"},{"location":"home/releases/#summary_8","text":"This release adds support for GCC 4.8 . Furthermore, it adds a function get_to to write a JSON value to a passed reference. Another topic of this release was the CMake support which has been overworked and documented. Besides, a lot of bugs have been fixed and slight improvements have been made. All changes are backward-compatible.","title":"Summary"},{"location":"home/releases/#new-features_4","text":"The library can now also built with GCC 4.8 . Though this compiler does not fully support C++11, it can successfully compile and run the test suite. Note that bug 57824 in GCC 4.8 still forbids to use multiline raw strings in arguments to macros. #1257 Added new function get_to to write a JSON value to a passed reference. The destination type is automatically derived which allows more succinct code compared to the get function. #1227 #1231","title":"New Features"},{"location":"home/releases/#bug-fixes_8","text":"Fixed a bug in the CMake file that made target_link_libraries to not properly include nlohmann_json . #1243 #1245 #1260 Fixed a warning in MSVC 2017 complaining about a constexpr if. #1204 #1268 #1272 Fixed a bug that prevented compilation with ICPC. #755 #1222 Improved the SFINAE correctness to fix a bug in the conversion operator. #1237 #1238 Fixed a -Wctor-dtor-privacy warning. #1224 Fixed a warning on a lambda in unevaluated context. #1225 #1230 Fixed a bug introduced in version 3.2.0 where defining JSON_CATCH_USER led to duplicate macro definition of JSON_INTERNAL_CATCH . #1213 #1214 Fixed a bug that prevented compilation with Clang 3.4.2 in RHEL 7. #1179 #1249","title":"Bug Fixes"},{"location":"home/releases/#improvements_5","text":"Added documentation on CMake integration of the library. #1270 Changed the CMake file to use find_package(nlohmann_json) without installing the library. #1202 Improved error messages in case operator[] is used with the wrong combination (json.exception.type_error.305) of JSON container type and argument type. Example: \"cannot use operator[] with a string argument\". #1220 #1221 Added a license and version information to the Meson build file. #1252 Removed static assertions to indicated missing to_json or from_json functions as such assertions do not play well with SFINAE. These assertions also led to problems with GMock. #960 #1212 #1228 The test suite now does not wait forever if run in a wrong directory and input files are not found. #1262 The test suite does not show deprecation warnings for deprecated functions which frequently led to confusion. #1271","title":"Improvements"},{"location":"home/releases/#further-changes_7","text":"GCC 4.8 and Xcode 10 were added to the continuous integration suite at Travis. Added lgtm checks to pull requests. Added tests for CMake integration. #1260","title":"Further Changes"},{"location":"home/releases/#deprecated-functions_8","text":"This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead.","title":"Deprecated functions"},{"location":"home/releases/#v320","text":"Files include.zip (124 KB) include.zip.asc (1 KB) json.hpp (636 KB) json.hpp.asc (1 KB) Release date: 2018-08-20 SHA-256: ce6b5610a051ec6795fa11c33854abebb086f0fd67c311f5921c3c07f9531b44 (json.hpp), 35ee642558b90e2f9bc758995c4788c4b4d4dec54eef95fb8f38cb4d49c8fc7c (include.zip)","title":"v3.2.0"},{"location":"home/releases/#summary_9","text":"This release introduces a SAX interface to the library. While this may be a very special feature used by only few people, it allowed to unify all functions that consumed input and created some kind of JSON value. Internally, now all existing functions like parse , accept , from_cbor , from_msgpack , and from_ubjson use the SAX interface with different event processors. This allowed to separate the input processing from the value generation. Furthermore, throwing an exception in case of a parse error is now optional and up to the event processor. Finally, the JSON parser is now non-recursive (meaning it does not use the call stack, but std::vector<bool> to track the hierarchy of structured values) which allows to process nested input more efficiently. Furthermore, the library finally is able to parse from wide string types . This is the first step toward opening the library from UTF-8 to UTF-16 and UTF-32. This release further fixes several bugs in the library. All changes are backward-compatible.","title":"Summary"},{"location":"home/releases/#new-features_5","text":"added a parser with a SAX interface (#971, #1153) support to parse from wide string types std::wstring , std::u16string , and std::u32string ; the input will be converted to UTF-8 (#1031) added support for std::string_view when using C++17 (#1028) allow to roundtrip std::map and std::unordered_map from JSON if key type is not convertible to string; in these cases, values are serialized to arrays of pairs (#1079, #1089, #1133, #1138)","title":"New Features"},{"location":"home/releases/#bug-fixes_9","text":"allow to create nullptr_t from JSON allowing to properly roundtrip null values (#1169) allow compare user-defined string types (#1130) better support for algorithms using iterators from items() (#1045, #1134) added parameter to avoid compilation error with MSVC 2015 debug builds (#1114) re-added accidentially skipped unit tests (#1176) fixed MSVC issue with std::swap (#1168)","title":"Bug Fixes"},{"location":"home/releases/#improvements_6","text":"key() function for iterators returns a const reference rather than a string copy (#1098) binary formats CBOR, MessagePack, and UBJSON now supports float as type for floating-point numbers (#1021)","title":"Improvements"},{"location":"home/releases/#further-changes_8","text":"changed issue templates improved continuous integration: added builders for Xcode 9.3 and 9.4, added builders for GCC 8 and Clang 6, added builder for MinGW, added builders for MSVC targeting x86 required CMake version is now at least 3.8 (#1040) overworked CMake file wrt. packaging (#1048) added package managers: Spack (#1041) and CocoaPods (#1148) fixed Meson include directory (#1142) preprocessor macro JSON_SKIP_UNSUPPORTED_COMPILER_CHECK can skip the rejection of unsupported compilers - use at your own risk! (#1128) preprocessor macro JSON_INTERNAL_CATCH / JSON_INTERNAL_CATCH_USER allows to control the behavior of exception handling inside the library (#1187) added note on char to JSON conversion added note how to send security-related issue via encrypted email removed dependency to std::stringstream (#1117) added SPDX-License-Identifier added updated JSON Parsing Test Suite, described in Parsing JSON is a Minefield \ud83d\udca3 updated to Catch 1.12.0","title":"Further Changes"},{"location":"home/releases/#deprecated-functions_9","text":"This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead.","title":"Deprecated functions"},{"location":"home/releases/#v312","text":"Files include.zip (115 KB) include.zip.asc (1 KB) json.hpp (582 KB) json.hpp.asc (1 KB) Release date: 2018-03-14 SHA-256: fbdfec4b4cf63b3b565d09f87e6c3c183bdd45c5be1864d3fcb338f6f02c1733 (json.hpp), 495362ee1b9d03d9526ba9ccf1b4a9c37691abe3a642ddbced13e5778c16660c (include.zip)","title":"v3.1.2"},{"location":"home/releases/#summary_10","text":"This release fixes several bugs in the library. All changes are backward-compatible.","title":"Summary"},{"location":"home/releases/#bug-fixes_10","text":"Fixed a memory leak occurring in the parser callback (#1001). Different specializations of basic_json (e.g., using different template arguments for strings or objects) can now be used in assignments (#972, #977, #986). Fixed a logical error in an iterator range check (#992).","title":"Bug Fixes"},{"location":"home/releases/#improvements_7","text":"The parser and the serialization now support user-defined string types (#1006, #1009).","title":"Improvements"},{"location":"home/releases/#further-changes_9","text":"Clang Analyzer is now used as additional static analyzer; see make clang_analyze . Overworked README by adding links to the documentation (#981).","title":"Further Changes"},{"location":"home/releases/#deprecated-functions_10","text":"This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead.","title":"Deprecated functions"},{"location":"home/releases/#v311","text":"Files include.zip (114 KB) include.zip.asc (1 KB) json.hpp (577 KB) json.hpp.asc (1 KB) Release date: 2018-02-13 SHA-256: e14ce5e33d6a2daf748026bd4947f3d9686ca4cfd53d10c3da46a0a9aceb7f2e (json.hpp), fde771d4b9e4f222965c00758a2bdd627d04fb7b59e09b7f3d1965abdc848505 (include.zip)","title":"v3.1.1"},{"location":"home/releases/#summary_11","text":"This release fixes several bugs in the library. All changes are backward-compatible.","title":"Summary"},{"location":"home/releases/#bug-fixes_11","text":"Fixed parsing of CBOR strings with indefinite length (#961). Earlier versions of this library misinterpreted the CBOR standard and rejected input with the 0x7F start byte. Fixed user-defined conversion to vector type (#924, #969). A wrong SFINAE check rejected code though a user-defined conversion was provided. Fixed documentation of the parser behavior for objects with duplicate keys (#963). The exact behavior is not specified by RFC 8259 and the library now also provides no guarantee which object key is stored. Added check to detect memory overflow when parsing UBJSON containers (#962). The optimized UBJSON format allowed for specifying an array with billions of null elements with a few bytes and the library did not check whether this size exceeded max_size() .","title":"Bug Fixes"},{"location":"home/releases/#further-changes_10","text":"Code coverage is now calculated for the individual header files, allowing to find uncovered lines more quickly than by browsing through the single header version (#953, #957). A Makefile target run_benchmarks was added to quickly build and run the benchmark suite. The documentation was harmonized with respect to the header inclusion (#955). Now all examples and the README use #include <nlohmann/json.hpp> to allow for selecting single_include or include or whatever installation folder as include directory. Added note on how to use the library with the cget package manager (#954).","title":"Further Changes"},{"location":"home/releases/#deprecated-functions_11","text":"This release does not deprecate any functions. As an overview, the following functions have been deprecated in earlier versions and will be removed in the next major version (i.e., 4.0.0): Function iterator_wrapper are deprecated. Please use the member function items() instead. Functions friend std::istream& operator<<(basic_json&, std::istream&) and friend std::ostream& operator>>(const basic_json&, std::ostream&) are deprecated. Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead.","title":"Deprecated functions"},{"location":"home/releases/#v310","text":"Files include.zip (114 KB) include.zip.asc (1 KB) json.hpp (577 KB) json.hpp.asc (1 KB) Release date: 2018-02-01 SHA-256: d40f614d10a6e4e4e80dca9463da905285f20e93116c36d97d4dc1aa63d10ba4 (json.hpp), 2b7234fca394d1e27b7e017117ed80b7518fafbb4f4c13a7c069624f6f924673 (include.zip)","title":"v3.1.0"},{"location":"home/releases/#summary_12","text":"This release adds support for the UBJSON format and JSON Merge Patch . It also contains some minor changes and bug fixes. All changes are backward-compatible.","title":"Summary"},{"location":"home/releases/#new-features_6","text":"The library now supports UBJSON (Universal Binary JSON Specification) as binary format to read and write JSON values space-efficiently. See the documentation overview for a comparison of the different formats CBOR, MessagePack, and UBJSON. JSON Merge Patch (RFC 7386) offers an intuitive means to describe patches between JSON values (#876, #877). See the documentation of merge_patch for more information.","title":"New features"},{"location":"home/releases/#improvements_8","text":"The library now uses the Grisu2 algorithm for printing floating-point numbers (based on the reference implementation by Florian Loitsch) which produces a short representation which is guaranteed to round-trip (#360, #935, #936). The UTF-8 handling was further simplified by using the decoder of Bj\u00f6rn Hoehrmann in more scenarios.","title":"Improvements"},{"location":"home/releases/#reorganization","text":"Though the library is released as a single header, its development got more and more complicated. With this release, the header is split into several files and the single-header file json.hpp can be generated from these development sources. In the repository, folder include contains the development sources and single_include contains the single json.hpp header (#700, #906, #907, #910, #911, #915, #920, #924, #925, #928, #944). The split further allowed for a forward declaration header include/nlohmann/json_fwd.hpp to speed up compilation times (#314).","title":"Reorganization"},{"location":"home/releases/#further-changes_11","text":"Google Benchmark is now used for micro benchmarks (see benchmarks folder, #921). The serialization (JSON and binary formats) now properly work with the libraries string template parameter, allowing for optimized string implementations to be used in constraint environments such as embedded software (#941, #950). The exceptional behavior can now be overridden by defining macros JSON_THROW_USER , JSON_TRY_USER , and JSON_CATCH_USER , defining the behavior of throw , try and catch , respectively. This allows to switch off C++'s exception mechanism yet still execute user-defined code in case an error condition occurs (#938). To facilitate the interplay with flex and Bison , the library does not use the variable name yytext any more as it could clash with macro definitions (#933). The library now defines NLOHMANN_JSON_VERSION_MAJOR , NLOHMANN_JSON_VERSION_MINOR , and NLOHMANN_JSON_VERSION_PATCH to allow for conditional compilation based on the included library version (#943, #948). A compilation error with ICC has been fixed (#947). Typos and links in the documentation have been fixed (#900, #930). A compiler error related to incomplete types has been fixed (#919). The tests form the UTF-8 decoder stress test have been added to the test suite.","title":"Further changes"},{"location":"home/releases/#deprecated-functions_12","text":"Function iterator_wrapper has been deprecated (#874). Since its introduction, the name was up for discussion, as it was too technical. We now introduced the member function items() with the same semantics. iterator_wrapper will be removed in the next major version (i.e., 4.0.0). Furthermore, the following functions are deprecated since version 3.0.0 and will be removed in the next major version (i.e., 4.0.0): friend std::istream& operator<<(basic_json&, std::istream&) friend std::ostream& operator>>(const basic_json&, std::ostream&) Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead.","title":"Deprecated functions"},{"location":"home/releases/#v301","text":"Files json.hpp (502 KB) json.hpp.asc (1 KB) Release date: 2017-12-29 SHA-256: c9b3591f1bb94e723a0cd7be861733a3a555b234ef132be1e9027a0364118c4c","title":"v3.0.1"},{"location":"home/releases/#summary_13","text":"This release fixes small issues in the implementation of JSON Pointer and JSON Patch . All changes are backward-compatible.","title":"Summary"},{"location":"home/releases/#changes","text":"The \"copy\" operation of JSON Patch ( RFC 6902 ) requests that it is an error if the target path points into a non-existing array or object (see #894 for a detailed description). This release fixes the implementation to detect such invalid target paths and throw an exception. An array index in a JSON Pointer ( RFC 6901 ) must be an integer. This release fixes the implementation to throw an exception in case invalid array indices such as 10e2 are used. Added the JSON Patch tests from Byron Ruth and Mike McCabe. Fixed the documentation of the at(ptr) function with JSON Pointers to list all possible exceptions (see #888). Updated the container overview documentation (see #883). The CMake files now respect the BUILD_TESTING option (see #846, #885) Fixed some compiler warnings (see #858, #882).","title":"Changes"},{"location":"home/releases/#deprecated-functions_13","text":"To unify the interfaces and to improve similarity with the STL, the following functions are deprecated since version 3.0.0 and will be removed in the next major version (i.e., 4.0.0): friend std::istream& operator<<(basic_json&, std::istream&) friend std::ostream& operator>>(const basic_json&, std::ostream&) Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead.","title":"Deprecated functions"},{"location":"home/releases/#v300","text":"Files json.hpp (501 KB) json.hpp.asc (1 KB) Release date: 2017-12-17 SHA-256: 076d4a0cb890a3c3d389c68421a11c3d77c64bd788e85d50f1b77ed252f2a462","title":"v3.0.0"},{"location":"home/releases/#summary_14","text":"After almost a year, here is finally a new release of JSON for Modern C++, and it is a major one! As we adhere to semantic versioning , this means the release includes some breaking changes, so please read the next section carefully before you update. But don't worry, we also added a few new features and put a lot of effort into fixing a lot of bugs and straighten out a few inconsistencies.","title":"Summary"},{"location":"home/releases/#breaking-changes","text":"This section describes changes that change the public API of the library and may require changes in code using a previous version of the library. In section \"Moving from 2.x.x to 3.0.0\" at the end of the release notes, we describe in detail how existing code needs to be changed. The library now uses user-defined exceptions instead of re-using those defined in <stdexcept> (#244). This not only allows to add more information to the exceptions (every exception now has an identifier, and parse errors contain the position of the error), but also to easily catch all library exceptions with a single catch(json::exception) . When strings with a different encoding as UTF-8 were stored in JSON values, their serialization could not be parsed by the library itself, as only UTF-8 is supported. To enforce this library limitation and improve consistency, non-UTF-8 encoded strings now yield a json::type_error exception during serialization (#838). The check for valid UTF-8 is realized with code from Bj\u00f6rn Hoehrmann . NaN and infinity values can now be stored inside the JSON value without throwing an exception. They are, however, still serialized as null (#388). The library's iterator tag was changed from RandomAccessIterator to BidirectionalIterator (#593). Supporting RandomAccessIterator was incorrect as it assumed an ordering of values in a JSON objects which are unordered by definition. The library does not include the standard headers <iostream> , <ctype> , and <stdexcept> any more. You may need to add these headers to code relying on them. Removed constructor explicit basic_json(std::istream& i, const parser_callback_t cb = nullptr) which was deprecated in version 2.0.0 (#480).","title":"Breaking changes"},{"location":"home/releases/#deprecated-functions_14","text":"To unify the interfaces and to improve similarity with the STL, the following functions are now deprecated and will be removed in the next major version (i.e., 4.0.0): friend std::istream& operator<<(basic_json&, std::istream&) friend std::ostream& operator>>(const basic_json&, std::ostream&) Please use friend std::istream& operator>>(std::istream&, basic_json&) and friend operator<<(std::ostream&, const basic_json&) instead.","title":"Deprecated functions"},{"location":"home/releases/#new-features_7","text":"With all this breaking and deprecation out of the way, let's talk about features! We improved the diagnostic information for syntax errors (#301). Now, an exception json::parse_error is thrown which contains a detailed message on the error, but also a member byte to indicate the byte offset in the input where the error occurred. We added a non-throwing syntax check (#458): The new accept function returns a Boolean indicating whether the input is proper JSON. We also added a Boolean parameter allow_exceptions to the existing parse functions to return a discarded value in case a syntax error occurs instead of throwing an exception. An update function was added to merge two JSON objects (#428). In case you are wondering: the name was inspired by Python . The insert function now also supports an iterator range to add elements to an object. The binary exchange formats CBOR and MessagePack can now be parsed from input streams and written to output streams (#477). Input streams are now only read until the end of a JSON value instead of the end of the input (#367). The serialization function dump now has two optional parameters ensure_ascii to escape all non-ASCII characters with \\uxxxx and an indent_char parameter to choose whether to indent with spaces or tabs (#654). Added built-in type support for C arrays (#502), std::pair and std::tuple (#563, #614), enum and enum class (#545), std::vector<bool> (#494). Fixed support for std::valarray (#702), std::array (#553), and std::map<std::string, std::string> (#600, #607).","title":"New features"},{"location":"home/releases/#further-changes_12","text":"Furthermore, there have been a lot of changes under the hood: Replaced the re2c generated scanner by a self-coded version which allows for a better modularization of the parser and better diagnostics. To test the new scanner, we added millions (8,860,608 to be exact) of unit tests to check all valid and invalid byte sequences of the Unicode standard. Google's OSS-Fuzz is still constantly fuzz-testing the library and found several issues that were fixed in this release (#497, #504, #514, #516, #518, #519, #575). We now also ignore UTF-8 byte order marks when parsing from an iterator range (#602). Values can be now moved from initializer lists (#663). Updated to Catch 1.9.7. Unfortunately, Catch2 currently has some performance issues. The non-exceptional paths of the library are now annotated with __builtin_expect to optimize branch prediction as long as no error occurs. MSVC now produces a stack trace in MSVC if a from_json or to_json function was not found for a user-defined type. We also added a debug visualizer nlohmann_json.natvis for better debugging in MSVC (#844). Overworked the documentation and added even more examples. The build workflow now relies on CMake and CTest. Special flags can be chosen with CMake, including coverage ( JSON_Coverage ), compilation without exceptions ( JSON_NoExceptions ), LLVM sanitizers ( JSON_Sanitizer ), or execution with Valgrind ( JSON_Valgrind ). Added support for package managers Meson (#576), Conan (#566), Hunter (#671, #829), and vcpkg (#753). Added CI builders: Xcode 8.3, 9.0, 9.1, and 9.2; GCC 7.2; Clang 3.8, 3.9, 4.0, and 5.0; Visual Studio 2017. The library is further built with C++17 settings on the latest Clang, GCC, and MSVC version to quickly detect new issues.","title":"Further changes"},{"location":"home/releases/#moving-from-2xx-to-300","text":"","title":"Moving from 2.x.x to 3.0.0"},{"location":"home/releases/#user-defined-exceptions","text":"There are five different exceptions inheriting from json::exception : json::parse_error for syntax errors (including the binary formats), json::invalid_iterator for errors related to iterators, json::type_error for errors where functions were called with the wrong JSON type, json::out_of_range for range errors, and json::other_error for miscellaneous errors. To support these exception, the try / catch blocks of your code need to be adjusted: new exception previous exception parse_error.101 invalid_argument parse_error.102 invalid_argument parse_error.103 invalid_argument parse_error.104 invalid_argument parse_error.105 invalid_argument parse_error.106 domain_error parse_error.107 domain_error parse_error.108 domain_error parse_error.109 invalid_argument parse_error.110 out_of_range parse_error.111 invalid_argument parse_error.112 invalid_argument invalid_iterator.201 domain_error invalid_iterator.202 domain_error invalid_iterator.203 domain_error invalid_iterator.204 out_of_range invalid_iterator.205 out_of_range invalid_iterator.206 domain_error invalid_iterator.207 domain_error invalid_iterator.208 domain_error invalid_iterator.209 domain_error invalid_iterator.210 domain_error invalid_iterator.211 domain_error invalid_iterator.212 domain_error invalid_iterator.213 domain_error invalid_iterator.214 out_of_range type_error.301 domain_error type_error.302 domain_error type_error.303 domain_error type_error.304 domain_error type_error.305 domain_error type_error.306 domain_error type_error.307 domain_error type_error.308 domain_error type_error.309 domain_error type_error.310 domain_error type_error.311 domain_error type_error.313 domain_error type_error.314 domain_error type_error.315 domain_error out_of_range.401 out_of_range out_of_range.402 out_of_range out_of_range.403 out_of_range out_of_range.404 out_of_range out_of_range.405 domain_error other_error.501 domain_error","title":"User-defined Exceptions"},{"location":"home/releases/#handling-of-nan-and-inf","text":"If an overflow occurs during parsing a number from a JSON text, an exception json::out_of_range is thrown so that the overflow is detected early and roundtripping is guaranteed. NaN and INF floating-point values can be stored in a JSON value and are not replaced by null. That is, the basic_json class behaves like double in this regard (no exception occurs). However, NaN and INF are serialized to null .","title":"Handling of NaN and INF"},{"location":"home/releases/#removal-of-deprecated-functions","text":"Function explicit basic_json(std::istream& i, const parser_callback_t cb = nullptr) should be replaced by the parse function: Let ss be a stream and cb be a parse callback function. Old code: json j ( ss , cb ); New code: json j = json :: parse ( ss , cb ); If no callback function is used, also the following code works: json j ; j << ss ; or json j ; ss >> j ;","title":"Removal of deprecated functions"},{"location":"home/releases/#v211","text":"Files json.hpp (437 KB) json.hpp.asc (1 KB) Release date: 2017-02-25 SHA-256: faa2321beb1aa7416d035e7417fcfa59692ac3d8c202728f9bcc302e2d558f57","title":"v2.1.1"},{"location":"home/releases/#summary_15","text":"This release fixes a locale-related bug in the parser . To do so, the whole number handling (lexer, parser, and also the serialization) have been overworked. Furthermore, a lot of small changes added up that were added to this release. All changes are backward-compatible.","title":"Summary"},{"location":"home/releases/#changes_1","text":"Locales that have a different character than . as decimal separator (e.g., the Norwegian locale nb_NO.UTF-8 ) led to truncated number parsing or parse errors. The library now has been fixed to work with any locale . Note that . is still the only valid decimal separator for JSON input. Numbers like 1.0 were correctly parsed as floating-point number, but serialized as integer ( 1 ). Now, floating-point numbers correctly round trip . Parsing incorrect JSON numbers with leading 0 ( 0123 ) could yield a buffer overflow . This is fixed now by detecting such errors directly by the lexer. Constructing a JSON value from a pointer was incorrectly interpreted as a Boolean; such code will now yield a compiler error. Comparing a JSON number with 0 led to a comparison with null . This is fixed now. All throw calls are now wrapped in macros. Starting during the preparation of this release (since 8 February 2017), commits and released files are cryptographically signed with this GPG key . Previous releases have also been signed. The parser for MessagePack and CBOR now supports an optional start index parameter to define a byte offset for the parser. Some more warnings have been fixed. With Clang, the code compiles without warnings with -Weverything (well, it needs -Wno-documentation-unknown-command and -Wno-deprecated-declarations , but you get the point). The code can be compiled easier with many Android NDKs by avoiding macros like UINT8_MAX which previously required defining a preprocessor macro for compilation. The unit tests now compile two times faster. Cotire is used to speed up the build. Fixed a lot of typos in the documentation. Added a section to the README file that lists all used third-party code/tools . Added a note on constructing a string value vs. parsing. The test suite now contains 11202597 unit tests. Improved the Doxygen documentation by shortening the template parameters of class basic_json . Removed Doozer. Added Codacity. Upgraded Catch to version 1.7.2.","title":"Changes"},{"location":"home/releases/#v210","text":"Files json.hpp (426 KB) json.hpp.asc (1 KB) Release date: 2017-01-28 SHA-256: a571dee92515b685784fd527e38405cf3f5e13e96edbfe3f03d6df2e363a767b","title":"v2.1.0"},{"location":"home/releases/#summary_16","text":"This release introduces a means to convert from/to user-defined types. The release is backwards compatible.","title":"Summary"},{"location":"home/releases/#changes_2","text":"The library now offers an elegant way to convert from and to arbitrary value types . All you need to do is to implement two functions: to_json and from_json . Then, a conversion is as simple as putting a = between variables. See the README for more information and examples. Exceptions can now be switched off. This can be done by defining the preprocessor symbol JSON_NOEXCEPTION or by passing -fno-exceptions to your compiler. In case the code would usually thrown an exception, abort() is now called. Information on the library can be queried with the new (static) function meta() which returns a JSON object with information on the version, compiler, and platform. See the documentation for an example. A bug in the CBOR parser was fixed which led to a buffer overflow. The function type_name() is now public. It allows to query the type of a JSON value as string. Added the Big List of Naughty Strings as test case. Updated to Catch v1.6.0 . Some typos in the documentation have been fixed.","title":"Changes"},{"location":"home/releases/#v2010","text":"Files json.hpp (409 KB) json.hpp.asc (1 KB) Release date: 2017-01-02 SHA-256: ec27d4e74e9ce0f78066389a70724afd07f10761009322dc020656704ad5296d","title":"v2.0.10"},{"location":"home/releases/#summary_17","text":"This release fixes several security-relevant bugs in the MessagePack and CBOR parsers. The fixes are backwards compatible.","title":"Summary"},{"location":"home/releases/#changes_3","text":"Fixed a lot of bugs in the CBOR and MesssagePack parsers . These bugs occurred if invalid input was parsed and then could lead in buffer overflows. These bugs were found with Google's OSS-Fuzz , see #405, #407, #408, #409, #411, and #412 for more information. We now also use the Doozer continuous integration platform . The complete test suite is now also run with Clang's address sanitizer and undefined-behavior sanitizer . Overworked fuzz testing ; CBOR and MessagePack implementations are now fuzz-tested. Furthermore, all fuzz tests now include a round trip which ensures created output can again be properly parsed and yields the same JSON value. Clarified documentation of find() function to always return end() when called on non-object value types. Moved thirdparty test code to test/thirdparty directory.","title":"Changes"},{"location":"home/releases/#v209","text":"Files json.hpp (406 KB) json.hpp.asc (1 KB) Release date: 2016-12-16 SHA-256: fbf3396f13e187d6c214c297bddc742d918ea9b55e10bfb3d9f458b9bfdc22e5","title":"v2.0.9"},{"location":"home/releases/#summary_18","text":"This release implements with CBOR and MessagePack two binary serialization/deserialization formats . It further contains some small fixes and improvements. The fixes are backwards compatible.","title":"Summary"},{"location":"home/releases/#changes_4","text":"The library can now read and write the binary formats CBOR (Concise Binary Object Representation) and MessagePack . Both formats are aimed to produce a very compact representation of JSON which can be parsed very efficiently. See the README file for more information and examples. simplified the iteration implementation allowing to remove dozens of lines of code fixed an integer overflow error detected by Google's OSS-Fuzz suppressed documentation warnings inside the library to facilitate compilation with -Wdocumentation fixed an overflow detection error in the number parser updated contribution guidelines to a list of frequentely asked features that will most likely be never added to the library added a table of contents to the README file to add some structure mentioned the many examples and the documentation in the README file split unit tests into individual independent binaries to speed up compilation and testing the test suite now contains 11201886 tests","title":"Changes"},{"location":"home/releases/#v208","text":"Files json.hpp (360 KB) json.hpp.asc (1 KB) Release date: 2016-12-02 SHA-256: b70db0ad34f8e0e61dc3f0cbab88099336c9674c193d8a3439d93d6aca2d7120","title":"v2.0.8"},{"location":"home/releases/#summary_19","text":"This release combines a lot of small fixes and improvements. The fixes are backwards compatible.","title":"Summary"},{"location":"home/releases/#changes_5","text":"fixed a bug that froze the parser if a passed file was not found (now, std::invalid_argument is thrown) fixed a bug that lead to an error of a file at EOF was parsed again (now, std::invalid_argument is thrown) the well known functions emplace and emplace_back have been added to JSON values and work as expected improved the performance of the serialization ( dump function) improved the performance of the deserialization (parser) some continuous integration images at Travis were added and retired; see here for the current continuous integration setup the Coverity scan works again the benchmarking code has been improved to produce more stable results the README file has been extended and includes more frequently asked examples the test suite now contains 8905518 tests updated Catch to version 1.5.8","title":"Changes"},{"location":"home/releases/#v207","text":"Files json.hpp (355 KB) json.hpp.asc (1 KB) Release date: 2016-11-02 SHA-256: 5545c323670f8165bae90b9dc6078825e86ec310d96cc4e5b47233ea43715bbf","title":"v2.0.7"},{"location":"home/releases/#summary_20","text":"This release fixes a few bugs in the JSON parser found in the Parsing JSON is a Minefield \ud83d\udca3 article. The fixes are backwards compatible.","title":"Summary"},{"location":"home/releases/#changes_6","text":"The article Parsing JSON is a Minefield \ud83d\udca3 discusses a lot of pitfalls of the JSON specification. When investigating the published test cases, a few bugs in the library were found and fixed: Files with less than 5 bytes can now be parsed without error. The library now properly rejects any file encoding other than UTF-8. Furthermore, incorrect surrogate pairs are properly detected and rejected. The library now accepts all but one \"yes\" test (y_string_utf16.json): UTF-16 is not supported. The library rejects all but one \"no\" test (n_number_then_00.json): Null bytes are treated as end of file instead of an error. This allows to parse input from null-terminated strings. The string length passed to a user-defined string literal is now exploited to choose a more efficient constructor. A few grammar mistakes in the README file have been fixed.","title":"Changes"},{"location":"home/releases/#v206","text":"Files json.hpp (349 KB) json.hpp.asc (1 KB) Release date: 2016-10-15 SHA256: 459cc93d5e2f503e50c6d5876eb86bfea7daf405f5a567c5a2c9abc2383756ae","title":"v2.0.6"},{"location":"home/releases/#summary_21","text":"This release fixes the semantics of operator[] for JSON Pointers (see below). This fix is backwards compatible.","title":"Summary"},{"location":"home/releases/#changes_7","text":"operator[] for JSON Pointers now behaves like the other versions of operator[] and transforms null values into objects or arrays if required. This allows to created nested structues like j[\"/foo/bar/2\"] = 17 (yielding {\"foo\": \"bar\": [null, null, 17]} ) without problems. overworked a helper SFINAE function fixed some documentation issues fixed the CMake files to allow to run the test suite outside the main project directory restored test coverage to 100%.","title":"Changes"},{"location":"home/releases/#v205","text":"Files json.hpp (347 KB) json.hpp.asc (1 KB) Release date: 2016-09-14 SHA-256: 8b7565263a44e2b7d3b89808bc73d2d639037ff0c1f379e3d56dbd77e00b98d9","title":"v2.0.5"},{"location":"home/releases/#summary_22","text":"This release fixes a regression bug in the stream parser (function parse() and the << / >> operators). This fix is backwards compatible.","title":"Summary"},{"location":"home/releases/#changes_8","text":"Bug fix : The end of a file stream was not detected properly which led to parse errors. This bug should have been fixed with 2.0.4, but there was still a flaw in the code.","title":"Changes"},{"location":"home/releases/#v204","text":"Files json.hpp (347 KB) json.hpp.asc (1 KB) Release date: 2016-09-11 SHA-256: 632ceec4c25c4e2153f71470d3a2b992c8355f6d8b4d627d05dd16095cd3aeda","title":"v2.0.4"},{"location":"home/releases/#summary_23","text":"This release fixes a bug in the stream parser (function parse() and the << / >> operators). This fix is backwards compatible.","title":"Summary"},{"location":"home/releases/#changes_9","text":"Bug fix : The end of a file stream was not detected properly which led to parse errors. Fixed a compiler warning about an unused variable.","title":"Changes"},{"location":"home/releases/#v203","text":"Files json.hpp (347 KB) json.hpp.asc (1 KB) Release date: 2016-08-31 SHA-256: 535b73efe5546fde9e763c14aeadfc7b58183c0b3cd43c29741025aba6cf6bd3","title":"v2.0.3"},{"location":"home/releases/#summary_24","text":"This release combines a lot of small fixes and improvements. The release is backwards compatible.","title":"Summary"},{"location":"home/releases/#changes_10","text":"The parser/deserialization functions have been generalized to process any contiguous sequence of 1-byte elements (e.g., char , unsigned char , uint8_t ). This includes all kind of string representations (string literals, char arrays, std::string , const char* ), contiguous containers (C-style arrays, std::vector , std::array , std::valarray , std::initializer_list ). User-defined containers providing random-access iterator access via std::begin and std::end can be used as well. See the documentation ( 1 , 2 , 3 , 4 ) for more information. Note that contiguous storage cannot be checked at compile time; if any of the parse functions are called with a noncompliant container, the behavior is undefined and will most likely yield segmentation violation. The preconditions are enforced by an assertion unless the library is compiled with preprocessor symbol NDEBUG . As a general remark on assertions : The library uses assertions to preclude undefined behavior. A prominent example for this is the operator[] for const JSON objects. The behavior of this const version of the operator is undefined if the given key does not exist in the JSON object, because unlike the non-const version, it cannot add a null value at the given key. Assertions can be switched of by defining the preprocessor symbol NDEBUG . See the documentation of assert for more information. In the course of cleaning up the parser/deserialization functions, the constructor basic_json(std::istream&, const parser_callback_t) has been deprecated and will be deleted with the next major release 3.0.0 to unify the interface of the library. Deserialization will be done by stream operators or by calling one of the parse functions. That is, calls like json j(i); for an input stream i need to be replaced by json j = json::parse(i); . Compilers will produce a deprecation warning if client code uses this function. Minor improvements: Improved the performance of the serialization by avoiding the re-creation of a locale object. Fixed two MSVC warnings. Compiling the test suite with /Wall now only warns about non-inlined functions (C4710) and the deprecation of the constructor from input-stream (C4996). Some project internals: The project has qualified for the Core Infrastructure Initiative Best Practices Badge . While most requirements where already satisfied, some led to a more explicit documentation of quality-ensuring procedures. For instance, static analysis is now executed with every commit on the build server. Furthermore, the contribution guidelines document how to communicate security issues privately. The test suite has been overworked and split into several files to allow for faster compilation and analysis. The execute the test suite, simply execute make check . The continuous integration with Travis was extended with Clang versions 3.6.0 to 3.8.1 and now includes 18 different compiler/OS combinations. An 11-day run of American fuzzy lop checked 962 million inputs on the parser and found no issue.","title":"Changes"},{"location":"home/releases/#v202","text":"Files json.hpp (338 KB) json.hpp.asc (1 KB) Release date: 2016-07-31 SHA-256: 8e97b7965b4594b00998d6704465412360e1a0ed927badb51ded8b82291a8f3d","title":"v2.0.2"},{"location":"home/releases/#summary_25","text":"This release combines a lot of small fixes and improvements. The release is backwards compatible.","title":"Summary"},{"location":"home/releases/#changes_11","text":"The parser has been overworked, and a lot of small issues have been fixed: Improved parser performance by avoiding recursion and using move semantics for the return value. Unescaped control charaters \\x10 - \\x1f are not accepted any more. Fixed a bug in the parser when reading from an input stream. Improved test case coverage for UTF-8 parsing: now, all valid Unicode code points are tested both escaped and unescaped. The precision of output streams is now preserved by the parser. Started to check the code correctness by proving termination of important loops. Furthermore, individual assertions have been replaced by a more systematic function which checks the class invariants. Note that assertions should be switched off in production by defining the preprocessor macro NDEBUG , see the documentation of assert . A lot of code cleanup : removed unused headers, fixed some compiler warnings, and fixed a build error for Windows-based Clang builds. Added some compile-time checks: Unsupported compilers are rejected during compilation with an #error command. Static assertion prohibits code with incompatible pointer types used in get_ptr() . Improved the documentation , and adjusted the documentation script to choose the correct version of sed . Replaced a lot of \"raw loops\" by STL functions like std::all_of , std::for_each , or std::accumulate . This facilitates reasoning about termination of loops and sometimes allowed to simplify functions to a single return statement. Implemented a value() function for JSON pointers (similar to at function). The Homebrew formula (see Integration ) is now tested for all Xcode builds (6.1 - 8.x) with Travis. Avoided output to std::cout in the test cases.","title":"Changes"},{"location":"home/releases/#v201","text":"Files json.hpp (321 KB) json.hpp.asc (1 KB) Release date: 2016-06-28 SHA-256: ef550fcd7df572555bf068e9ec4e9d3b9e4cdd441cecb0dcea9ea7fd313f72dd","title":"v2.0.1"},{"location":"home/releases/#summary_26","text":"This release fixes a performance regression in the JSON serialization (function dump() ). This fix is backwards compatible.","title":"Summary"},{"location":"home/releases/#changes_12","text":"The locale of the output stream (or the internal string stream if a JSON value is serialized to a string) is now adjusted once for the whole serialization instead of for each floating-point number. The locale of an output stream is now correctly reset to the previous value by the JSON library.","title":"Changes"},{"location":"home/releases/#v200","text":"Files json.hpp (321 KB) json.hpp.asc (1 KB) Release date: 2016-06-24 SHA-256: ac9e1fb25c2ac9ca5fc501fcd2fe3281fe04f07018a1b48820e7b1b11491bb6c","title":"v2.0.0"},{"location":"home/releases/#summary_27","text":"This release adds several features such as JSON Pointers, JSON Patch, or support for 64 bit unsigned integers. Furthermore, several (subtle) bugs have been fixed. As noexcept and constexpr specifier have been added to several functions, the public API has effectively been changed in a (potential) non-backwards compatible manner. As we adhere to Semantic Versioning , this calls for a new major version, so say hello to 2\ufe0f\u20e3.0\ufe0f\u20e3.0\ufe0f\u20e3.","title":"Summary"},{"location":"home/releases/#changes_13","text":"\ud83d\udd1f A JSON value now uses uint64_t (default value for template parameter NumberUnsignedType ) as data type for unsigned integer values. This type is used automatically when an unsigned number is parsed. Furthermore, constructors, conversion operators and an is_number_unsigned() test have been added. \ud83d\udc49 JSON Pointer ( RFC 6901 ) support: A JSON Pointer is a string (similar to an XPath expression) to address a value inside a structured JSON value. JSON Pointers can be used in at() and operator[] functions. Furthermore, JSON values can be \u201cflattened\u201d to key/value pairs using flatten() where each key is a JSON Pointer. The original value can be restored by \u201cunflattening\u201d the flattened value using unflatten() . \ud83c\udfe5 JSON Patch ( RFC 6902 ) support. A JSON Patch is a JSON value that describes the required edit operations (add, change, remove, \u2026) to transform a JSON value into another one. A JSON Patch can be created with function diff(const basic_json&) and applied with patch(const basic_json&) . Note the created patches use a rather primitive algorithm so far and leave room for improvement. \ud83c\uddea\ud83c\uddfa The code is now locale-independent : Floating-point numbers are always serialized with a period ( . ) as decimal separator and ignores different settings from the locale. \ud83c\udf7a Homebrew support: Install the library with brew tap nlohmann/json && brew install nlohmann_json . Added constructor to create a JSON value by parsing a std::istream (e.g., std::stringstream or std::ifstream ). Added noexcept specifier to basic_json(boolean_t) , basic_json(const number_integer_t) , basic_json(const int) , basic_json(const number_float_t) , iterator functions ( begin() , end() , etc.) When parsing numbers, the sign of 0.0 (vs. -0.0 ) is preserved. Improved MSVC 2015, Android, and MinGW support. See README for more information. Improved test coverage (added 2,225,386 tests). Removed some misuses of std::move . Fixed several compiler warnings. Improved error messages from JSON parser. Updated to re2c to version 0.16 to use a minimal DFAs for the lexer. Updated test suite to use Catch version 1.5.6. Made type getters ( is_number , etc.) and const value access constexpr . Functions push_back and operator+= now work with key/value pairs passed as initializer list, e.g. j_object += {\"key\", 1} . Overworked CMakeLists.txt to make it easier to integrate the library into other projects.","title":"Changes"},{"location":"home/releases/#notes","text":"Parser error messages are still very vague and contain no information on the error location. The implemented diff function is rather primitive and does not create minimal diffs. The name of function iteration_wrapper may change in the future and the function will be deprecated in the next release. Roundtripping (i.e., parsing a JSON value from a string, serializing it, and comparing the strings) of floating-point numbers is not 100% accurate. Note that RFC 7159 defines no format to internally represent numbers and states not requirement for roundtripping. Nevertheless, benchmarks like Native JSON Benchmark treat roundtripping deviations as conformance errors.","title":"Notes"},{"location":"home/releases/#v110","text":"Files json.hpp (257 KB) json.hpp.asc (1 KB) Release date: 2016-01-24 SHA-256: c0cf0e3017798ca6bb18e757ebc570d21a3bdac877845e2b9e9573d183ed2f05","title":"v1.1.0"},{"location":"home/releases/#summary_28","text":"This release fixes several small bugs and adds functionality in a backwards-compatible manner. Compared to the last version (1.0.0) , the following changes have been made:","title":"Summary"},{"location":"home/releases/#changes_14","text":"Fixed : Floating-point numbers are now serialized and deserialized properly such that rountripping works in more cases. [#185, #186, #190, #191, #194] Added : The code now contains assertions to detect undefined behavior during development. As the standard function assert is used, the assertions can be switched off by defining the preprocessor symbol NDEBUG during compilation. [#168] Added : It is now possible to get a reference to the stored values via the newly added function get_ref() . [#128, #184] Fixed : Access to object values via keys ( operator[] ) now works with all kind of string representations. [#171, #189] Fixed : The code now compiles again with Microsoft Visual Studio 2015 . [#144, #167, #188] Fixed : All required headers are now included. Fixed : Typos and other small issues. [#162, #166, #175, #177, #179, #180]","title":"Changes"},{"location":"home/releases/#notes_1","text":"There are still known open issues (#178, #187) which will be fixed in version 2.0.0. However, these fixes will require a small API change and will not be entirely backwards-compatible.","title":"Notes"},{"location":"home/releases/#v100","text":"Files json.hpp (243 KB) json.hpp.asc (1 KB) Release date: 2015-12-28 SHA-256: 767dc2fab1819d7b9e19b6e456d61e38d21ef7182606ecf01516e3f5230446de","title":"v1.0.0"},{"location":"home/releases/#summary_29","text":"This is the first official release. Compared to the prerelease version 1.0.0-rc1 , only a few minor improvements have been made:","title":"Summary"},{"location":"home/releases/#changes_15","text":"Changed : A UTF-8 byte order mark is silently ignored. Changed : sprintf is no longer used. Changed : iterator_wrapper also works for const objects; note: the name may change! Changed : Error messages during deserialization have been improved. Added : The parse function now also works with type std::istream&& . Added : Function value(key, default_value) returns either a copy of an object's element at the specified key or a given default value if no element with the key exists. Added : Public functions are tagged with the version they were introduced. This shall allow for better versioning in the future. Added : All public functions and types are documented (see http://nlohmann.github.io/json/doxygen/ ) including executable examples. Added : Allocation of all types (in particular arrays, strings, and objects) is now exception-safe. Added : They descriptions of thrown exceptions have been overworked and are part of the tests suite and documentation.","title":"Changes"},{"location":"home/sponsors/","text":"Sponsors \u00b6 You can sponsor this library at GitHub Sponsors . Named Sponsors \u00b6 Michael Hartmann Stefan Hagen Steve Sperandeo Thanks everyone!","title":"Sponsors"},{"location":"home/sponsors/#sponsors","text":"You can sponsor this library at GitHub Sponsors .","title":"Sponsors"},{"location":"home/sponsors/#named-sponsors","text":"Michael Hartmann Stefan Hagen Steve Sperandeo Thanks everyone!","title":"Named Sponsors"},{"location":"integration/","text":"Integration \u00b6 json.hpp is the single required file in single_include/nlohmann or released here . You need to add #include <nlohmann/json.hpp> // for convenience using json = nlohmann :: json ; to the files you want to process JSON and set the necessary switches to enable C++11 (e.g., -std=c++11 for GCC and Clang). You can further use file include/nlohmann/json_fwd.hpp for forward-declarations. The installation of json_fwd.hpp (as part of cmake's install step), can be achieved by setting -DJSON_MultipleHeaders=ON .","title":"Integration"},{"location":"integration/#integration","text":"json.hpp is the single required file in single_include/nlohmann or released here . You need to add #include <nlohmann/json.hpp> // for convenience using json = nlohmann :: json ; to the files you want to process JSON and set the necessary switches to enable C++11 (e.g., -std=c++11 for GCC and Clang). You can further use file include/nlohmann/json_fwd.hpp for forward-declarations. The installation of json_fwd.hpp (as part of cmake's install step), can be achieved by setting -DJSON_MultipleHeaders=ON .","title":"Integration"},{"location":"integration/cmake/","text":"CMake \u00b6 You can also use the nlohmann_json::nlohmann_json interface target in CMake. This target populates the appropriate usage requirements for INTERFACE_INCLUDE_DIRECTORIES to point to the appropriate include directories and INTERFACE_COMPILE_FEATURES for the necessary C++11 flags. External \u00b6 To use this library from a CMake project, you can locate it directly with find_package() and use the namespaced imported target from the generated package configuration: # CMakeLists.txt find_package ( nlohmann_json 3.2.0 REQUIRED ) ... add_library ( foo ... ) ... target_link_libraries ( foo PRIVATE nlohmann_json::nlohmann_json ) The package configuration file, nlohmann_jsonConfig.cmake , can be used either from an install tree or directly out of the build tree. Embedded \u00b6 To embed the library directly into an existing CMake project, place the entire source tree in a subdirectory and call add_subdirectory() in your CMakeLists.txt file: # Typically you don't care so much for a third party library's tests to be # run from your own project's code. set ( JSON_BuildTests OFF CACHE INTERNAL \"\" ) # If you only include this third party in PRIVATE source files, you do not # need to install it when your main project gets installed. # set(JSON_Install OFF CACHE INTERNAL \"\") # Don't use include(nlohmann_json/CMakeLists.txt) since that carries with it # unintended consequences that will break the build. It's generally # discouraged (although not necessarily well documented as such) to use # include(...) for pulling in other CMake projects anyways. add_subdirectory ( nlohmann_json ) ... add_library ( foo ... ) ... target_link_libraries ( foo PRIVATE nlohmann_json::nlohmann_json ) Embedded (FetchContent) \u00b6 Since CMake v3.11, FetchContent can be used to automatically download the repository as a dependency at configure type. Example: include ( FetchContent ) FetchContent_Declare ( json GIT_REPOSITORY https://github.com/nlohmann/json GIT_TAG v3.7.3 ) FetchContent_GetProperties ( json ) if ( NOT json_POPULATED ) FetchContent_Populate ( json ) add_subdirectory ( ${ json_SOURCE_DIR } ${ json_BINARY_DIR } EXCLUDE_FROM_ALL ) endif () target_link_libraries ( foo PRIVATE nlohmann_json::nlohmann_json ) Note The repository https://github.com/nlohmann/json download size is huge. It contains all the dataset used for the benchmarks. You might want to depend on a smaller repository. For instance, you might want to replace the URL above by https://github.com/ArthurSonzogni/nlohmann_json_cmake_fetchcontent . Supporting Both \u00b6 To allow your project to support either an externally supplied or an embedded JSON library, you can use a pattern akin to the following: # Top level CMakeLists.txt project ( FOO ) ... option ( FOO_USE_EXTERNAL_JSON \"Use an external JSON library\" OFF ) ... add_subdirectory ( thirdparty ) ... add_library ( foo ... ) ... # Note that the namespaced target will always be available regardless of the # import method target_link_libraries ( foo PRIVATE nlohmann_json::nlohmann_json ) # thirdparty/CMakeLists.txt ... if ( FOO_USE_EXTERNAL_JSON ) find_package ( nlohmann_json 3.2.0 REQUIRED ) else () set ( JSON_BuildTests OFF CACHE INTERNAL \"\" ) add_subdirectory ( nlohmann_json ) endif () ... thirdparty/nlohmann_json is then a complete copy of this source tree.","title":"CMake"},{"location":"integration/cmake/#cmake","text":"You can also use the nlohmann_json::nlohmann_json interface target in CMake. This target populates the appropriate usage requirements for INTERFACE_INCLUDE_DIRECTORIES to point to the appropriate include directories and INTERFACE_COMPILE_FEATURES for the necessary C++11 flags.","title":"CMake"},{"location":"integration/cmake/#external","text":"To use this library from a CMake project, you can locate it directly with find_package() and use the namespaced imported target from the generated package configuration: # CMakeLists.txt find_package ( nlohmann_json 3.2.0 REQUIRED ) ... add_library ( foo ... ) ... target_link_libraries ( foo PRIVATE nlohmann_json::nlohmann_json ) The package configuration file, nlohmann_jsonConfig.cmake , can be used either from an install tree or directly out of the build tree.","title":"External"},{"location":"integration/cmake/#embedded","text":"To embed the library directly into an existing CMake project, place the entire source tree in a subdirectory and call add_subdirectory() in your CMakeLists.txt file: # Typically you don't care so much for a third party library's tests to be # run from your own project's code. set ( JSON_BuildTests OFF CACHE INTERNAL \"\" ) # If you only include this third party in PRIVATE source files, you do not # need to install it when your main project gets installed. # set(JSON_Install OFF CACHE INTERNAL \"\") # Don't use include(nlohmann_json/CMakeLists.txt) since that carries with it # unintended consequences that will break the build. It's generally # discouraged (although not necessarily well documented as such) to use # include(...) for pulling in other CMake projects anyways. add_subdirectory ( nlohmann_json ) ... add_library ( foo ... ) ... target_link_libraries ( foo PRIVATE nlohmann_json::nlohmann_json )","title":"Embedded"},{"location":"integration/cmake/#embedded-fetchcontent","text":"Since CMake v3.11, FetchContent can be used to automatically download the repository as a dependency at configure type. Example: include ( FetchContent ) FetchContent_Declare ( json GIT_REPOSITORY https://github.com/nlohmann/json GIT_TAG v3.7.3 ) FetchContent_GetProperties ( json ) if ( NOT json_POPULATED ) FetchContent_Populate ( json ) add_subdirectory ( ${ json_SOURCE_DIR } ${ json_BINARY_DIR } EXCLUDE_FROM_ALL ) endif () target_link_libraries ( foo PRIVATE nlohmann_json::nlohmann_json ) Note The repository https://github.com/nlohmann/json download size is huge. It contains all the dataset used for the benchmarks. You might want to depend on a smaller repository. For instance, you might want to replace the URL above by https://github.com/ArthurSonzogni/nlohmann_json_cmake_fetchcontent .","title":"Embedded (FetchContent)"},{"location":"integration/cmake/#supporting-both","text":"To allow your project to support either an externally supplied or an embedded JSON library, you can use a pattern akin to the following: # Top level CMakeLists.txt project ( FOO ) ... option ( FOO_USE_EXTERNAL_JSON \"Use an external JSON library\" OFF ) ... add_subdirectory ( thirdparty ) ... add_library ( foo ... ) ... # Note that the namespaced target will always be available regardless of the # import method target_link_libraries ( foo PRIVATE nlohmann_json::nlohmann_json ) # thirdparty/CMakeLists.txt ... if ( FOO_USE_EXTERNAL_JSON ) find_package ( nlohmann_json 3.2.0 REQUIRED ) else () set ( JSON_BuildTests OFF CACHE INTERNAL \"\" ) add_subdirectory ( nlohmann_json ) endif () ... thirdparty/nlohmann_json is then a complete copy of this source tree.","title":"Supporting Both"},{"location":"integration/package_managers/","text":"Package Managers \u00b6 Throughout this page, we will describe how to compile the example file example.cpp below. #include <nlohmann/json.hpp> #include <iostream> using json = nlohmann :: json ; int main () { std :: cout << json :: meta () << std :: endl ; } Homebrew \u00b6 If you are using OS X and Homebrew , just type brew tap nlohmann/json brew install nlohmann-json and you're set. If you want the bleeding edge rather than the latest release, use brew tap nlohmann/json brew install nlohmann-json --HEAD instead. Example Create the following file: example.cpp #include <nlohmann/json.hpp> #include <iostream> using json = nlohmann :: json ; int main () { std :: cout << json :: meta () << std :: endl ; } Install the package brew tap nlohmann/json brew install nlohmann-json Determine the include path, which defaults to /usr/local/Cellar/nlohmann-json/$version/include , where $version is the version of the library, e.g. 3.7.3 . The path of the library can be determined with brew list nlohmann-json Compile the code. For instance, the code can be compiled using Clang with clang++ example.cpp -I/usr/local/Cellar/nlohmann-json/3.7.3/include -std = c++11 -o example Meson \u00b6 If you are using the Meson Build System , add this source tree as a meson subproject . You may also use the include.zip published in this project's Releases to reduce the size of the vendored source tree. Alternatively, you can get a wrap file by downloading it from Meson WrapDB , or simply use meson wrap install nlohmann_json . Please see the meson project for any issues regarding the packaging. The provided meson.build can also be used as an alternative to cmake for installing nlohmann_json system-wide in which case a pkg-config file is installed. To use it, simply have your build system require the nlohmann_json pkg-config dependency. In Meson, it is preferred to use the dependency() object with a subproject fallback, rather than using the subproject directly. Conan \u00b6 If you are using Conan to manage your dependencies, merely add nlohmann_json/x.y.z to your conanfile 's requires, where x.y.z is the release version you want to use. Please file issues here if you experience problems with the packages. Example Create the following files: Conanfile.txt [requires] nlohmann_json/3.7.3 [generators] cmake CMakeLists.txt project ( json_example ) cmake_minimum_required ( VERSION 2.8.12 ) add_definitions ( \"-std=c++11\" ) include ( ${ CMAKE_BINARY_DIR } /conanbuildinfo.cmake ) conan_basic_setup () add_executable ( json_example example.cpp ) target_link_libraries ( json_example ${ CONAN_LIBS } ) example.cpp #include <nlohmann/json.hpp> #include <iostream> using json = nlohmann :: json ; int main () { std :: cout << json :: meta () << std :: endl ; } Build: mkdir build cd build conan install .. cmake .. cmake --build . Spack \u00b6 If you are using Spack to manage your dependencies, you can use the nlohmann-json package . Please see the spack project for any issues regarding the packaging. Hunter \u00b6 If you are using hunter on your project for external dependencies, then you can use the nlohmann_json package . Please see the hunter project for any issues regarding the packaging. Buckaroo \u00b6 If you are using Buckaroo , you can install this library's module with buckaroo add github.com/buckaroo-pm/nlohmann-json . Please file issues here . There is a demo repo here . vcpkg \u00b6 If you are using vcpkg on your project for external dependencies, then you can use the nlohmann-json package . Please see the vcpkg project for any issues regarding the packaging. cget \u00b6 If you are using cget , you can install the latest development version with cget install nlohmann/json . A specific version can be installed with cget install nlohmann/json@v3.1.0 . Also, the multiple header version can be installed by adding the -DJSON_MultipleHeaders=ON flag (i.e., cget install nlohmann/json -DJSON_MultipleHeaders=ON ). CocoaPods \u00b6 If you are using CocoaPods , you can use the library by adding pod \"nlohmann_json\", '~>3.1.2' to your podfile (see an example ). Please file issues here . NuGet \u00b6 If you are using NuGet , you can use the package nlohmann.json . Please check this extensive description on how to use the package. Please files issues here . Conda \u00b6 If you are using conda , you can use the package nlohmann_json from conda-forge executing conda install -c conda-forge nlohmann_json . Please file issues here . MSYS2 \u00b6 If you are using MSYS2 , your can use the mingw-w64-nlohmann-json package, just type pacman -S mingw-w64-i686-nlohmann-json or pacman -S mingw-w64-x86_64-nlohmann-json for installation. Please file issues here if you experience problems with the packages. build2 \u00b6 If you are using build2 , you can use the nlohmann-json package from the public repository http://cppget.org or directly from the package's sources repository . In your project's manifest file, just add depends: nlohmann-json (probably with some version constraints ). If you are not familiar with using dependencies in build2 , please read this introduction . Please file issues here if you experience problems with the packages. wsjcpp \u00b6 If you are using wsjcpp , you can use the command wsjcpp install \"https://github.com/nlohmann/json:develop\" to get the latest version. Note you can change the branch \":develop\" to an existing tag or another branch.","title":"Package Managers"},{"location":"integration/package_managers/#package-managers","text":"Throughout this page, we will describe how to compile the example file example.cpp below. #include <nlohmann/json.hpp> #include <iostream> using json = nlohmann :: json ; int main () { std :: cout << json :: meta () << std :: endl ; }","title":"Package Managers"},{"location":"integration/package_managers/#homebrew","text":"If you are using OS X and Homebrew , just type brew tap nlohmann/json brew install nlohmann-json and you're set. If you want the bleeding edge rather than the latest release, use brew tap nlohmann/json brew install nlohmann-json --HEAD instead. Example Create the following file: example.cpp #include <nlohmann/json.hpp> #include <iostream> using json = nlohmann :: json ; int main () { std :: cout << json :: meta () << std :: endl ; } Install the package brew tap nlohmann/json brew install nlohmann-json Determine the include path, which defaults to /usr/local/Cellar/nlohmann-json/$version/include , where $version is the version of the library, e.g. 3.7.3 . The path of the library can be determined with brew list nlohmann-json Compile the code. For instance, the code can be compiled using Clang with clang++ example.cpp -I/usr/local/Cellar/nlohmann-json/3.7.3/include -std = c++11 -o example","title":"Homebrew"},{"location":"integration/package_managers/#meson","text":"If you are using the Meson Build System , add this source tree as a meson subproject . You may also use the include.zip published in this project's Releases to reduce the size of the vendored source tree. Alternatively, you can get a wrap file by downloading it from Meson WrapDB , or simply use meson wrap install nlohmann_json . Please see the meson project for any issues regarding the packaging. The provided meson.build can also be used as an alternative to cmake for installing nlohmann_json system-wide in which case a pkg-config file is installed. To use it, simply have your build system require the nlohmann_json pkg-config dependency. In Meson, it is preferred to use the dependency() object with a subproject fallback, rather than using the subproject directly.","title":"Meson"},{"location":"integration/package_managers/#conan","text":"If you are using Conan to manage your dependencies, merely add nlohmann_json/x.y.z to your conanfile 's requires, where x.y.z is the release version you want to use. Please file issues here if you experience problems with the packages. Example Create the following files: Conanfile.txt [requires] nlohmann_json/3.7.3 [generators] cmake CMakeLists.txt project ( json_example ) cmake_minimum_required ( VERSION 2.8.12 ) add_definitions ( \"-std=c++11\" ) include ( ${ CMAKE_BINARY_DIR } /conanbuildinfo.cmake ) conan_basic_setup () add_executable ( json_example example.cpp ) target_link_libraries ( json_example ${ CONAN_LIBS } ) example.cpp #include <nlohmann/json.hpp> #include <iostream> using json = nlohmann :: json ; int main () { std :: cout << json :: meta () << std :: endl ; } Build: mkdir build cd build conan install .. cmake .. cmake --build .","title":"Conan"},{"location":"integration/package_managers/#spack","text":"If you are using Spack to manage your dependencies, you can use the nlohmann-json package . Please see the spack project for any issues regarding the packaging.","title":"Spack"},{"location":"integration/package_managers/#hunter","text":"If you are using hunter on your project for external dependencies, then you can use the nlohmann_json package . Please see the hunter project for any issues regarding the packaging.","title":"Hunter"},{"location":"integration/package_managers/#buckaroo","text":"If you are using Buckaroo , you can install this library's module with buckaroo add github.com/buckaroo-pm/nlohmann-json . Please file issues here . There is a demo repo here .","title":"Buckaroo"},{"location":"integration/package_managers/#vcpkg","text":"If you are using vcpkg on your project for external dependencies, then you can use the nlohmann-json package . Please see the vcpkg project for any issues regarding the packaging.","title":"vcpkg"},{"location":"integration/package_managers/#cget","text":"If you are using cget , you can install the latest development version with cget install nlohmann/json . A specific version can be installed with cget install nlohmann/json@v3.1.0 . Also, the multiple header version can be installed by adding the -DJSON_MultipleHeaders=ON flag (i.e., cget install nlohmann/json -DJSON_MultipleHeaders=ON ).","title":"cget"},{"location":"integration/package_managers/#cocoapods","text":"If you are using CocoaPods , you can use the library by adding pod \"nlohmann_json\", '~>3.1.2' to your podfile (see an example ). Please file issues here .","title":"CocoaPods"},{"location":"integration/package_managers/#nuget","text":"If you are using NuGet , you can use the package nlohmann.json . Please check this extensive description on how to use the package. Please files issues here .","title":"NuGet"},{"location":"integration/package_managers/#conda","text":"If you are using conda , you can use the package nlohmann_json from conda-forge executing conda install -c conda-forge nlohmann_json . Please file issues here .","title":"Conda"},{"location":"integration/package_managers/#msys2","text":"If you are using MSYS2 , your can use the mingw-w64-nlohmann-json package, just type pacman -S mingw-w64-i686-nlohmann-json or pacman -S mingw-w64-x86_64-nlohmann-json for installation. Please file issues here if you experience problems with the packages.","title":"MSYS2"},{"location":"integration/package_managers/#build2","text":"If you are using build2 , you can use the nlohmann-json package from the public repository http://cppget.org or directly from the package's sources repository . In your project's manifest file, just add depends: nlohmann-json (probably with some version constraints ). If you are not familiar with using dependencies in build2 , please read this introduction . Please file issues here if you experience problems with the packages.","title":"build2"},{"location":"integration/package_managers/#wsjcpp","text":"If you are using wsjcpp , you can use the command wsjcpp install \"https://github.com/nlohmann/json:develop\" to get the latest version. Note you can change the branch \":develop\" to an existing tag or another branch.","title":"wsjcpp"}]}